<!DOCTYPE html>

<html>
<head>
  <title>highstock.src.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="AJAXCompleter.html">
                  AJAXCompleter.js
                </a>
              
                
                <a class="source" href="AJAXEmailClientCompleter.html">
                  AJAXEmailClientCompleter.js
                </a>
              
                
                <a class="source" href="AJAXOtherCompleter.html">
                  AJAXOtherCompleter.js
                </a>
              
                
                <a class="source" href="AJAXReferenceChoice.html">
                  AJAXReferenceChoice.js
                </a>
              
                
                <a class="source" href="AJAXReferenceCompleter.html">
                  AJAXReferenceCompleter.js
                </a>
              
                
                <a class="source" href="AJAXReferenceCompleterMulti.html">
                  AJAXReferenceCompleterMulti.js
                </a>
              
                
                <a class="source" href="AJAXReferenceControls.html">
                  AJAXReferenceControls.js
                </a>
              
                
                <a class="source" href="AJAXTableCompleter.html">
                  AJAXTableCompleter.js
                </a>
              
                
                <a class="source" href="AngularBootstrapper.html">
                  AngularBootstrapper.js
                </a>
              
                
                <a class="source" href="AttachmentUploader.html">
                  AttachmentUploader.js
                </a>
              
                
                <a class="source" href="AutoComplete.html">
                  AutoComplete.js
                </a>
              
                
                <a class="source" href="BindWatch.html">
                  BindWatch.js
                </a>
              
                
                <a class="source" href="CookieJar.html">
                  CookieJar.js
                </a>
              
                
                <a class="source" href="CustomEventManager.html">
                  CustomEventManager.js
                </a>
              
                
                <a class="source" href="DaysOfWeekElement.html">
                  DaysOfWeekElement.js
                </a>
              
                
                <a class="source" href="DerivedFields.html">
                  DerivedFields.js
                </a>
              
                
                <a class="source" href="FieldListElement.html">
                  FieldListElement.js
                </a>
              
                
                <a class="source" href="FormAdditionalOptionsMenu.html">
                  FormAdditionalOptionsMenu.js
                </a>
              
                
                <a class="source" href="GlideAPI1.html">
                  GlideAPI1.js
                </a>
              
                
                <a class="source" href="GlideAjax.html">
                  GlideAjax.js
                </a>
              
                
                <a class="source" href="GlideAjaxForm.html">
                  GlideAjaxForm.js
                </a>
              
                
                <a class="source" href="GlideBox.html">
                  GlideBox.js
                </a>
              
                
                <a class="source" href="GlideClientCache.html">
                  GlideClientCache.js
                </a>
              
                
                <a class="source" href="GlideDecoration.html">
                  GlideDecoration.js
                </a>
              
                
                <a class="source" href="GlideDialogForm.html">
                  GlideDialogForm.js
                </a>
              
                
                <a class="source" href="GlideDialogWindow.html">
                  GlideDialogWindow.js
                </a>
              
                
                <a class="source" href="GlideDraggable.html">
                  GlideDraggable.js
                </a>
              
                
                <a class="source" href="GlideDuration.html">
                  GlideDuration.js
                </a>
              
                
                <a class="source" href="GlideEvent.html">
                  GlideEvent.js
                </a>
              
                
                <a class="source" href="GlideEventHandler.html">
                  GlideEventHandler.js
                </a>
              
                
                <a class="source" href="GlideFilter14.html">
                  GlideFilter14.js
                </a>
              
                
                <a class="source" href="GlideFilterDate.html">
                  GlideFilterDate.js
                </a>
              
                
                <a class="source" href="GlideFilterDescription.html">
                  GlideFilterDescription.js
                </a>
              
                
                <a class="source" href="GlideFilterHandlers.html">
                  GlideFilterHandlers.js
                </a>
              
                
                <a class="source" href="GlideFilterItemVariables.html">
                  GlideFilterItemVariables.js
                </a>
              
                
                <a class="source" href="GlideFilterLabels.html">
                  GlideFilterLabels.js
                </a>
              
                
                <a class="source" href="GlideFilterQuestions.html">
                  GlideFilterQuestions.js
                </a>
              
                
                <a class="source" href="GlideFilterReference.html">
                  GlideFilterReference.js
                </a>
              
                
                <a class="source" href="GlideFilterReferenceMulti.html">
                  GlideFilterReferenceMulti.js
                </a>
              
                
                <a class="source" href="GlideFilterVariableMap.html">
                  GlideFilterVariableMap.js
                </a>
              
                
                <a class="source" href="GlideFilterVariables.html">
                  GlideFilterVariables.js
                </a>
              
                
                <a class="source" href="GlideForm14.html">
                  GlideForm14.js
                </a>
              
                
                <a class="source" href="GlideHeaderSearch.html">
                  GlideHeaderSearch.js
                </a>
              
                
                <a class="source" href="GlideList2.html">
                  GlideList2.js
                </a>
              
                
                <a class="source" href="GlideList2FilterUtil.html">
                  GlideList2FilterUtil.js
                </a>
              
                
                <a class="source" href="GlideList2Handlers.html">
                  GlideList2Handlers.js
                </a>
              
                
                <a class="source" href="GlideList2InitEvents.html">
                  GlideList2InitEvents.js
                </a>
              
                
                <a class="source" href="GlideList2Statics.html">
                  GlideList2Statics.js
                </a>
              
                
                <a class="source" href="GlideListAggregates.html">
                  GlideListAggregates.js
                </a>
              
                
                <a class="source" href="GlideListEditor.html">
                  GlideListEditor.js
                </a>
              
                
                <a class="source" href="GlideListEditorMessaging.html">
                  GlideListEditorMessaging.js
                </a>
              
                
                <a class="source" href="GlideListElement.html">
                  GlideListElement.js
                </a>
              
                
                <a class="source" href="GlideListWidget.html">
                  GlideListWidget.js
                </a>
              
                
                <a class="source" href="GlideListv3Compatibility.html">
                  GlideListv3Compatibility.js
                </a>
              
                
                <a class="source" href="GlideModal.html">
                  GlideModal.js
                </a>
              
                
                <a class="source" href="GlideModalForm.html">
                  GlideModalForm.js
                </a>
              
                
                <a class="source" href="GlideNavigation.html">
                  GlideNavigation.js
                </a>
              
                
                <a class="source" href="GlideOverlay.html">
                  GlideOverlay.js
                </a>
              
                
                <a class="source" href="GlidePane.html">
                  GlidePane.js
                </a>
              
                
                <a class="source" href="GlidePaneForm.html">
                  GlidePaneForm.js
                </a>
              
                
                <a class="source" href="GlideRecord.html">
                  GlideRecord.js
                </a>
              
                
                <a class="source" href="GlideTabs2.html">
                  GlideTabs2.js
                </a>
              
                
                <a class="source" href="GlideTabs2State.html">
                  GlideTabs2State.js
                </a>
              
                
                <a class="source" href="GlideTabs2Tab.html">
                  GlideTabs2Tab.js
                </a>
              
                
                <a class="source" href="GlideTimeElement.html">
                  GlideTimeElement.js
                </a>
              
                
                <a class="source" href="GlideTimerElement.html">
                  GlideTimerElement.js
                </a>
              
                
                <a class="source" href="GlideTransactionScope.html">
                  GlideTransactionScope.js
                </a>
              
                
                <a class="source" href="GlideUI.html">
                  GlideUI.js
                </a>
              
                
                <a class="source" href="GlideUIDefault.html">
                  GlideUIDefault.js
                </a>
              
                
                <a class="source" href="GlideUIElement.html">
                  GlideUIElement.js
                </a>
              
                
                <a class="source" href="GlideUINotification.html">
                  GlideUINotification.js
                </a>
              
                
                <a class="source" href="GlideURL.html">
                  GlideURL.js
                </a>
              
                
                <a class="source" href="GlideURLElement.html">
                  GlideURLElement.js
                </a>
              
                
                <a class="source" href="GlideUrlBuilder.html">
                  GlideUrlBuilder.js
                </a>
              
                
                <a class="source" href="GlideUser.html">
                  GlideUser.js
                </a>
              
                
                <a class="source" href="GlideUserImageElement.html">
                  GlideUserImageElement.js
                </a>
              
                
                <a class="source" href="GlideVideoPlayer.html">
                  GlideVideoPlayer.js
                </a>
              
                
                <a class="source" href="GlideWebAnalytics.html">
                  GlideWebAnalytics.js
                </a>
              
                
                <a class="source" href="GlideWidgetActions.html">
                  GlideWidgetActions.js
                </a>
              
                
                <a class="source" href="GlideWidgetFilter.html">
                  GlideWidgetFilter.js
                </a>
              
                
                <a class="source" href="GlideWidgetHideOnEmpty.html">
                  GlideWidgetHideOnEmpty.js
                </a>
              
                
                <a class="source" href="GlideWidgetSearch.html">
                  GlideWidgetSearch.js
                </a>
              
                
                <a class="source" href="GlideWidgetVCR.html">
                  GlideWidgetVCR.js
                </a>
              
                
                <a class="source" href="GlideWindow.html">
                  GlideWindow.js
                </a>
              
                
                <a class="source" href="GuidedTourElementTranslator.html">
                  GuidedTourElementTranslator.js
                </a>
              
                
                <a class="source" href="GwtCellEditor.html">
                  GwtCellEditor.js
                </a>
              
                
                <a class="source" href="GwtCellSelector.html">
                  GwtCellSelector.js
                </a>
              
                
                <a class="source" href="GwtContextMenu.html">
                  GwtContextMenu.js
                </a>
              
                
                <a class="source" href="GwtCursor.html">
                  GwtCursor.js
                </a>
              
                
                <a class="source" href="GwtDate.html">
                  GwtDate.js
                </a>
              
                
                <a class="source" href="GwtDraggable.html">
                  GwtDraggable.js
                </a>
              
                
                <a class="source" href="GwtDraggableSnap.html">
                  GwtDraggableSnap.js
                </a>
              
                
                <a class="source" href="GwtExportScheduleDialog.html">
                  GwtExportScheduleDialog.js
                </a>
              
                
                <a class="source" href="GwtGridEdit.html">
                  GwtGridEdit.js
                </a>
              
                
                <a class="source" href="GwtListEditAjaxChangeSaver.html">
                  GwtListEditAjaxChangeSaver.js
                </a>
              
                
                <a class="source" href="GwtListEditAjaxValueLoader.html">
                  GwtListEditAjaxValueLoader.js
                </a>
              
                
                <a class="source" href="GwtListEditBoolean.html">
                  GwtListEditBoolean.js
                </a>
              
                
                <a class="source" href="GwtListEditCalendar.html">
                  GwtListEditCalendar.js
                </a>
              
                
                <a class="source" href="GwtListEditDependent.html">
                  GwtListEditDependent.js
                </a>
              
                
                <a class="source" href="GwtListEditDuration.html">
                  GwtListEditDuration.js
                </a>
              
                
                <a class="source" href="GwtListEditEncryptedText.html">
                  GwtListEditEncryptedText.js
                </a>
              
                
                <a class="source" href="GwtListEditError.html">
                  GwtListEditError.js
                </a>
              
                
                <a class="source" href="GwtListEditGList.html">
                  GwtListEditGList.js
                </a>
              
                
                <a class="source" href="GwtListEditGlideRecord.html">
                  GwtListEditGlideRecord.js
                </a>
              
                
                <a class="source" href="GwtListEditGridSelector.html">
                  GwtListEditGridSelector.js
                </a>
              
                
                <a class="source" href="GwtListEditInternalType.html">
                  GwtListEditInternalType.js
                </a>
              
                
                <a class="source" href="GwtListEditJournal.html">
                  GwtListEditJournal.js
                </a>
              
                
                <a class="source" href="GwtListEditMultiText.html">
                  GwtListEditMultiText.js
                </a>
              
                
                <a class="source" href="GwtListEditPassword.html">
                  GwtListEditPassword.js
                </a>
              
                
                <a class="source" href="GwtListEditRecord.html">
                  GwtListEditRecord.js
                </a>
              
                
                <a class="source" href="GwtListEditRecordDecorations.html">
                  GwtListEditRecordDecorations.js
                </a>
              
                
                <a class="source" href="GwtListEditReference.html">
                  GwtListEditReference.js
                </a>
              
                
                <a class="source" href="GwtListEditRelatedTags.html">
                  GwtListEditRelatedTags.js
                </a>
              
                
                <a class="source" href="GwtListEditSavePolicy.html">
                  GwtListEditSavePolicy.js
                </a>
              
                
                <a class="source" href="GwtListEditSelect.html">
                  GwtListEditSelect.js
                </a>
              
                
                <a class="source" href="GwtListEditTableController.html">
                  GwtListEditTableController.js
                </a>
              
                
                <a class="source" href="GwtListEditTablename.html">
                  GwtListEditTablename.js
                </a>
              
                
                <a class="source" href="GwtListEditText.html">
                  GwtListEditText.js
                </a>
              
                
                <a class="source" href="GwtListEditTranslatedField.html">
                  GwtListEditTranslatedField.js
                </a>
              
                
                <a class="source" href="GwtListEditUpdateTablename.html">
                  GwtListEditUpdateTablename.js
                </a>
              
                
                <a class="source" href="GwtListEditValueRenderer.html">
                  GwtListEditValueRenderer.js
                </a>
              
                
                <a class="source" href="GwtListEditWindow.html">
                  GwtListEditWindow.js
                </a>
              
                
                <a class="source" href="GwtListEditor.html">
                  GwtListEditor.js
                </a>
              
                
                <a class="source" href="GwtListEditorPendingChanges.html">
                  GwtListEditorPendingChanges.js
                </a>
              
                
                <a class="source" href="GwtMessage14.html">
                  GwtMessage14.js
                </a>
              
                
                <a class="source" href="GwtObservable.html">
                  GwtObservable.js
                </a>
              
                
                <a class="source" href="GwtPollDialog.html">
                  GwtPollDialog.js
                </a>
              
                
                <a class="source" href="InPlaceEdit.html">
                  InPlaceEdit.js
                </a>
              
                
                <a class="source" href="KeyboardRegistry.html">
                  KeyboardRegistry.js
                </a>
              
                
                <a class="source" href="LAB.min.html">
                  LAB.min.js
                </a>
              
                
                <a class="source" href="NOW.messaging.html">
                  NOW.messaging.js
                </a>
              
                
                <a class="source" href="NOW.messaging.record.html">
                  NOW.messaging.record.js
                </a>
              
                
                <a class="source" href="NameMapEntry.html">
                  NameMapEntry.js
                </a>
              
                
                <a class="source" href="Notification.html">
                  Notification.js
                </a>
              
                
                <a class="source" href="NotificationMessage.html">
                  NotificationMessage.js
                </a>
              
                
                <a class="source" href="PageTiming14.html">
                  PageTiming14.js
                </a>
              
                
                <a class="source" href="PageTimingService.html">
                  PageTimingService.js
                </a>
              
                
                <a class="source" href="PersonalizeForm.html">
                  PersonalizeForm.js
                </a>
              
                
                <a class="source" href="Point.html">
                  Point.js
                </a>
              
                
                <a class="source" href="SLARepairClient.html">
                  SLARepairClient.js
                </a>
              
                
                <a class="source" href="ScriptLoader.html">
                  ScriptLoader.js
                </a>
              
                
                <a class="source" href="Select.html">
                  Select.js
                </a>
              
                
                <a class="source" href="SingletonKeyboardRegistry.html">
                  SingletonKeyboardRegistry.js
                </a>
              
                
                <a class="source" href="SlushBucket.html">
                  SlushBucket.js
                </a>
              
                
                <a class="source" href="StopWatch.html">
                  StopWatch.js
                </a>
              
                
                <a class="source" href="Table.html">
                  Table.js
                </a>
              
                
                <a class="source" href="TableElement.html">
                  TableElement.js
                </a>
              
                
                <a class="source" href="TableExtension.html">
                  TableExtension.js
                </a>
              
                
                <a class="source" href="TemplateRecord.html">
                  TemplateRecord.js
                </a>
              
                
                <a class="source" href="TextAreaElement.html">
                  TextAreaElement.js
                </a>
              
                
                <a class="source" href="UserRolesElement.html">
                  UserRolesElement.js
                </a>
              
                
                <a class="source" href="_dragdrop.html">
                  _dragdrop.js
                </a>
              
                
                <a class="source" href="_module.heisenberg.html">
                  _module.heisenberg.js
                </a>
              
                
                <a class="source" href="_module.html">
                  _module.js
                </a>
              
                
                <a class="source" href="_ng_chat.html">
                  _ng_chat.js
                </a>
              
                
                <a class="source" href="_sn.dragdrop.html">
                  _sn.dragdrop.js
                </a>
              
                
                <a class="source" href="_util_includes.html">
                  _util_includes.js
                </a>
              
                
                <a class="source" href="ac.html">
                  ac.js
                </a>
              
                
                <a class="source" href="ac_derived_field_support.html">
                  ac_derived_field_support.js
                </a>
              
                
                <a class="source" href="accessibility.html">
                  accessibility.js
                </a>
              
                
                <a class="source" href="accessibility_readonly.html">
                  accessibility_readonly.js
                </a>
              
                
                <a class="source" href="accessibility_tabindex.html">
                  accessibility_tabindex.js
                </a>
              
                
                <a class="source" href="affix.html">
                  affix.js
                </a>
              
                
                <a class="source" href="alert.html">
                  alert.js
                </a>
              
                
                <a class="source" href="amb.Channel.html">
                  amb.Channel.js
                </a>
              
                
                <a class="source" href="amb.ChannelListener.html">
                  amb.ChannelListener.js
                </a>
              
                
                <a class="source" href="amb.ChannelRedirect.html">
                  amb.ChannelRedirect.js
                </a>
              
                
                <a class="source" href="amb.EventManager.html">
                  amb.EventManager.js
                </a>
              
                
                <a class="source" href="amb.Logger.html">
                  amb.Logger.js
                </a>
              
                
                <a class="source" href="amb.MessageClient.html">
                  amb.MessageClient.js
                </a>
              
                
                <a class="source" href="amb.MessageClientBuilder.html">
                  amb.MessageClientBuilder.js
                </a>
              
                
                <a class="source" href="amb.ServerConnection.html">
                  amb.ServerConnection.js
                </a>
              
                
                <a class="source" href="amb_properties.html">
                  amb_properties.js
                </a>
              
                
                <a class="source" href="angular-animate.html">
                  angular-animate.js
                </a>
              
                
                <a class="source" href="angular-animate.min.html">
                  angular-animate.min.js
                </a>
              
                
                <a class="source" href="angular-aria.html">
                  angular-aria.js
                </a>
              
                
                <a class="source" href="angular-aria.min.html">
                  angular-aria.min.js
                </a>
              
                
                <a class="source" href="angular-cookies.html">
                  angular-cookies.js
                </a>
              
                
                <a class="source" href="angular-cookies.min.html">
                  angular-cookies.min.js
                </a>
              
                
                <a class="source" href="angular-dragdrop.html">
                  angular-dragdrop.js
                </a>
              
                
                <a class="source" href="angular-file-upload-all.html">
                  angular-file-upload-all.js
                </a>
              
                
                <a class="source" href="angular-placeholder.min.html">
                  angular-placeholder.min.js
                </a>
              
                
                <a class="source" href="angular-resource.html">
                  angular-resource.js
                </a>
              
                
                <a class="source" href="angular-resource.min.html">
                  angular-resource.min.js
                </a>
              
                
                <a class="source" href="angular-route.html">
                  angular-route.js
                </a>
              
                
                <a class="source" href="angular-route.min.html">
                  angular-route.min.js
                </a>
              
                
                <a class="source" href="angular-sanitize.html">
                  angular-sanitize.js
                </a>
              
                
                <a class="source" href="angular-sanitize.min.html">
                  angular-sanitize.min.js
                </a>
              
                
                <a class="source" href="angular-tooltips.html">
                  angular-tooltips.js
                </a>
              
                
                <a class="source" href="angular-touch.html">
                  angular-touch.js
                </a>
              
                
                <a class="source" href="angular-touch.min.html">
                  angular-touch.min.js
                </a>
              
                
                <a class="source" href="angular-ui-tinymce.html">
                  angular-ui-tinymce.js
                </a>
              
                
                <a class="source" href="angular.html">
                  angular.js
                </a>
              
                
                <a class="source" href="angular.min.html">
                  angular.min.js
                </a>
              
                
                <a class="source" href="angular_includes_1.5.11.html">
                  angular_includes_1.5.11.js
                </a>
              
                
                <a class="source" href="angular_includes_no_min.1.5.11.html">
                  angular_includes_no_min.1.5.11.js
                </a>
              
                
                <a class="source" href="annotations_toggle.html">
                  annotations_toggle.js
                </a>
              
                
                <a class="source" href="app.$sp.html">
                  app.$sp.js
                </a>
              
                
                <a class="source" href="app.config.html">
                  app.config.js
                </a>
              
                
                <a class="source" href="app.form_presence.html">
                  app.form_presence.js
                </a>
              
                
                <a class="source" href="app.html">
                  app.js
                </a>
              
                
                <a class="source" href="app.ng.amb.html">
                  app.ng.amb.js
                </a>
              
                
                <a class="source" href="app.overviewhelp.html">
                  app.overviewhelp.js
                </a>
              
                
                <a class="source" href="appResourcesProvider.html">
                  appResourcesProvider.js
                </a>
              
                
                <a class="source" href="app_embedded_help.html">
                  app_embedded_help.js
                </a>
              
                
                <a class="source" href="aside.html">
                  aside.js
                </a>
              
                
                <a class="source" href="attachments.html">
                  attachments.js
                </a>
              
                
                <a class="source" href="auth.html">
                  auth.js
                </a>
              
                
                <a class="source" href="autosize-3.0.17.min.html">
                  autosize-3.0.17.min.js
                </a>
              
                
                <a class="source" href="batchedGlideAjax.html">
                  batchedGlideAjax.js
                </a>
              
                
                <a class="source" href="bootstrap-datetimepicker.html">
                  bootstrap-datetimepicker.js
                </a>
              
                
                <a class="source" href="bootstrap-iconpicker.html">
                  bootstrap-iconpicker.js
                </a>
              
                
                <a class="source" href="bootstrap_336.html">
                  bootstrap_336.js
                </a>
              
                
                <a class="source" href="button.html">
                  button.js
                </a>
              
                
                <a class="source" href="cabrillo.factory.html">
                  cabrillo.factory.js
                </a>
              
                
                <a class="source" href="calendar.html">
                  calendar.js
                </a>
              
                
                <a class="source" href="camera.html">
                  camera.js
                </a>
              
                
                <a class="source" href="carousel.html">
                  carousel.js
                </a>
              
                
                <a class="source" href="catalogDataLookup.html">
                  catalogDataLookup.js
                </a>
              
                
                <a class="source" href="catalogGlideFormFactory.html">
                  catalogGlideFormFactory.js
                </a>
              
                
                <a class="source" href="catalogItemFactory.html">
                  catalogItemFactory.js
                </a>
              
                
                <a class="source" href="clientScript_components.html">
                  clientScript_components.js
                </a>
              
                
                <a class="source" href="collapse.html">
                  collapse.js
                </a>
              
                
                <a class="source" href="cometd.html">
                  cometd.js
                </a>
              
                
                <a class="source" href="concourseNavigatorService.html">
                  concourseNavigatorService.js
                </a>
              
                
                <a class="source" href="concourse_framebuster.html">
                  concourse_framebuster.js
                </a>
              
                
                <a class="source" href="concourse_gjsv.html">
                  concourse_gjsv.js
                </a>
              
                
                <a class="source" href="condition14_new.html">
                  condition14_new.js
                </a>
              
                
                <a class="source" href="condition14_reporting.html">
                  condition14_reporting.js
                </a>
              
                
                <a class="source" href="condition14_templates.html">
                  condition14_templates.js
                </a>
              
                
                <a class="source" href="condition_global_variables14.html">
                  condition_global_variables14.js
                </a>
              
                
                <a class="source" href="config.bindWatch.html">
                  config.bindWatch.js
                </a>
              
                
                <a class="source" href="constant.spConf.html">
                  constant.spConf.js
                </a>
              
                
                <a class="source" href="constants_embedded_help.html">
                  constants_embedded_help.js
                </a>
              
                
                <a class="source" href="context_actions.html">
                  context_actions.js
                </a>
              
                
                <a class="source" href="controller.AMBRecordWatcher.html">
                  controller.AMBRecordWatcher.js
                </a>
              
                
                <a class="source" href="controller.MagellanCtrl.html">
                  controller.MagellanCtrl.js
                </a>
              
                
                <a class="source" href="controller.Stream.html">
                  controller.Stream.js
                </a>
              
                
                <a class="source" href="controller.chat.html">
                  controller.chat.js
                </a>
              
                
                <a class="source" href="controller.chatFloating.html">
                  controller.chatFloating.js
                </a>
              
                
                <a class="source" href="controller.elevateRoles.html">
                  controller.elevateRoles.js
                </a>
              
                
                <a class="source" href="controller.embeddedHelp.html">
                  controller.embeddedHelp.js
                </a>
              
                
                <a class="source" href="controller.formStream.html">
                  controller.formStream.js
                </a>
              
                
                <a class="source" href="controller.guidedTours.html">
                  controller.guidedTours.js
                </a>
              
                
                <a class="source" href="controller.impersonate.html">
                  controller.impersonate.js
                </a>
              
                
                <a class="source" href="controller.settings.html">
                  controller.settings.js
                </a>
              
                
                <a class="source" href="controller.snStream.html">
                  controller.snStream.js
                </a>
              
                
                <a class="source" href="controller.spLogin.html">
                  controller.spLogin.js
                </a>
              
                
                <a class="source" href="controller.spPage.html">
                  controller.spPage.js
                </a>
              
                
                <a class="source" href="controller.spWidgetDebug.html">
                  controller.spWidgetDebug.js
                </a>
              
                
                <a class="source" href="core.html">
                  core.js
                </a>
              
                
                <a class="source" href="dateTimeFormat.html">
                  dateTimeFormat.js
                </a>
              
                
                <a class="source" href="debug.html">
                  debug.js
                </a>
              
                
                <a class="source" href="debuggerTools.html">
                  debuggerTools.js
                </a>
              
                
                <a class="source" href="decorator.uiTinymce.html">
                  decorator.uiTinymce.js
                </a>
              
                
                <a class="source" href="deferred_related_lists.html">
                  deferred_related_lists.js
                </a>
              
                
                <a class="source" href="depends.html">
                  depends.js
                </a>
              
                
                <a class="source" href="deprecated.html">
                  deprecated.js
                </a>
              
                
                <a class="source" href="dimensions.html">
                  dimensions.js
                </a>
              
                
                <a class="source" href="directive.applicationPicker.html">
                  directive.applicationPicker.js
                </a>
              
                
                <a class="source" href="directive.concourseApplicationTree.html">
                  directive.concourseApplicationTree.js
                </a>
              
                
                <a class="source" href="directive.concourseMainPane.html">
                  directive.concourseMainPane.js
                </a>
              
                
                <a class="source" href="directive.connectConversationBarToggle.html">
                  directive.connectConversationBarToggle.js
                </a>
              
                
                <a class="source" href="directive.contenteditable.html">
                  directive.contenteditable.js
                </a>
              
                
                <a class="source" href="directive.domainPicker.html">
                  directive.domainPicker.js
                </a>
              
                
                <a class="source" href="directive.domainReferencePicker.html">
                  directive.domainReferencePicker.js
                </a>
              
                
                <a class="source" href="directive.elevateRoleIndicator.html">
                  directive.elevateRoleIndicator.js
                </a>
              
                
                <a class="source" href="directive.embeddedHelpBarToggle.html">
                  directive.embeddedHelpBarToggle.js
                </a>
              
                
                <a class="source" href="directive.enableAccessibility.html">
                  directive.enableAccessibility.js
                </a>
              
                
                <a class="source" href="directive.encryptionPicker.html">
                  directive.encryptionPicker.js
                </a>
              
                
                <a class="source" href="directive.formStreamEntry.html">
                  directive.formStreamEntry.js
                </a>
              
                
                <a class="source" href="directive.glideFormField.html">
                  directive.glideFormField.js
                </a>
              
                
                <a class="source" href="directive.glyph.html">
                  directive.glyph.js
                </a>
              
                
                <a class="source" href="directive.javascriptDebugger.html">
                  directive.javascriptDebugger.js
                </a>
              
                
                <a class="source" href="directive.liveIntroduction.html">
                  directive.liveIntroduction.js
                </a>
              
                
                <a class="source" href="directive.liveSearch.html">
                  directive.liveSearch.js
                </a>
              
                
                <a class="source" href="directive.liveSearchControl.html">
                  directive.liveSearchControl.js
                </a>
              
                
                <a class="source" href="directive.liveSearchPopover.html">
                  directive.liveSearchPopover.js
                </a>
              
                
                <a class="source" href="directive.magellanColorPicker.html">
                  directive.magellanColorPicker.js
                </a>
              
                
                <a class="source" href="directive.magellanEditFavorites.html">
                  directive.magellanEditFavorites.js
                </a>
              
                
                <a class="source" href="directive.magellanFavoritesList.html">
                  directive.magellanFavoritesList.js
                </a>
              
                
                <a class="source" href="directive.magellanHistoryCompact.html">
                  directive.magellanHistoryCompact.js
                </a>
              
                
                <a class="source" href="directive.magellanIconPicker.html">
                  directive.magellanIconPicker.js
                </a>
              
                
                <a class="source" href="directive.magellanNavigationFilter.html">
                  directive.magellanNavigationFilter.js
                </a>
              
                
                <a class="source" href="directive.mainPane.html">
                  directive.mainPane.js
                </a>
              
                
                <a class="source" href="directive.message.html">
                  directive.message.js
                </a>
              
                
                <a class="source" href="directive.navBannerLogo.html">
                  directive.navBannerLogo.js
                </a>
              
                
                <a class="source" href="directive.ngModelUpdateOnEnter.html">
                  directive.ngModelUpdateOnEnter.js
                </a>
              
                
                <a class="source" href="directive.nowAttachmentsList.html">
                  directive.nowAttachmentsList.js
                </a>
              
                
                <a class="source" href="directive.preferenceChanger.html">
                  directive.preferenceChanger.js
                </a>
              
                
                <a class="source" href="directive.preferencePicker.html">
                  directive.preferencePicker.js
                </a>
              
                
                <a class="source" href="directive.printerFriendly.html">
                  directive.printerFriendly.js
                </a>
              
                
                <a class="source" href="directive.recursiveHelper.html">
                  directive.recursiveHelper.js
                </a>
              
                
                <a class="source" href="directive.requestManager.html">
                  directive.requestManager.js
                </a>
              
                
                <a class="source" href="directive.scroll_form.html">
                  directive.scroll_form.js
                </a>
              
                
                <a class="source" href="directive.sn-draggable.html">
                  directive.sn-draggable.js
                </a>
              
                
                <a class="source" href="directive.sn-droptarget.html">
                  directive.sn-droptarget.js
                </a>
              
                
                <a class="source" href="directive.sn-sortable.html">
                  directive.sn-sortable.js
                </a>
              
                
                <a class="source" href="directive.snActions.html">
                  directive.snActions.js
                </a>
              
                
                <a class="source" href="directive.snActionsMenu.html">
                  directive.snActionsMenu.js
                </a>
              
                
                <a class="source" href="directive.snAriaChatMessage.html">
                  directive.snAriaChatMessage.js
                </a>
              
                
                <a class="source" href="directive.snAriaUnreadNotifications.html">
                  directive.snAriaUnreadNotifications.js
                </a>
              
                
                <a class="source" href="directive.snAside.html">
                  directive.snAside.js
                </a>
              
                
                <a class="source" href="directive.snAsideAttachments.html">
                  directive.snAsideAttachments.js
                </a>
              
                
                <a class="source" href="directive.snAsideContent.html">
                  directive.snAsideContent.js
                </a>
              
                
                <a class="source" href="directive.snAsideFrame.html">
                  directive.snAsideFrame.js
                </a>
              
                
                <a class="source" href="directive.snAsideInfo.html">
                  directive.snAsideInfo.js
                </a>
              
                
                <a class="source" href="directive.snAsideInfoItem.html">
                  directive.snAsideInfoItem.js
                </a>
              
                
                <a class="source" href="directive.snAsideInfoViewAllItem.html">
                  directive.snAsideInfoViewAllItem.js
                </a>
              
                
                <a class="source" href="directive.snAsideMemberList.html">
                  directive.snAsideMemberList.js
                </a>
              
                
                <a class="source" href="directive.snAsideNotificationItem.html">
                  directive.snAsideNotificationItem.js
                </a>
              
                
                <a class="source" href="directive.snAsideNotifications.html">
                  directive.snAsideNotifications.js
                </a>
              
                
                <a class="source" href="directive.snAttachmentList.html">
                  directive.snAttachmentList.js
                </a>
              
                
                <a class="source" href="directive.snAttachmentPreview.html">
                  directive.snAttachmentPreview.js
                </a>
              
                
                <a class="source" href="directive.snAutoScroll.html">
                  directive.snAutoScroll.js
                </a>
              
                
                <a class="source" href="directive.snAvatar.html">
                  directive.snAvatar.js
                </a>
              
                
                <a class="source" href="directive.snAvatarPopover.html">
                  directive.snAvatarPopover.js
                </a>
              
                
                <a class="source" href="directive.snBindI18n.html">
                  directive.snBindI18n.js
                </a>
              
                
                <a class="source" href="directive.snBindOnce.html">
                  directive.snBindOnce.js
                </a>
              
                
                <a class="source" href="directive.snBindPopoverSelection.html">
                  directive.snBindPopoverSelection.js
                </a>
              
                
                <a class="source" href="directive.snBlurOnEnter.html">
                  directive.snBlurOnEnter.js
                </a>
              
                
                <a class="source" href="directive.snBootstrapPopover.html">
                  directive.snBootstrapPopover.js
                </a>
              
                
                <a class="source" href="directive.snChatActionOptionsPopup.html">
                  directive.snChatActionOptionsPopup.js
                </a>
              
                
                <a class="source" href="directive.snChatTab.html">
                  directive.snChatTab.js
                </a>
              
                
                <a class="source" href="directive.snChoiceList.html">
                  directive.snChoiceList.js
                </a>
              
                
                <a class="source" href="directive.snClickToEdit.html">
                  directive.snClickToEdit.js
                </a>
              
                
                <a class="source" href="directive.snCloak.html">
                  directive.snCloak.js
                </a>
              
                
                <a class="source" href="directive.snComplexPopover.html">
                  directive.snComplexPopover.js
                </a>
              
                
                <a class="source" href="directive.snComposing.html">
                  directive.snComposing.js
                </a>
              
                
                <a class="source" href="directive.snConfirmModal.html">
                  directive.snConfirmModal.js
                </a>
              
                
                <a class="source" href="directive.snConnectContent.html">
                  directive.snConnectContent.js
                </a>
              
                
                <a class="source" href="directive.snConnectDuration.html">
                  directive.snConnectDuration.js
                </a>
              
                
                <a class="source" href="directive.snConnectHeader.html">
                  directive.snConnectHeader.js
                </a>
              
                
                <a class="source" href="directive.snContextMenu.html">
                  directive.snContextMenu.js
                </a>
              
                
                <a class="source" href="directive.snConversation.html">
                  directive.snConversation.js
                </a>
              
                
                <a class="source" href="directive.snConversationAddUserButton.html">
                  directive.snConversationAddUserButton.js
                </a>
              
                
                <a class="source" href="directive.snConversationContainer.html">
                  directive.snConversationContainer.js
                </a>
              
                
                <a class="source" href="directive.snConversationFooter.html">
                  directive.snConversationFooter.js
                </a>
              
                
                <a class="source" href="directive.snConversationHeader.html">
                  directive.snConversationHeader.js
                </a>
              
                
                <a class="source" href="directive.snConversationHeaderControls.html">
                  directive.snConversationHeaderControls.js
                </a>
              
                
                <a class="source" href="directive.snConversationItem.html">
                  directive.snConversationItem.js
                </a>
              
                
                <a class="source" href="directive.snConversationList.html">
                  directive.snConversationList.js
                </a>
              
                
                <a class="source" href="directive.snConversationListContainer.html">
                  directive.snConversationListContainer.js
                </a>
              
                
                <a class="source" href="directive.snConversationSearch.html">
                  directive.snConversationSearch.js
                </a>
              
                
                <a class="source" href="directive.snCreateMessage.html">
                  directive.snCreateMessage.js
                </a>
              
                
                <a class="source" href="directive.snCreateNewConversationHeader.html">
                  directive.snCreateNewConversationHeader.js
                </a>
              
                
                <a class="source" href="directive.snDayAgo.html">
                  directive.snDayAgo.js
                </a>
              
                
                <a class="source" href="directive.snDialog.html">
                  directive.snDialog.js
                </a>
              
                
                <a class="source" href="directive.snDragEventBlocker.html">
                  directive.snDragEventBlocker.js
                </a>
              
                
                <a class="source" href="directive.snDropTargetPopup.html">
                  directive.snDropTargetPopup.js
                </a>
              
                
                <a class="source" href="directive.snEmbeddedHelpActionList.html">
                  directive.snEmbeddedHelpActionList.js
                </a>
              
                
                <a class="source" href="directive.snEmbeddedHelpContent.html">
                  directive.snEmbeddedHelpContent.js
                </a>
              
                
                <a class="source" href="directive.snEmbeddedHelpMenu.html">
                  directive.snEmbeddedHelpMenu.js
                </a>
              
                
                <a class="source" href="directive.snEmbeddedHelpPane.html">
                  directive.snEmbeddedHelpPane.js
                </a>
              
                
                <a class="source" href="directive.snEscape.html">
                  directive.snEscape.js
                </a>
              
                
                <a class="source" href="directive.snExpandedEmail.html">
                  directive.snExpandedEmail.js
                </a>
              
                
                <a class="source" href="directive.snFieldReference.html">
                  directive.snFieldReference.js
                </a>
              
                
                <a class="source" href="directive.snFileUploadInput.html">
                  directive.snFileUploadInput.js
                </a>
              
                
                <a class="source" href="directive.snFloatingConversation.html">
                  directive.snFloatingConversation.js
                </a>
              
                
                <a class="source" href="directive.snFloatingConversationCompressed.html">
                  directive.snFloatingConversationCompressed.js
                </a>
              
                
                <a class="source" href="directive.snFloatingConversationContainer.html">
                  directive.snFloatingConversationContainer.js
                </a>
              
                
                <a class="source" href="directive.snFlyout.html">
                  directive.snFlyout.js
                </a>
              
                
                <a class="source" href="directive.snFocus.html">
                  directive.snFocus.js
                </a>
              
                
                <a class="source" href="directive.snFocusEsc.html">
                  directive.snFocusEsc.js
                </a>
              
                
                <a class="source" href="directive.snFocusOnConversation.html">
                  directive.snFocusOnConversation.js
                </a>
              
                
                <a class="source" href="directive.snGlyph.html">
                  directive.snGlyph.js
                </a>
              
                
                <a class="source" href="directive.snGroupAvatar.html">
                  directive.snGroupAvatar.js
                </a>
              
                
                <a class="source" href="directive.snImageUploader.html">
                  directive.snImageUploader.js
                </a>
              
                
                <a class="source" href="directive.snLinkCardList.html">
                  directive.snLinkCardList.js
                </a>
              
                
                <a class="source" href="directive.snLinkContent.html">
                  directive.snLinkContent.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentArticle.html">
                  directive.snLinkContentArticle.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentAttachment.html">
                  directive.snLinkContentAttachment.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentError.html">
                  directive.snLinkContentError.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentImage.html">
                  directive.snLinkContentImage.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentRecord.html">
                  directive.snLinkContentRecord.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentSoundcloud.html">
                  directive.snLinkContentSoundcloud.js
                </a>
              
                
                <a class="source" href="directive.snLinkContentYoutube.html">
                  directive.snLinkContentYoutube.js
                </a>
              
                
                <a class="source" href="directive.snLoadingBar.html">
                  directive.snLoadingBar.js
                </a>
              
                
                <a class="source" href="directive.snLoadingIndicator.html">
                  directive.snLoadingIndicator.js
                </a>
              
                
                <a class="source" href="directive.snMentionPopover.html">
                  directive.snMentionPopover.js
                </a>
              
                
                <a class="source" href="directive.snMessageBatch.html">
                  directive.snMessageBatch.js
                </a>
              
                
                <a class="source" href="directive.snModal.html">
                  directive.snModal.js
                </a>
              
                
                <a class="source" href="directive.snModalShow.html">
                  directive.snModalShow.js
                </a>
              
                
                <a class="source" href="directive.snNonAgentClose.html">
                  directive.snNonAgentClose.js
                </a>
              
                
                <a class="source" href="directive.snNotification.html">
                  directive.snNotification.js
                </a>
              
                
                <a class="source" href="directive.snOnload.html">
                  directive.snOnload.js
                </a>
              
                
                <a class="source" href="directive.snOptions.html">
                  directive.snOptions.js
                </a>
              
                
                <a class="source" href="directive.snPane.html">
                  directive.snPane.js
                </a>
              
                
                <a class="source" href="directive.snPaneManager.html">
                  directive.snPaneManager.js
                </a>
              
                
                <a class="source" href="directive.snPasteFileHandler.html">
                  directive.snPasteFileHandler.js
                </a>
              
                
                <a class="source" href="directive.snPod.html">
                  directive.snPod.js
                </a>
              
                
                <a class="source" href="directive.snPopOver.html">
                  directive.snPopOver.js
                </a>
              
                
                <a class="source" href="directive.snPopoverBasic.html">
                  directive.snPopoverBasic.js
                </a>
              
                
                <a class="source" href="directive.snPresence.html">
                  directive.snPresence.js
                </a>
              
                
                <a class="source" href="directive.snPulse.html">
                  directive.snPulse.js
                </a>
              
                
                <a class="source" href="directive.snQueueEntryClose.html">
                  directive.snQueueEntryClose.js
                </a>
              
                
                <a class="source" href="directive.snQueueEntryTransfer.html">
                  directive.snQueueEntryTransfer.js
                </a>
              
                
                <a class="source" href="directive.snQueueEntryTransferAccepted.html">
                  directive.snQueueEntryTransferAccepted.js
                </a>
              
                
                <a class="source" href="directive.snQueueItem.html">
                  directive.snQueueItem.js
                </a>
              
                
                <a class="source" href="directive.snQueueList.html">
                  directive.snQueueList.js
                </a>
              
                
                <a class="source" href="directive.snRecordPicker.html">
                  directive.snRecordPicker.js
                </a>
              
                
                <a class="source" href="directive.snReferencePicker.html">
                  directive.snReferencePicker.js
                </a>
              
                
                <a class="source" href="directive.snRepeatEventEmitter.html">
                  directive.snRepeatEventEmitter.js
                </a>
              
                
                <a class="source" href="directive.snResizeHeight.html">
                  directive.snResizeHeight.js
                </a>
              
                
                <a class="source" href="directive.snSearchButton.html">
                  directive.snSearchButton.js
                </a>
              
                
                <a class="source" href="directive.snSelectBasic.html">
                  directive.snSelectBasic.js
                </a>
              
                
                <a class="source" href="directive.snStickyHeaders.html">
                  directive.snStickyHeaders.js
                </a>
              
                
                <a class="source" href="directive.snStream.html">
                  directive.snStream.js
                </a>
              
                
                <a class="source" href="directive.snSupportConversationItem.html">
                  directive.snSupportConversationItem.js
                </a>
              
                
                <a class="source" href="directive.snSupportTab.html">
                  directive.snSupportTab.js
                </a>
              
                
                <a class="source" href="directive.snSyncWith.html">
                  directive.snSyncWith.js
                </a>
              
                
                <a class="source" href="directive.snTableReference.html">
                  directive.snTableReference.js
                </a>
              
                
                <a class="source" href="directive.snTabs.html">
                  directive.snTabs.js
                </a>
              
                
                <a class="source" href="directive.snTabsBasic.html">
                  directive.snTabsBasic.js
                </a>
              
                
                <a class="source" href="directive.snTextExpander.html">
                  directive.snTextExpander.js
                </a>
              
                
                <a class="source" href="directive.snTimeAgo.html">
                  directive.snTimeAgo.js
                </a>
              
                
                <a class="source" href="directive.snTooltipBasic.html">
                  directive.snTooltipBasic.js
                </a>
              
                
                <a class="source" href="directive.snTriggerOverviewHelp.html">
                  directive.snTriggerOverviewHelp.js
                </a>
              
                
                <a class="source" href="directive.snUploadAttachmentList.html">
                  directive.snUploadAttachmentList.js
                </a>
              
                
                <a class="source" href="directive.snUserAvatar.html">
                  directive.snUserAvatar.js
                </a>
              
                
                <a class="source" href="directive.snUserProfile.html">
                  directive.snUserProfile.js
                </a>
              
                
                <a class="source" href="directive.snVideoPlayer.html">
                  directive.snVideoPlayer.js
                </a>
              
                
                <a class="source" href="directive.spAriaPageTitle.html">
                  directive.spAriaPageTitle.js
                </a>
              
                
                <a class="source" href="directive.spAttachmentButton.html">
                  directive.spAttachmentButton.js
                </a>
              
                
                <a class="source" href="directive.spCLink.html">
                  directive.spCLink.js
                </a>
              
                
                <a class="source" href="directive.spCatItem.html">
                  directive.spCatItem.js
                </a>
              
                
                <a class="source" href="directive.spChoiceList.html">
                  directive.spChoiceList.js
                </a>
              
                
                <a class="source" href="directive.spCodeMirror.html">
                  directive.spCodeMirror.js
                </a>
              
                
                <a class="source" href="directive.spColorPicker.html">
                  directive.spColorPicker.js
                </a>
              
                
                <a class="source" href="directive.spContextMenu.html">
                  directive.spContextMenu.js
                </a>
              
                
                <a class="source" href="directive.spCssEditor.html">
                  directive.spCssEditor.js
                </a>
              
                
                <a class="source" href="directive.spCurrencyElement.html">
                  directive.spCurrencyElement.js
                </a>
              
                
                <a class="source" href="directive.spDatePicker.html">
                  directive.spDatePicker.js
                </a>
              
                
                <a class="source" href="directive.spDropdownTree.html">
                  directive.spDropdownTree.js
                </a>
              
                
                <a class="source" href="directive.spDurationElement.html">
                  directive.spDurationElement.js
                </a>
              
                
                <a class="source" href="directive.spEditableField.html">
                  directive.spEditableField.js
                </a>
              
                
                <a class="source" href="directive.spEmailElement.html">
                  directive.spEmailElement.js
                </a>
              
                
                <a class="source" href="directive.spFieldListElement.html">
                  directive.spFieldListElement.js
                </a>
              
                
                <a class="source" href="directive.spFormField.html">
                  directive.spFormField.js
                </a>
              
                
                <a class="source" href="directive.spGlyphPicker.html">
                  directive.spGlyphPicker.js
                </a>
              
                
                <a class="source" href="directive.spHTMLEditor.html">
                  directive.spHTMLEditor.js
                </a>
              
                
                <a class="source" href="directive.spHtmlContent.html">
                  directive.spHtmlContent.js
                </a>
              
                
                <a class="source" href="directive.spMessageDialog.html">
                  directive.spMessageDialog.js
                </a>
              
                
                <a class="source" href="directive.spModel.html">
                  directive.spModel.js
                </a>
              
                
                <a class="source" href="directive.spNavbarToggle.html">
                  directive.spNavbarToggle.js
                </a>
              
                
                <a class="source" href="directive.spNotifications.html">
                  directive.spNotifications.js
                </a>
              
                
                <a class="source" href="directive.spOnTransition.html">
                  directive.spOnTransition.js
                </a>
              
                
                <a class="source" href="directive.spPageRow.html">
                  directive.spPageRow.js
                </a>
              
                
                <a class="source" href="directive.spPanel.html">
                  directive.spPanel.js
                </a>
              
                
                <a class="source" href="directive.spReferenceElement.html">
                  directive.spReferenceElement.js
                </a>
              
                
                <a class="source" href="directive.spReferenceField.html">
                  directive.spReferenceField.js
                </a>
              
                
                <a class="source" href="directive.spScriptEditor.html">
                  directive.spScriptEditor.js
                </a>
              
                
                <a class="source" href="directive.spScroll.html">
                  directive.spScroll.js
                </a>
              
                
                <a class="source" href="directive.spTextarea.html">
                  directive.spTextarea.js
                </a>
              
                
                <a class="source" href="directive.spTinymceEditor.html">
                  directive.spTinymceEditor.js
                </a>
              
                
                <a class="source" href="directive.spWidget.html">
                  directive.spWidget.js
                </a>
              
                
                <a class="source" href="directive.themePicker.html">
                  directive.themePicker.js
                </a>
              
                
                <a class="source" href="directive.updateSetPicker.html">
                  directive.updateSetPicker.js
                </a>
              
                
                <a class="source" href="dropdown.html">
                  dropdown.js
                </a>
              
                
                <a class="source" href="dropdowns.html">
                  dropdowns.js
                </a>
              
                
                <a class="source" href="email_activity.html">
                  email_activity.js
                </a>
              
                
                <a class="source" href="event_initialize.html">
                  event_initialize.js
                </a>
              
                
                <a class="source" href="export-csv.html">
                  export-csv.js
                </a>
              
                
                <a class="source" href="exporting.html">
                  exporting.js
                </a>
              
                
                <a class="source" href="factory.AMBOverlay.html">
                  factory.AMBOverlay.js
                </a>
              
                
                <a class="source" href="factory.ArraySynchronizer.html">
                  factory.ArraySynchronizer.js
                </a>
              
                
                <a class="source" href="factory.Conversation.html">
                  factory.Conversation.js
                </a>
              
                
                <a class="source" href="factory.Document.html">
                  factory.Document.js
                </a>
              
                
                <a class="source" href="factory.LiveLink.html">
                  factory.LiveLink.js
                </a>
              
                
                <a class="source" href="factory.Message.html">
                  factory.Message.js
                </a>
              
                
                <a class="source" href="factory.attachment.html">
                  factory.attachment.js
                </a>
              
                
                <a class="source" href="factory.commandFactory.html">
                  factory.commandFactory.js
                </a>
              
                
                <a class="source" href="factory.glideUrlBuilder.html">
                  factory.glideUrlBuilder.js
                </a>
              
                
                <a class="source" href="factory.keyboardRegistry.html">
                  factory.keyboardRegistry.js
                </a>
              
                
                <a class="source" href="factory.magellan_Endpoint.html">
                  factory.magellan_Endpoint.js
                </a>
              
                
                <a class="source" href="factory.magellan_FavoritesList.html">
                  factory.magellan_FavoritesList.js
                </a>
              
                
                <a class="source" href="factory.magellan_HistoryList.html">
                  factory.magellan_HistoryList.js
                </a>
              
                
                <a class="source" href="factory.magellan_Permalink.html">
                  factory.magellan_Permalink.js
                </a>
              
                
                <a class="source" href="factory.notificationWrapper.html">
                  factory.notificationWrapper.js
                </a>
              
                
                <a class="source" href="factory.nowAttachmentHandler.html">
                  factory.nowAttachmentHandler.js
                </a>
              
                
                <a class="source" href="factory.paneManager.html">
                  factory.paneManager.js
                </a>
              
                
                <a class="source" href="factory.queue.html">
                  factory.queue.js
                </a>
              
                
                <a class="source" href="factory.queueEntry.html">
                  factory.queueEntry.js
                </a>
              
                
                <a class="source" href="factory.snAttachmentHandler.html">
                  factory.snAttachmentHandler.js
                </a>
              
                
                <a class="source" href="factory.snChatAction.html">
                  factory.snChatAction.js
                </a>
              
                
                <a class="source" href="factory.snHotKey.html">
                  factory.snHotKey.js
                </a>
              
                
                <a class="source" href="factory.snPresence.html">
                  factory.snPresence.js
                </a>
              
                
                <a class="source" href="factory.snRecordPresence.html">
                  factory.snRecordPresence.js
                </a>
              
                
                <a class="source" href="factory.snRecordWatcher.html">
                  factory.snRecordWatcher.js
                </a>
              
                
                <a class="source" href="factory.spInterceptor.html">
                  factory.spInterceptor.js
                </a>
              
                
                <a class="source" href="factory.spMacro.html">
                  factory.spMacro.js
                </a>
              
                
                <a class="source" href="factory.spPage.html">
                  factory.spPage.js
                </a>
              
                
                <a class="source" href="factory.spServer.html">
                  factory.spServer.js
                </a>
              
                
                <a class="source" href="factory.spUIActionFactory.html">
                  factory.spUIActionFactory.js
                </a>
              
                
                <a class="source" href="factory.spWidget.html">
                  factory.spWidget.js
                </a>
              
                
                <a class="source" href="factory.unwrappedHTTPPromise.html">
                  factory.unwrappedHTTPPromise.js
                </a>
              
                
                <a class="source" href="filter.conversation.html">
                  filter.conversation.js
                </a>
              
                
                <a class="source" href="filter.frameSet.html">
                  filter.frameSet.js
                </a>
              
                
                <a class="source" href="filter.searchTerm.html">
                  filter.searchTerm.js
                </a>
              
                
                <a class="source" href="filter.transferAccepted.html">
                  filter.transferAccepted.js
                </a>
              
                
                <a class="source" href="filter.truncate.html">
                  filter.truncate.js
                </a>
              
                
                <a class="source" href="fixedHeaders.html">
                  fixedHeaders.js
                </a>
              
                
                <a class="source" href="floating_scrollbar.min.html">
                  floating_scrollbar.min.js
                </a>
              
                
                <a class="source" href="focus-trap.html">
                  focus-trap.js
                </a>
              
                
                <a class="source" href="form.html">
                  form.js
                </a>
              
                
                <a class="source" href="form_submitted_mask.html">
                  form_submitted_mask.js
                </a>
              
                
                <a class="source" href="form_tags.html">
                  form_tags.js
                </a>
              
                
                <a class="source" href="formatting.html">
                  formatting.js
                </a>
              
                
                <a class="source" href="functions.html">
                  functions.js
                </a>
              
                
                <a class="source" href="functions_attachments.html">
                  functions_attachments.js
                </a>
              
                
                <a class="source" href="functions_bootstrap14.html">
                  functions_bootstrap14.js
                </a>
              
                
                <a class="source" href="functions_calendar.html">
                  functions_calendar.js
                </a>
              
                
                <a class="source" href="functions_clipboard.html">
                  functions_clipboard.js
                </a>
              
                
                <a class="source" href="functions_email.html">
                  functions_email.js
                </a>
              
                
                <a class="source" href="functions_fontsizer.html">
                  functions_fontsizer.js
                </a>
              
                
                <a class="source" href="functions_onchange.html">
                  functions_onchange.js
                </a>
              
                
                <a class="source" href="functions_reference.html">
                  functions_reference.js
                </a>
              
                
                <a class="source" href="functions_showloading.html">
                  functions_showloading.js
                </a>
              
                
                <a class="source" href="functions_user_image.html">
                  functions_user_image.js
                </a>
              
                
                <a class="source" href="funnel.html">
                  funnel.js
                </a>
              
                
                <a class="source" href="geolocation.html">
                  geolocation.js
                </a>
              
                
                <a class="source" href="glide-highcharts-v5.html">
                  glide-highcharts-v5.js
                </a>
              
                
                <a class="source" href="glideAjaxBatchQueue.html">
                  glideAjaxBatchQueue.js
                </a>
              
                
                <a class="source" href="glideAjaxFactory.html">
                  glideAjaxFactory.js
                </a>
              
                
                <a class="source" href="glideFormEnvironmentFactory.html">
                  glideFormEnvironmentFactory.js
                </a>
              
                
                <a class="source" href="glideFormFactory.html">
                  glideFormFactory.js
                </a>
              
                
                <a class="source" href="glideFormFieldFactory.html">
                  glideFormFieldFactory.js
                </a>
              
                
                <a class="source" href="glideFormMessageHandler.html">
                  glideFormMessageHandler.js
                </a>
              
                
                <a class="source" href="glideListFactory.html">
                  glideListFactory.js
                </a>
              
                
                <a class="source" href="glideModalFactory.html">
                  glideModalFactory.js
                </a>
              
                
                <a class="source" href="glideRecordData.html">
                  glideRecordData.js
                </a>
              
                
                <a class="source" href="glideRecordFactory.html">
                  glideRecordFactory.js
                </a>
              
                
                <a class="source" href="glideRequest.html">
                  glideRequest.js
                </a>
              
                
                <a class="source" href="glideUIActionsApi.html">
                  glideUIActionsApi.js
                </a>
              
                
                <a class="source" href="glideUIActionsFactory.html">
                  glideUIActionsFactory.js
                </a>
              
                
                <a class="source" href="glideUserFactory.html">
                  glideUserFactory.js
                </a>
              
                
                <a class="source" href="glideUserSession.html">
                  glideUserSession.js
                </a>
              
                
                <a class="source" href="guided_tours_template.html">
                  guided_tours_template.js
                </a>
              
                
                <a class="source" href="heatmap.html">
                  heatmap.js
                </a>
              
                
                <a class="source" href="heisenberg_all.html">
                  heisenberg_all.js
                </a>
              
                
                <a class="source" href="highcharts-more.src.html">
                  highcharts-more.src.js
                </a>
              
                
                <a class="source" href="highstock.src.html">
                  highstock.src.js
                </a>
              
                
                <a class="source" href="hopscotch.min.html">
                  hopscotch.min.js
                </a>
              
                
                <a class="source" href="html_class_setter.html">
                  html_class_setter.js
                </a>
              
                
                <a class="source" href="i18n.html">
                  i18n.js
                </a>
              
                
                <a class="source" href="iconset-fontawesome-4.2.0.html">
                  iconset-fontawesome-4.2.0.js
                </a>
              
                
                <a class="source" href="jQueryRequestShim.html">
                  jQueryRequestShim.js
                </a>
              
                
                <a class="source" href="jquery-2.1.html">
                  jquery-2.1.js
                </a>
              
                
                <a class="source" href="jquery-2.2.3.min.html">
                  jquery-2.2.3.min.js
                </a>
              
                
                <a class="source" href="jquery-ui-1.9.2.custom.html">
                  jquery-ui-1.9.2.custom.js
                </a>
              
                
                <a class="source" href="jquery-ui-dragdrop.min.html">
                  jquery-ui-dragdrop.min.js
                </a>
              
                
                <a class="source" href="jquery.ui.touch-punch.min.html">
                  jquery.ui.touch-punch.min.js
                </a>
              
                
                <a class="source" href="jquery2_includes.html">
                  jquery2_includes.js
                </a>
              
                
                <a class="source" href="jquery_clean.html">
                  jquery_clean.js
                </a>
              
                
                <a class="source" href="jquery_csrf.html">
                  jquery_csrf.js
                </a>
              
                
                <a class="source" href="jquery_no_conflict.html">
                  jquery_no_conflict.js
                </a>
              
                
                <a class="source" href="js_embedded_help_includes.html">
                  js_embedded_help_includes.js
                </a>
              
                
                <a class="source" href="js_guided_tours_includes.html">
                  js_guided_tours_includes.js
                </a>
              
                
                <a class="source" href="js_hopscotch_includes.html">
                  js_hopscotch_includes.js
                </a>
              
                
                <a class="source" href="js_includes_amb.html">
                  js_includes_amb.js
                </a>
              
                
                <a class="source" href="js_includes_angular.html">
                  js_includes_angular.js
                </a>
              
                
                <a class="source" href="js_includes_angular_strap_aside.html">
                  js_includes_angular_strap_aside.js
                </a>
              
                
                <a class="source" href="js_includes_angular_strap_components.html">
                  js_includes_angular_strap_components.js
                </a>
              
                
                <a class="source" href="js_includes_attachments.html">
                  js_includes_attachments.js
                </a>
              
                
                <a class="source" href="js_includes_avatar.html">
                  js_includes_avatar.js
                </a>
              
                
                <a class="source" href="js_includes_batchedga.html">
                  js_includes_batchedga.js
                </a>
              
                
                <a class="source" href="js_includes_bind_watch.html">
                  js_includes_bind_watch.js
                </a>
              
                
                <a class="source" href="js_includes_cabrillo.html">
                  js_includes_cabrillo.js
                </a>
              
                
                <a class="source" href="js_includes_clientScript.html">
                  js_includes_clientScript.js
                </a>
              
                
                <a class="source" href="js_includes_common.html">
                  js_includes_common.js
                </a>
              
                
                <a class="source" href="js_includes_common_accessibility.html">
                  js_includes_common_accessibility.js
                </a>
              
                
                <a class="source" href="js_includes_concourse.html">
                  js_includes_concourse.js
                </a>
              
                
                <a class="source" href="js_includes_concourse_pane_extension.html">
                  js_includes_concourse_pane_extension.js
                </a>
              
                
                <a class="source" href="js_includes_concourse_view_stack.html">
                  js_includes_concourse_view_stack.js
                </a>
              
                
                <a class="source" href="js_includes_connect_conversation.html">
                  js_includes_connect_conversation.js
                </a>
              
                
                <a class="source" href="js_includes_connect_document.html">
                  js_includes_connect_document.js
                </a>
              
                
                <a class="source" href="js_includes_connect_message.html">
                  js_includes_connect_message.js
                </a>
              
                
                <a class="source" href="js_includes_connect_presence.html">
                  js_includes_connect_presence.js
                </a>
              
                
                <a class="source" href="js_includes_connect_profile.html">
                  js_includes_connect_profile.js
                </a>
              
                
                <a class="source" href="js_includes_connect_queue.html">
                  js_includes_connect_queue.js
                </a>
              
                
                <a class="source" href="js_includes_connect_resource.html">
                  js_includes_connect_resource.js
                </a>
              
                
                <a class="source" href="js_includes_connect_util.html">
                  js_includes_connect_util.js
                </a>
              
                
                <a class="source" href="js_includes_controls.html">
                  js_includes_controls.js
                </a>
              
                
                <a class="source" href="js_includes_customer.html">
                  js_includes_customer.js
                </a>
              
                
                <a class="source" href="js_includes_data.html">
                  js_includes_data.js
                </a>
              
                
                <a class="source" href="js_includes_datetime.html">
                  js_includes_datetime.js
                </a>
              
                
                <a class="source" href="js_includes_doctype.html">
                  js_includes_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_fast.html">
                  js_includes_fast.js
                </a>
              
                
                <a class="source" href="js_includes_form.html">
                  js_includes_form.js
                </a>
              
                
                <a class="source" href="js_includes_form_presence.html">
                  js_includes_form_presence.js
                </a>
              
                
                <a class="source" href="js_includes_glide.html">
                  js_includes_glide.js
                </a>
              
                
                <a class="source" href="js_includes_i18n.html">
                  js_includes_i18n.js
                </a>
              
                
                <a class="source" href="js_includes_last_doctype.html">
                  js_includes_last_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_link.html">
                  js_includes_link.js
                </a>
              
                
                <a class="source" href="js_includes_list_edit_doctype.html">
                  js_includes_list_edit_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_listv2_doctype.html">
                  js_includes_listv2_doctype.js
                </a>
              
                
                <a class="source" href="js_includes_magellan.html">
                  js_includes_magellan.js
                </a>
              
                
                <a class="source" href="js_includes_mention.html">
                  js_includes_mention.js
                </a>
              
                
                <a class="source" href="js_includes_messaging.html">
                  js_includes_messaging.js
                </a>
              
                
                <a class="source" href="js_includes_navpage15.html">
                  js_includes_navpage15.js
                </a>
              
                
                <a class="source" href="js_includes_ngCommon.html">
                  js_includes_ngCommon.js
                </a>
              
                
                <a class="source" href="js_includes_ng_amb.html">
                  js_includes_ng_amb.js
                </a>
              
                
                <a class="source" href="js_includes_ng_chat.html">
                  js_includes_ng_chat.js
                </a>
              
                
                <a class="source" href="js_includes_notification.html">
                  js_includes_notification.js
                </a>
              
                
                <a class="source" href="js_includes_overviewhelp.html">
                  js_includes_overviewhelp.js
                </a>
              
                
                <a class="source" href="js_includes_presence.html">
                  js_includes_presence.js
                </a>
              
                
                <a class="source" href="js_includes_resources.html">
                  js_includes_resources.js
                </a>
              
                
                <a class="source" href="js_includes_session_notification.html">
                  js_includes_session_notification.js
                </a>
              
                
                <a class="source" href="js_includes_sp.html">
                  js_includes_sp.js
                </a>
              
                
                <a class="source" href="js_includes_sp_core.html">
                  js_includes_sp_core.js
                </a>
              
                
                <a class="source" href="js_includes_sp_deps.html">
                  js_includes_sp_deps.js
                </a>
              
                
                <a class="source" href="js_includes_sp_tinymce.html">
                  js_includes_sp_tinymce.js
                </a>
              
                
                <a class="source" href="js_includes_stream.html">
                  js_includes_stream.js
                </a>
              
                
                <a class="source" href="js_includes_ui.html">
                  js_includes_ui.js
                </a>
              
                
                <a class="source" href="js_includes_ui16_form.html">
                  js_includes_ui16_form.js
                </a>
              
                
                <a class="source" href="js_includes_ui_popover.html">
                  js_includes_ui_popover.js
                </a>
              
                
                <a class="source" href="js_includes_user_profile.html">
                  js_includes_user_profile.js
                </a>
              
                
                <a class="source" href="js_includes_util.html">
                  js_includes_util.js
                </a>
              
                
                <a class="source" href="js_includes_video.html">
                  js_includes_video.js
                </a>
              
                
                <a class="source" href="js_includes_weba.html">
                  js_includes_weba.js
                </a>
              
                
                <a class="source" href="keyboard.0.2.2.min.html">
                  keyboard.0.2.2.min.js
                </a>
              
                
                <a class="source" href="keyboardShortcuts.html">
                  keyboardShortcuts.js
                </a>
              
                
                <a class="source" href="list.html">
                  list.js
                </a>
              
                
                <a class="source" href="list_filter.html">
                  list_filter.js
                </a>
              
                
                <a class="source" href="lodash.min.html">
                  lodash.min.js
                </a>
              
                
                <a class="source" href="magellan.CreateFavoriteModal.html">
                  magellan.CreateFavoriteModal.js
                </a>
              
                
                <a class="source" href="magellan.html">
                  magellan.js
                </a>
              
                
                <a class="source" href="map.html">
                  map.js
                </a>
              
                
                <a class="source" href="mentio.html">
                  mentio.js
                </a>
              
                
                <a class="source" href="modal.html">
                  modal.js
                </a>
              
                
                <a class="source" href="modals.html">
                  modals.js
                </a>
              
                
                <a class="source" href="modernizr.custom.min.html">
                  modernizr.custom.min.js
                </a>
              
                
                <a class="source" href="moment-2.14.1.min.html">
                  moment-2.14.1.min.js
                </a>
              
                
                <a class="source" href="moment-timezone-with-data-0.5.13.html">
                  moment-timezone-with-data-0.5.13.js
                </a>
              
                
                <a class="source" href="navigation.html">
                  navigation.js
                </a>
              
                
                <a class="source" href="newtag-it.html">
                  newtag-it.js
                </a>
              
                
                <a class="source" href="ng-sortable.html">
                  ng-sortable.js
                </a>
              
                
                <a class="source" href="ng_jqdnd_includes.html">
                  ng_jqdnd_includes.js
                </a>
              
                
                <a class="source" href="no-data-to-display.html">
                  no-data-to-display.js
                </a>
              
                
                <a class="source" href="nowapi.html">
                  nowapi.js
                </a>
              
                
                <a class="source" href="ocLazyLoad.html">
                  ocLazyLoad.js
                </a>
              
                
                <a class="source" href="ocLazyLoad.min.html">
                  ocLazyLoad.min.js
                </a>
              
                
                <a class="source" href="offline-exporting.html">
                  offline-exporting.js
                </a>
              
                
                <a class="source" href="page_title.html">
                  page_title.js
                </a>
              
                
                <a class="source" href="pattern-fill-v2.html">
                  pattern-fill-v2.js
                </a>
              
                
                <a class="source" href="popover.html">
                  popover.js
                </a>
              
                
                <a class="source" href="popovers.html">
                  popovers.js
                </a>
              
                
                <a class="source" href="popupdivs14.html">
                  popupdivs14.js
                </a>
              
                
                <a class="source" href="popups.html">
                  popups.js
                </a>
              
                
                <a class="source" href="prism.html">
                  prism.js
                </a>
              
                
                <a class="source" href="proj4.html">
                  proj4.js
                </a>
              
                
                <a class="source" href="prototype.effects.html">
                  prototype.effects.js
                </a>
              
                
                <a class="source" href="prototype.hidefix.html">
                  prototype.hidefix.js
                </a>
              
                
                <a class="source" href="prototype.html">
                  prototype.js
                </a>
              
                
                <a class="source" href="prototype.min.html">
                  prototype.min.js
                </a>
              
                
                <a class="source" href="prototype.plugin.html">
                  prototype.plugin.js
                </a>
              
                
                <a class="source" href="prototype.template.html">
                  prototype.template.js
                </a>
              
                
                <a class="source" href="provider.defaultJSAutocomplete.html">
                  provider.defaultJSAutocomplete.js
                </a>
              
                
                <a class="source" href="provider.lazyloader.html">
                  provider.lazyloader.js
                </a>
              
                
                <a class="source" href="provider.linkContentTypes.html">
                  provider.linkContentTypes.js
                </a>
              
                
                <a class="source" href="responsive_form_header.html">
                  responsive_form_header.js
                </a>
              
                
                <a class="source" href="scoped_object_bridge.html">
                  scoped_object_bridge.js
                </a>
              
                
                <a class="source" href="scoped_object_generators.html">
                  scoped_object_generators.js
                </a>
              
                
                <a class="source" href="scrollable.html">
                  scrollable.js
                </a>
              
                
                <a class="source" href="scrollspy.html">
                  scrollspy.js
                </a>
              
                
                <a class="source" href="searchFocus.html">
                  searchFocus.js
                </a>
              
                
                <a class="source" href="section.html">
                  section.js
                </a>
              
                
                <a class="source" href="select2.html">
                  select2.js
                </a>
              
                
                <a class="source" href="select2.min.html">
                  select2.min.js
                </a>
              
                
                <a class="source" href="selects.html">
                  selects.js
                </a>
              
                
                <a class="source" href="service.AMB.html">
                  service.AMB.js
                </a>
              
                
                <a class="source" href="service.ChatActionHandler.html">
                  service.ChatActionHandler.js
                </a>
              
                
                <a class="source" href="service.activeConversation.html">
                  service.activeConversation.js
                </a>
              
                
                <a class="source" href="service.audioNotifier.html">
                  service.audioNotifier.js
                </a>
              
                
                <a class="source" href="service.authInterceptor.html">
                  service.authInterceptor.js
                </a>
              
                
                <a class="source" href="service.avatarProfilePersister.html">
                  service.avatarProfilePersister.js
                </a>
              
                
                <a class="source" href="service.concoursePaneExtensionRegistry.html">
                  service.concoursePaneExtensionRegistry.js
                </a>
              
                
                <a class="source" href="service.connectDropTarget.html">
                  service.connectDropTarget.js
                </a>
              
                
                <a class="source" href="service.conversationPersister.html">
                  service.conversationPersister.js
                </a>
              
                
                <a class="source" href="service.conversations.html">
                  service.conversations.js
                </a>
              
                
                <a class="source" href="service.dateUtils.html">
                  service.dateUtils.js
                </a>
              
                
                <a class="source" href="service.debounceFn.html">
                  service.debounceFn.js
                </a>
              
                
                <a class="source" href="service.documentLinkMatcher.html">
                  service.documentLinkMatcher.js
                </a>
              
                
                <a class="source" href="service.documents.html">
                  service.documents.js
                </a>
              
                
                <a class="source" href="service.durationFormatter.html">
                  service.durationFormatter.js
                </a>
              
                
                <a class="source" href="service.embeddedHelpService.html">
                  service.embeddedHelpService.js
                </a>
              
                
                <a class="source" href="service.fileSizeConverter.html">
                  service.fileSizeConverter.js
                </a>
              
                
                <a class="source" href="service.filterExpressionParser.html">
                  service.filterExpressionParser.js
                </a>
              
                
                <a class="source" href="service.getTemplateUrl.html">
                  service.getTemplateUrl.js
                </a>
              
                
                <a class="source" href="service.guidedToursService.html">
                  service.guidedToursService.js
                </a>
              
                
                <a class="source" href="service.hotKeyHandler.html">
                  service.hotKeyHandler.js
                </a>
              
                
                <a class="source" href="service.i18n.html">
                  service.i18n.js
                </a>
              
                
                <a class="source" href="service.legacySessionNotificationHandler.html">
                  service.legacySessionNotificationHandler.js
                </a>
              
                
                <a class="source" href="service.md5.html">
                  service.md5.js
                </a>
              
                
                <a class="source" href="service.messageBatcher.html">
                  service.messageBatcher.js
                </a>
              
                
                <a class="source" href="service.messageNotifier.html">
                  service.messageNotifier.js
                </a>
              
                
                <a class="source" href="service.messages.html">
                  service.messages.js
                </a>
              
                
                <a class="source" href="service.notificationPreferences.html">
                  service.notificationPreferences.js
                </a>
              
                
                <a class="source" href="service.nowServer.html">
                  service.nowServer.js
                </a>
              
                
                <a class="source" href="service.nowStream.html">
                  service.nowStream.js
                </a>
              
                
                <a class="source" href="service.priorityQueue.html">
                  service.priorityQueue.js
                </a>
              
                
                <a class="source" href="service.profiles.html">
                  service.profiles.js
                </a>
              
                
                <a class="source" href="service.progressDialog.html">
                  service.progressDialog.js
                </a>
              
                
                <a class="source" href="service.queryFilter.html">
                  service.queryFilter.js
                </a>
              
                
                <a class="source" href="service.queueEntries.html">
                  service.queueEntries.js
                </a>
              
                
                <a class="source" href="service.queueEntryNotifier.html">
                  service.queueEntryNotifier.js
                </a>
              
                
                <a class="source" href="service.queueNotifier.html">
                  service.queueNotifier.js
                </a>
              
                
                <a class="source" href="service.queues.html">
                  service.queues.js
                </a>
              
                
                <a class="source" href="service.resourcePersister.html">
                  service.resourcePersister.js
                </a>
              
                
                <a class="source" href="service.screenReaderStatus.html">
                  service.screenReaderStatus.js
                </a>
              
                
                <a class="source" href="service.screenWidth.html">
                  service.screenWidth.js
                </a>
              
                
                <a class="source" href="service.sessionNotificationInterceptor.html">
                  service.sessionNotificationInterceptor.js
                </a>
              
                
                <a class="source" href="service.snComplexPopoverService.html">
                  service.snComplexPopoverService.js
                </a>
              
                
                <a class="source" href="service.snComposingPresence.html">
                  service.snComposingPresence.js
                </a>
              
                
                <a class="source" href="service.snConnect.html">
                  service.snConnect.js
                </a>
              
                
                <a class="source" href="service.snConnectAsideManager.html">
                  service.snConnectAsideManager.js
                </a>
              
                
                <a class="source" href="service.snConnectMention.html">
                  service.snConnectMention.js
                </a>
              
                
                <a class="source" href="service.snConversationAsideHistory.html">
                  service.snConversationAsideHistory.js
                </a>
              
                
                <a class="source" href="service.snCustomEvent.html">
                  service.snCustomEvent.js
                </a>
              
                
                <a class="source" href="service.snHttp.html">
                  service.snHttp.js
                </a>
              
                
                <a class="source" href="service.snMention.html">
                  service.snMention.js
                </a>
              
                
                <a class="source" href="service.snNotification.html">
                  service.snNotification.js
                </a>
              
                
                <a class="source" href="service.snNotifier.html">
                  service.snNotifier.js
                </a>
              
                
                <a class="source" href="service.snResource.html">
                  service.snResource.js
                </a>
              
                
                <a class="source" href="service.snTabActivity.html">
                  service.snTabActivity.js
                </a>
              
                
                <a class="source" href="service.snTypingTracker.html">
                  service.snTypingTracker.js
                </a>
              
                
                <a class="source" href="service.spAria.html">
                  service.spAria.js
                </a>
              
                
                <a class="source" href="service.spAriaFocusManager.html">
                  service.spAriaFocusManager.js
                </a>
              
                
                <a class="source" href="service.spCodeEditorAutocomplete.html">
                  service.spCodeEditorAutocomplete.js
                </a>
              
                
                <a class="source" href="service.spIs.html">
                  service.spIs.js
                </a>
              
                
                <a class="source" href="service.spModal.html">
                  service.spModal.js
                </a>
              
                
                <a class="source" href="service.spPreference.html">
                  service.spPreference.js
                </a>
              
                
                <a class="source" href="service.spThrottle.html">
                  service.spThrottle.js
                </a>
              
                
                <a class="source" href="service.spUtil.html">
                  service.spUtil.js
                </a>
              
                
                <a class="source" href="service.supportTabHandler.html">
                  service.supportTabHandler.js
                </a>
              
                
                <a class="source" href="service.sysNumberData.html">
                  service.sysNumberData.js
                </a>
              
                
                <a class="source" href="service.titleFlasher.html">
                  service.titleFlasher.js
                </a>
              
                
                <a class="source" href="service.uiNotificationHandler.html">
                  service.uiNotificationHandler.js
                </a>
              
                
                <a class="source" href="service.unreadCount.html">
                  service.unreadCount.js
                </a>
              
                
                <a class="source" href="service.uploadAttachment.html">
                  service.uploadAttachment.js
                </a>
              
                
                <a class="source" href="service.urlTools.html">
                  service.urlTools.js
                </a>
              
                
                <a class="source" href="service.userData.html">
                  service.userData.js
                </a>
              
                
                <a class="source" href="service.userPreferences.html">
                  service.userPreferences.js
                </a>
              
                
                <a class="source" href="service.viewStack.html">
                  service.viewStack.js
                </a>
              
                
                <a class="source" href="simpleStorage.html">
                  simpleStorage.js
                </a>
              
                
                <a class="source" href="snPolyfill.html">
                  snPolyfill.js
                </a>
              
                
                <a class="source" href="snPopover.html">
                  snPopover.js
                </a>
              
                
                <a class="source" href="snPresenceLite.html">
                  snPresenceLite.js
                </a>
              
                
                <a class="source" href="snTimeAgoSettings.html">
                  snTimeAgoSettings.js
                </a>
              
                
                <a class="source" href="snm.auth.data.module.html">
                  snm.auth.data.module.js
                </a>
              
                
                <a class="source" href="snm.serviceCatalog.data.shim.html">
                  snm.serviceCatalog.data.shim.js
                </a>
              
                
                <a class="source" href="snm.serviceCatalog.form.module.html">
                  snm.serviceCatalog.form.module.js
                </a>
              
                
                <a class="source" href="solid-gauge.html">
                  solid-gauge.js
                </a>
              
                
                <a class="source" href="sortable.min.html">
                  sortable.min.js
                </a>
              
                
                <a class="source" href="sp.geo.html">
                  sp.geo.js
                </a>
              
                
                <a class="source" href="streamButton.html">
                  streamButton.js
                </a>
              
                
                <a class="source" href="tabbable.html">
                  tabbable.js
                </a>
              
                
                <a class="source" href="tables.html">
                  tables.js
                </a>
              
                
                <a class="source" href="tabs.html">
                  tabs.js
                </a>
              
                
                <a class="source" href="tabs2_14.html">
                  tabs2_14.js
                </a>
              
                
                <a class="source" href="templates.html">
                  templates.js
                </a>
              
                
                <a class="source" href="textutil.html">
                  textutil.js
                </a>
              
                
                <a class="source" href="theme.min.html">
                  theme.min.js
                </a>
              
                
                <a class="source" href="timeAgo.html">
                  timeAgo.js
                </a>
              
                
                <a class="source" href="tinymce.min.html">
                  tinymce.min.js
                </a>
              
                
                <a class="source" href="tooltip.html">
                  tooltip.js
                </a>
              
                
                <a class="source" href="tooltips.html">
                  tooltips.js
                </a>
              
                
                <a class="source" href="transaction_scope_includes.html">
                  transaction_scope_includes.js
                </a>
              
                
                <a class="source" href="transition.html">
                  transition.js
                </a>
              
                
                <a class="source" href="treemap.html">
                  treemap.js
                </a>
              
                
                <a class="source" href="typeahead.jquery.html">
                  typeahead.jquery.js
                </a>
              
                
                <a class="source" href="ui-bootstrap-tpls-0.12.1.html">
                  ui-bootstrap-tpls-0.12.1.js
                </a>
              
                
                <a class="source" href="ui-bootstrap-tpls-1.1.2.html">
                  ui-bootstrap-tpls-1.1.2.js
                </a>
              
                
                <a class="source" href="ui-sortable.html">
                  ui-sortable.js
                </a>
              
                
                <a class="source" href="uiPolicyFactory.html">
                  uiPolicyFactory.js
                </a>
              
                
                <a class="source" href="uiPolicyTypes.html">
                  uiPolicyTypes.js
                </a>
              
                
                <a class="source" href="ui_policy.html">
                  ui_policy.js
                </a>
              
                
                <a class="source" href="utils14.html">
                  utils14.js
                </a>
              
                
                <a class="source" href="vanilla.cometd.html">
                  vanilla.cometd.js
                </a>
              
                
                <a class="source" href="velocity.min.html">
                  velocity.min.js
                </a>
              
                
                <a class="source" href="velocity.ui.html">
                  velocity.ui.js
                </a>
              
                
                <a class="source" href="viewLayout.html">
                  viewLayout.js
                </a>
              
                
                <a class="source" href="xmlUtil.html">
                  xmlUtil.js
                </a>
              
                
                <a class="source" href="xmlhttp.html">
                  xmlhttp.js
                </a>
              
                
                <a class="source" href="z_last_include.html">
                  z_last_include.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>highstock.src.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/*! RESOURCE: /scripts/highcharts/highstock.src.js */</span>
<span class="hljs-meta">'use strict'</span>;
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, factory</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">module</span> === <span class="hljs-string">'object'</span> &amp;&amp; <span class="hljs-built_in">module</span>.exports) {
        <span class="hljs-built_in">module</span>.exports = root.document ?
            factory(root) :
            factory;
    } <span class="hljs-keyword">else</span> {
        root.Highcharts = factory(root);
    }
}(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">window</span> : <span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">win</span>) </span>{
    <span class="hljs-keyword">var</span> Highcharts = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> win = <span class="hljs-built_in">window</span>,
            doc = win.document;
        <span class="hljs-keyword">var</span> SVG_NS = <span class="hljs-string">'http://www.w3.org/2000/svg'</span>,
            userAgent = (win.navigator &amp;&amp; win.navigator.userAgent) || <span class="hljs-string">''</span>,
            svg = doc &amp;&amp; doc.createElementNS &amp;&amp; !!doc.createElementNS(SVG_NS, <span class="hljs-string">'svg'</span>).createSVGRect,
            isMS = <span class="hljs-regexp">/(edge|msie|trident)/i</span>.test(userAgent) &amp;&amp; !<span class="hljs-built_in">window</span>.opera,
            vml = !svg,
            isFirefox = <span class="hljs-regexp">/Firefox/</span>.test(userAgent),
            hasBidiBug = isFirefox &amp;&amp; <span class="hljs-built_in">parseInt</span>(userAgent.split(<span class="hljs-string">'Firefox/'</span>)[<span class="hljs-number">1</span>], <span class="hljs-number">10</span>) &lt; <span class="hljs-number">4</span>;
        <span class="hljs-keyword">var</span> Highcharts = win.Highcharts ? win.Highcharts.error(<span class="hljs-number">16</span>, <span class="hljs-literal">true</span>) : {
            <span class="hljs-attr">product</span>: <span class="hljs-string">'Highstock'</span>,
            <span class="hljs-attr">version</span>: <span class="hljs-string">'5.0.7'</span>,
            <span class="hljs-attr">deg2rad</span>: <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span> / <span class="hljs-number">360</span>,
            <span class="hljs-attr">doc</span>: doc,
            <span class="hljs-attr">hasBidiBug</span>: hasBidiBug,
            <span class="hljs-attr">hasTouch</span>: doc &amp;&amp; doc.documentElement.ontouchstart !== <span class="hljs-literal">undefined</span>,
            <span class="hljs-attr">isMS</span>: isMS,
            <span class="hljs-attr">isWebKit</span>: <span class="hljs-regexp">/AppleWebKit/</span>.test(userAgent),
            <span class="hljs-attr">isFirefox</span>: isFirefox,
            <span class="hljs-attr">isTouchDevice</span>: <span class="hljs-regexp">/(Mobile|Android|Windows Phone)/</span>.test(userAgent),
            <span class="hljs-attr">SVG_NS</span>: SVG_NS,
            <span class="hljs-attr">chartCount</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">seriesTypes</span>: {},
            <span class="hljs-attr">symbolSizes</span>: {},
            <span class="hljs-attr">svg</span>: svg,
            <span class="hljs-attr">vml</span>: vml,
            <span class="hljs-attr">win</span>: win,
            <span class="hljs-attr">charts</span>: [],
            <span class="hljs-attr">marginNames</span>: [<span class="hljs-string">'plotTop'</span>, <span class="hljs-string">'marginRight'</span>, <span class="hljs-string">'marginBottom'</span>, <span class="hljs-string">'plotLeft'</span>],
            <span class="hljs-attr">noop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
            }
        };
        <span class="hljs-keyword">return</span> Highcharts;
    }());
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> timers = [];
        <span class="hljs-keyword">var</span> charts = H.charts,
            doc = H.doc,
            win = H.win;
        H.error = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code, stop</span>) </span>{
            <span class="hljs-keyword">var</span> msg = H.isNumber(code) ?
                <span class="hljs-string">'Highcharts error #'</span> + code + <span class="hljs-string">': www.highcharts.com/errors/'</span> + code :
                code;
            <span class="hljs-keyword">if</span> (stop) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(msg);
            }
            <span class="hljs-keyword">if</span> (win.console) {
                <span class="hljs-built_in">console</span>.log(msg);
            }
        };
        H.Fx = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, options, prop</span>) </span>{
            <span class="hljs-keyword">this</span>.options = options;
            <span class="hljs-keyword">this</span>.elem = elem;
            <span class="hljs-keyword">this</span>.prop = prop;
        };
        H.Fx.prototype = {
            <span class="hljs-attr">dSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>.paths[<span class="hljs-number">0</span>],
                    end = <span class="hljs-keyword">this</span>.paths[<span class="hljs-number">1</span>],
                    ret = [],
                    now = <span class="hljs-keyword">this</span>.now,
                    i = start.length,
                    startVal;
                <span class="hljs-keyword">if</span> (now === <span class="hljs-number">1</span>) {
                    ret = <span class="hljs-keyword">this</span>.toD;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === end.length &amp;&amp; now &lt; <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">while</span> (i--) {
                        startVal = <span class="hljs-built_in">parseFloat</span>(start[i]);
                        ret[i] =
                            <span class="hljs-built_in">isNaN</span>(startVal) ?
                            start[i] :
                            now * (<span class="hljs-built_in">parseFloat</span>(end[i] - startVal)) + startVal;
                    }
                } <span class="hljs-keyword">else</span> {
                    ret = end;
                }
                <span class="hljs-keyword">this</span>.elem.attr(<span class="hljs-string">'d'</span>, ret, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> elem = <span class="hljs-keyword">this</span>.elem,
                    prop = <span class="hljs-keyword">this</span>.prop,
                    now = <span class="hljs-keyword">this</span>.now,
                    step = <span class="hljs-keyword">this</span>.options.step;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[prop + <span class="hljs-string">'Setter'</span>]) {
                    <span class="hljs-keyword">this</span>[prop + <span class="hljs-string">'Setter'</span>]();
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem.attr) {
                    <span class="hljs-keyword">if</span> (elem.element) {
                        elem.attr(prop, now, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
                    }
                } <span class="hljs-keyword">else</span> {
                    elem.style[prop] = now + <span class="hljs-keyword">this</span>.unit;
                }
                <span class="hljs-keyword">if</span> (step) {
                    step.call(elem, now, <span class="hljs-keyword">this</span>);
                }
            },
            <span class="hljs-attr">run</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to, unit</span>) </span>{
                <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
                    timer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gotoEnd</span>) </span>{
                        <span class="hljs-keyword">return</span> timer.stopped ? <span class="hljs-literal">false</span> : self.step(gotoEnd);
                    },
                    i;
                <span class="hljs-keyword">this</span>.startTime = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
                <span class="hljs-keyword">this</span>.start = <span class="hljs-keyword">from</span>;
                <span class="hljs-keyword">this</span>.end = to;
                <span class="hljs-keyword">this</span>.unit = unit;
                <span class="hljs-keyword">this</span>.now = <span class="hljs-keyword">this</span>.start;
                <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">0</span>;
                timer.elem = <span class="hljs-keyword">this</span>.elem;
                timer.prop = <span class="hljs-keyword">this</span>.prop;
                <span class="hljs-keyword">if</span> (timer() &amp;&amp; timers.push(timer) === <span class="hljs-number">1</span>) {
                    timer.timerId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; timers.length; i++) {
                            <span class="hljs-keyword">if</span> (!timers[i]()) {
                                timers.splice(i--, <span class="hljs-number">1</span>);
                            }
                        }
                        <span class="hljs-keyword">if</span> (!timers.length) {
                            clearInterval(timer.timerId);
                        }
                    }, <span class="hljs-number">13</span>);
                }
            },
            <span class="hljs-attr">step</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">gotoEnd</span>) </span>{
                <span class="hljs-keyword">var</span> t = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(),
                    ret,
                    done,
                    options = <span class="hljs-keyword">this</span>.options,
                    elem = <span class="hljs-keyword">this</span>.elem,
                    complete = options.complete,
                    duration = options.duration,
                    curAnim = options.curAnim,
                    i;
                <span class="hljs-keyword">if</span> (elem.attr &amp;&amp; !elem.element) {
                    ret = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gotoEnd || t &gt;= duration + <span class="hljs-keyword">this</span>.startTime) {
                    <span class="hljs-keyword">this</span>.now = <span class="hljs-keyword">this</span>.end;
                    <span class="hljs-keyword">this</span>.pos = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">this</span>.update();
                    curAnim[<span class="hljs-keyword">this</span>.prop] = <span class="hljs-literal">true</span>;
                    done = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> curAnim) {
                        <span class="hljs-keyword">if</span> (curAnim[i] !== <span class="hljs-literal">true</span>) {
                            done = <span class="hljs-literal">false</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (done &amp;&amp; complete) {
                        complete.call(elem);
                    }
                    ret = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.pos = options.easing((t - <span class="hljs-keyword">this</span>.startTime) / duration);
                    <span class="hljs-keyword">this</span>.now = <span class="hljs-keyword">this</span>.start + ((<span class="hljs-keyword">this</span>.end - <span class="hljs-keyword">this</span>.start) * <span class="hljs-keyword">this</span>.pos);
                    <span class="hljs-keyword">this</span>.update();
                    ret = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">initPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, fromD, toD</span>) </span>{
                fromD = fromD || <span class="hljs-string">''</span>;
                <span class="hljs-keyword">var</span> shift,
                    startX = elem.startX,
                    endX = elem.endX,
                    bezier = fromD.indexOf(<span class="hljs-string">'C'</span>) &gt; <span class="hljs-number">-1</span>,
                    numParams = bezier ? <span class="hljs-number">7</span> : <span class="hljs-number">3</span>,
                    fullLength,
                    slice,
                    i,
                    start = fromD.split(<span class="hljs-string">' '</span>),
                    end = toD.slice(),
                    isArea = elem.isArea,
                    positionFactor = isArea ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>,
                    reverse;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sixify</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">var</span> isOperator,
                        nextIsOperator;
                    i = arr.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        isOperator = arr[i] === <span class="hljs-string">'M'</span> || arr[i] === <span class="hljs-string">'L'</span>;
                        nextIsOperator = <span class="hljs-regexp">/[a-zA-Z]/</span>.test(arr[i + <span class="hljs-number">3</span>]);
                        <span class="hljs-keyword">if</span> (isOperator &amp;&amp; nextIsOperator) {
                            arr.splice(
                                i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>,
                                arr[i + <span class="hljs-number">1</span>], arr[i + <span class="hljs-number">2</span>],
                                arr[i + <span class="hljs-number">1</span>], arr[i + <span class="hljs-number">2</span>]
                            );
                        }
                    }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insertSlice</span>(<span class="hljs-params">arr, subArr, index</span>) </span>{
                    [].splice.apply(
                        arr, [index, <span class="hljs-number">0</span>].concat(subArr)
                    );
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prepend</span>(<span class="hljs-params">arr, other</span>) </span>{
                    <span class="hljs-keyword">while</span> (arr.length &lt; fullLength) {
                        arr[<span class="hljs-number">0</span>] = other[fullLength - arr.length];
                        insertSlice(arr, arr.slice(<span class="hljs-number">0</span>, numParams), <span class="hljs-number">0</span>);
                        <span class="hljs-keyword">if</span> (isArea) {
                            insertSlice(
                                arr,
                                arr.slice(arr.length - numParams), arr.length
                            );
                            i--;
                        }
                    }
                    arr[<span class="hljs-number">0</span>] = <span class="hljs-string">'M'</span>;
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">append</span>(<span class="hljs-params">arr, other</span>) </span>{
                    <span class="hljs-keyword">var</span> i = (fullLength - arr.length) / numParams;
                    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; i--) {
                        slice = arr.slice().splice(
                            (arr.length / positionFactor) - numParams,
                            numParams * positionFactor
                        );
                        slice[<span class="hljs-number">0</span>] = other[fullLength - numParams - (i * numParams)];
                        <span class="hljs-keyword">if</span> (bezier) {
                            slice[numParams - <span class="hljs-number">6</span>] = slice[numParams - <span class="hljs-number">2</span>];
                            slice[numParams - <span class="hljs-number">5</span>] = slice[numParams - <span class="hljs-number">1</span>];
                        }
                        insertSlice(arr, slice, arr.length / positionFactor);
                        <span class="hljs-keyword">if</span> (isArea) {
                            i--;
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (bezier) {
                    sixify(start);
                    sixify(end);
                }
                <span class="hljs-keyword">if</span> (startX &amp;&amp; endX) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; startX.length; i++) {
                        <span class="hljs-keyword">if</span> (startX[i] === endX[<span class="hljs-number">0</span>]) {
                            shift = i;
                            <span class="hljs-keyword">break</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startX[<span class="hljs-number">0</span>] ===
                            endX[endX.length - startX.length + i]) {
                            shift = i;
                            reverse = <span class="hljs-literal">true</span>;
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (shift === <span class="hljs-literal">undefined</span>) {
                        start = [];
                    }
                }
                <span class="hljs-keyword">if</span> (start.length &amp;&amp; H.isNumber(shift)) {
                    fullLength = end.length + shift * positionFactor * numParams;
                    <span class="hljs-keyword">if</span> (!reverse) {
                        prepend(end, start);
                        append(start, end);
                    } <span class="hljs-keyword">else</span> {
                        prepend(start, end);
                        append(end, start);
                    }
                }
                <span class="hljs-keyword">return</span> [start, end];
            }
        };
        H.extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
            <span class="hljs-keyword">var</span> n;
            <span class="hljs-keyword">if</span> (!a) {
                a = {};
            }
            <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> b) {
                a[n] = b[n];
            }
            <span class="hljs-keyword">return</span> a;
        };
        H.merge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> i,
                args = <span class="hljs-built_in">arguments</span>,
                len,
                ret = {},
                doCopy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">copy, original</span>) </span>{
                    <span class="hljs-keyword">var</span> value, key;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> copy !== <span class="hljs-string">'object'</span>) {
                        copy = {};
                    }
                    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> original) {
                        <span class="hljs-keyword">if</span> (original.hasOwnProperty(key)) {
                            value = original[key];
                            <span class="hljs-keyword">if</span> (H.isObject(value, <span class="hljs-literal">true</span>) &amp;&amp;
                                key !== <span class="hljs-string">'renderTo'</span> &amp;&amp;
                                <span class="hljs-keyword">typeof</span> value.nodeType !== <span class="hljs-string">'number'</span>) {
                                copy[key] = doCopy(copy[key] || {}, value);
                            } <span class="hljs-keyword">else</span> {
                                copy[key] = original[key];
                            }
                        }
                    }
                    <span class="hljs-keyword">return</span> copy;
                };
            <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>] === <span class="hljs-literal">true</span>) {
                ret = args[<span class="hljs-number">1</span>];
                args = <span class="hljs-built_in">Array</span>.prototype.slice.call(args, <span class="hljs-number">2</span>);
            }
            len = args.length;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                ret = doCopy(ret, args[i]);
            }
            <span class="hljs-keyword">return</span> ret;
        };
        H.pInt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s, mag</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(s, mag || <span class="hljs-number">10</span>);
        };
        H.isString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> s === <span class="hljs-string">'string'</span>;
        };
        H.isArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">var</span> str = <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);
            <span class="hljs-keyword">return</span> str === <span class="hljs-string">'[object Array]'</span> || str === <span class="hljs-string">'[object Array Iterator]'</span>;
        };
        H.isObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, strict</span>) </span>{
            <span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp; (!strict || !H.isArray(obj));
        };
        H.isNumber = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> n === <span class="hljs-string">'number'</span> &amp;&amp; !<span class="hljs-built_in">isNaN</span>(n);
        };
        H.erase = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, item</span>) </span>{
            <span class="hljs-keyword">var</span> i = arr.length;
            <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (arr[i] === item) {
                    arr.splice(i, <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">break</span>;
                }
            }
        };
        H.defined = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">undefined</span> &amp;&amp; obj !== <span class="hljs-literal">null</span>;
        };
        H.attr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, prop, value</span>) </span>{
            <span class="hljs-keyword">var</span> key,
                ret;
            <span class="hljs-keyword">if</span> (H.isString(prop)) {
                <span class="hljs-keyword">if</span> (H.defined(value)) {
                    elem.setAttribute(prop, value);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem &amp;&amp; elem.getAttribute) {
                    ret = elem.getAttribute(prop);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (H.defined(prop) &amp;&amp; H.isObject(prop)) {
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> prop) {
                    elem.setAttribute(key, prop[key]);
                }
            }
            <span class="hljs-keyword">return</span> ret;
        };
        H.splat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
            <span class="hljs-keyword">return</span> H.isArray(obj) ? obj : [obj];
        };
        H.syncTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn, delay, context</span>) </span>{
            <span class="hljs-keyword">if</span> (delay) {
                <span class="hljs-keyword">return</span> setTimeout(fn, delay, context);
            }
            fn.call(<span class="hljs-number">0</span>, context);
        };
        H.pick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>,
                i,
                arg,
                length = args.length;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                arg = args[i];
                <span class="hljs-keyword">if</span> (arg !== <span class="hljs-literal">undefined</span> &amp;&amp; arg !== <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">return</span> arg;
                }
            }
        };
        H.css = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, styles</span>) </span>{
            <span class="hljs-keyword">if</span> (H.isMS &amp;&amp; !H.svg) {
                <span class="hljs-keyword">if</span> (styles &amp;&amp; styles.opacity !== <span class="hljs-literal">undefined</span>) {
                    styles.filter = <span class="hljs-string">'alpha(opacity='</span> + (styles.opacity * <span class="hljs-number">100</span>) + <span class="hljs-string">')'</span>;
                }
            }
            H.extend(el.style, styles);
        };
        H.createElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tag, attribs, styles, parent, nopad</span>) </span>{
            <span class="hljs-keyword">var</span> el = doc.createElement(tag),
                css = H.css;
            <span class="hljs-keyword">if</span> (attribs) {
                H.extend(el, attribs);
            }
            <span class="hljs-keyword">if</span> (nopad) {
                css(el, {
                    <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">border</span>: <span class="hljs-string">'none'</span>,
                    <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span>
                });
            }
            <span class="hljs-keyword">if</span> (styles) {
                css(el, styles);
            }
            <span class="hljs-keyword">if</span> (parent) {
                parent.appendChild(el);
            }
            <span class="hljs-keyword">return</span> el;
        };
        H.extendClass = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">parent, members</span>) </span>{
            <span class="hljs-keyword">var</span> object = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
            object.prototype = <span class="hljs-keyword">new</span> parent();
            H.extend(object.prototype, members);
            <span class="hljs-keyword">return</span> object;
        };
        H.pad = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number, length, padder</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>((length || <span class="hljs-number">2</span>) + <span class="hljs-number">1</span> -
                <span class="hljs-built_in">String</span>(number).length).join(padder || <span class="hljs-number">0</span>) + number;
        };
        H.relativeLength = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, base</span>) </span>{
            <span class="hljs-keyword">return</span> (<span class="hljs-regexp">/%$/</span>).test(value) ?
                base * <span class="hljs-built_in">parseFloat</span>(value) / <span class="hljs-number">100</span> :
                <span class="hljs-built_in">parseFloat</span>(value);
        };
        H.wrap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, method, func</span>) </span>{
            <span class="hljs-keyword">var</span> proceed = obj[method];
            obj[method] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>),
                    outerArgs = <span class="hljs-built_in">arguments</span>,
                    ctx = <span class="hljs-keyword">this</span>,
                    ret;
                ctx.proceed = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    proceed.apply(ctx, <span class="hljs-built_in">arguments</span>.length ? <span class="hljs-built_in">arguments</span> : outerArgs);
                };
                args.unshift(proceed);
                ret = func.apply(<span class="hljs-keyword">this</span>, args);
                ctx.proceed = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">return</span> ret;
            };
        };
        H.getTZOffset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">timestamp</span>) </span>{
            <span class="hljs-keyword">var</span> d = H.Date;
            <span class="hljs-keyword">return</span> ((d.hcGetTimezoneOffset &amp;&amp; d.hcGetTimezoneOffset(timestamp)) ||
                d.hcTimezoneOffset || <span class="hljs-number">0</span>) * <span class="hljs-number">60000</span>;
        };
        H.dateFormat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">format, timestamp, capitalize</span>) </span>{
            <span class="hljs-keyword">if</span> (!H.defined(timestamp) || <span class="hljs-built_in">isNaN</span>(timestamp)) {
                <span class="hljs-keyword">return</span> H.defaultOptions.lang.invalidDate || <span class="hljs-string">''</span>;
            }
            format = H.pick(format, <span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>);
            <span class="hljs-keyword">var</span> D = H.Date,
                date = <span class="hljs-keyword">new</span> D(timestamp - H.getTZOffset(timestamp)),
                key,
                hours = date[D.hcGetHours](),
                day = date[D.hcGetDay](),
                dayOfMonth = date[D.hcGetDate](),
                month = date[D.hcGetMonth](),
                fullYear = date[D.hcGetFullYear](),
                lang = H.defaultOptions.lang,
                langWeekdays = lang.weekdays,
                shortWeekdays = lang.shortWeekdays,
                pad = H.pad,
                replacements = H.extend({
                    <span class="hljs-string">'a'</span>: shortWeekdays ?
                        shortWeekdays[day] : langWeekdays[day].substr(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>),
                    <span class="hljs-string">'A'</span>: langWeekdays[day],
                    <span class="hljs-string">'d'</span>: pad(dayOfMonth),
                    <span class="hljs-string">'e'</span>: pad(dayOfMonth, <span class="hljs-number">2</span>, <span class="hljs-string">' '</span>),
                    <span class="hljs-string">'w'</span>: day,
                    <span class="hljs-string">'b'</span>: lang.shortMonths[month],
                    <span class="hljs-string">'B'</span>: lang.months[month],
                    <span class="hljs-string">'m'</span>: pad(month + <span class="hljs-number">1</span>),
                    <span class="hljs-string">'y'</span>: fullYear.toString().substr(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),
                    <span class="hljs-string">'Y'</span>: fullYear,
                    <span class="hljs-string">'H'</span>: pad(hours),
                    <span class="hljs-string">'k'</span>: hours,
                    <span class="hljs-string">'I'</span>: pad((hours % <span class="hljs-number">12</span>) || <span class="hljs-number">12</span>),
                    <span class="hljs-string">'l'</span>: (hours % <span class="hljs-number">12</span>) || <span class="hljs-number">12</span>,
                    <span class="hljs-string">'M'</span>: pad(date[D.hcGetMinutes]()),
                    <span class="hljs-string">'p'</span>: hours &lt; <span class="hljs-number">12</span> ? <span class="hljs-string">'AM'</span> : <span class="hljs-string">'PM'</span>,
                    <span class="hljs-string">'P'</span>: hours &lt; <span class="hljs-number">12</span> ? <span class="hljs-string">'am'</span> : <span class="hljs-string">'pm'</span>,
                    <span class="hljs-string">'S'</span>: pad(date.getSeconds()),
                    <span class="hljs-string">'L'</span>: pad(<span class="hljs-built_in">Math</span>.round(timestamp % <span class="hljs-number">1000</span>), <span class="hljs-number">3</span>)
                }, H.dateFormats);
            <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> replacements) {
                <span class="hljs-keyword">while</span> (format.indexOf(<span class="hljs-string">'%'</span> + key) !== <span class="hljs-number">-1</span>) {
                    format = format.replace(
                        <span class="hljs-string">'%'</span> + key,
                        <span class="hljs-keyword">typeof</span> replacements[key] === <span class="hljs-string">'function'</span> ?
                        replacements[key](timestamp) :
                        replacements[key]
                    );
                }
            }
            <span class="hljs-keyword">return</span> capitalize ?
                format.substr(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + format.substr(<span class="hljs-number">1</span>) :
                format;
        };
        H.formatSingle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">format, val</span>) </span>{
            <span class="hljs-keyword">var</span> floatRegex = <span class="hljs-regexp">/f$/</span>,
                decRegex = <span class="hljs-regexp">/\.([0-9])/</span>,
                lang = H.defaultOptions.lang,
                decimals;
            <span class="hljs-keyword">if</span> (floatRegex.test(format)) {
                decimals = format.match(decRegex);
                decimals = decimals ? decimals[<span class="hljs-number">1</span>] : <span class="hljs-number">-1</span>;
                <span class="hljs-keyword">if</span> (val !== <span class="hljs-literal">null</span>) {
                    val = H.numberFormat(
                        val,
                        decimals,
                        lang.decimalPoint,
                        format.indexOf(<span class="hljs-string">','</span>) &gt; <span class="hljs-number">-1</span> ? lang.thousandsSep : <span class="hljs-string">''</span>
                    );
                }
            } <span class="hljs-keyword">else</span> {
                val = H.dateFormat(format, val);
            }
            <span class="hljs-keyword">return</span> val;
        };
        H.format = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, ctx</span>) </span>{
            <span class="hljs-keyword">var</span> splitter = <span class="hljs-string">'{'</span>,
                isInside = <span class="hljs-literal">false</span>,
                segment,
                valueAndFormat,
                path,
                i,
                len,
                ret = [],
                val,
                index;
            <span class="hljs-keyword">while</span> (str) {
                index = str.indexOf(splitter);
                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">break</span>;
                }
                segment = str.slice(<span class="hljs-number">0</span>, index);
                <span class="hljs-keyword">if</span> (isInside) {
                    valueAndFormat = segment.split(<span class="hljs-string">':'</span>);
                    path = valueAndFormat.shift().split(<span class="hljs-string">'.'</span>);
                    len = path.length;
                    val = ctx;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                        val = val[path[i]];
                    }
                    <span class="hljs-keyword">if</span> (valueAndFormat.length) {
                        val = H.formatSingle(valueAndFormat.join(<span class="hljs-string">':'</span>), val);
                    }
                    ret.push(val);
                } <span class="hljs-keyword">else</span> {
                    ret.push(segment);
                }
                str = str.slice(index + <span class="hljs-number">1</span>);
                isInside = !isInside;
                splitter = isInside ? <span class="hljs-string">'}'</span> : <span class="hljs-string">'{'</span>;
            }
            ret.push(str);
            <span class="hljs-keyword">return</span> ret.join(<span class="hljs-string">''</span>);
        };
        H.getMagnitude = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.log(num) / <span class="hljs-built_in">Math</span>.LN10));
        };
        H.normalizeTickInterval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">interval, multiples, magnitude,
            allowDecimals, hasTickAmount</span>) </span>{
            <span class="hljs-keyword">var</span> normalized,
                i,
                retInterval = interval;
            magnitude = H.pick(magnitude, <span class="hljs-number">1</span>);
            normalized = interval / magnitude;
            <span class="hljs-keyword">if</span> (!multiples) {
                multiples = hasTickAmount ? [<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>] : [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>];
                <span class="hljs-keyword">if</span> (allowDecimals === <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">if</span> (magnitude === <span class="hljs-number">1</span>) {
                        multiples = H.grep(multiples, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>{
                            <span class="hljs-keyword">return</span> num % <span class="hljs-number">1</span> === <span class="hljs-number">0</span>;
                        });
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (magnitude &lt;= <span class="hljs-number">0.1</span>) {
                        multiples = [<span class="hljs-number">1</span> / magnitude];
                    }
                }
            }
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; multiples.length; i++) {
                retInterval = multiples[i];
                <span class="hljs-keyword">if</span> ((hasTickAmount &amp;&amp; retInterval * magnitude &gt;= interval) ||
                    (!hasTickAmount &amp;&amp; (normalized &lt;= (multiples[i] +
                        (multiples[i + <span class="hljs-number">1</span>] || multiples[i])) / <span class="hljs-number">2</span>))) {
                    <span class="hljs-keyword">break</span>;
                }
            }
            retInterval = H.correctFloat(
                retInterval * magnitude, -<span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.log(<span class="hljs-number">0.001</span>) / <span class="hljs-built_in">Math</span>.LN10)
            );
            <span class="hljs-keyword">return</span> retInterval;
        };
        H.stableSort = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, sortFunction</span>) </span>{
            <span class="hljs-keyword">var</span> length = arr.length,
                sortValue,
                i;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                arr[i].safeI = i;
            }
            arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                sortValue = sortFunction(a, b);
                <span class="hljs-keyword">return</span> sortValue === <span class="hljs-number">0</span> ? a.safeI - b.safeI : sortValue;
            });
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                <span class="hljs-keyword">delete</span> arr[i].safeI;
            }
        };
        H.arrayMin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">var</span> i = data.length,
                min = data[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (data[i] &lt; min) {
                    min = data[i];
                }
            }
            <span class="hljs-keyword">return</span> min;
        };
        H.arrayMax = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>{
            <span class="hljs-keyword">var</span> i = data.length,
                max = data[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (data[i] &gt; max) {
                    max = data[i];
                }
            }
            <span class="hljs-keyword">return</span> max;
        };
        H.destroyObjectProperties = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, except</span>) </span>{
            <span class="hljs-keyword">var</span> n;
            <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> obj) {
                <span class="hljs-keyword">if</span> (obj[n] &amp;&amp; obj[n] !== except &amp;&amp; obj[n].destroy) {
                    obj[n].destroy();
                }
                <span class="hljs-keyword">delete</span> obj[n];
            }
        };
        H.discardElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
            <span class="hljs-keyword">var</span> garbageBin = H.garbageBin;
            <span class="hljs-keyword">if</span> (!garbageBin) {
                garbageBin = H.createElement(<span class="hljs-string">'div'</span>);
            }
            <span class="hljs-keyword">if</span> (element) {
                garbageBin.appendChild(element);
            }
            garbageBin.innerHTML = <span class="hljs-string">''</span>;
        };
        H.correctFloat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num, prec</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseFloat</span>(
                num.toPrecision(prec || <span class="hljs-number">14</span>)
            );
        };
        H.setAnimation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">animation, chart</span>) </span>{
            chart.renderer.globalAnimation = H.pick(
                animation,
                chart.options.chart.animation,
                <span class="hljs-literal">true</span>
            );
        };
        H.animObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">animation</span>) </span>{
            <span class="hljs-keyword">return</span> H.isObject(animation) ?
                H.merge(animation) : {
                    <span class="hljs-attr">duration</span>: animation ? <span class="hljs-number">500</span> : <span class="hljs-number">0</span>
                };
        };
        H.timeUnits = {
            <span class="hljs-attr">millisecond</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">second</span>: <span class="hljs-number">1000</span>,
            <span class="hljs-attr">minute</span>: <span class="hljs-number">60000</span>,
            <span class="hljs-attr">hour</span>: <span class="hljs-number">3600000</span>,
            <span class="hljs-attr">day</span>: <span class="hljs-number">24</span> * <span class="hljs-number">3600000</span>,
            <span class="hljs-attr">week</span>: <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600000</span>,
            <span class="hljs-attr">month</span>: <span class="hljs-number">28</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600000</span>,
            <span class="hljs-attr">year</span>: <span class="hljs-number">364</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600000</span>
        };
        H.numberFormat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">number, decimals, decimalPoint, thousandsSep</span>) </span>{
            number = +number || <span class="hljs-number">0</span>;
            decimals = +decimals;
            <span class="hljs-keyword">var</span> lang = H.defaultOptions.lang,
                origDec = (number.toString().split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">1</span>] || <span class="hljs-string">''</span>).length,
                strinteger,
                thousands,
                ret,
                roundedNumber;
            <span class="hljs-keyword">if</span> (decimals === <span class="hljs-number">-1</span>) {
                decimals = <span class="hljs-built_in">Math</span>.min(origDec, <span class="hljs-number">20</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!H.isNumber(decimals)) {
                decimals = <span class="hljs-number">2</span>;
            }
            roundedNumber = (
                <span class="hljs-built_in">Math</span>.abs(number) + <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, -<span class="hljs-built_in">Math</span>.max(decimals, origDec) - <span class="hljs-number">1</span>)
            ).toFixed(decimals);
            strinteger = <span class="hljs-built_in">String</span>(H.pInt(roundedNumber));
            thousands = strinteger.length &gt; <span class="hljs-number">3</span> ? strinteger.length % <span class="hljs-number">3</span> : <span class="hljs-number">0</span>;
            decimalPoint = H.pick(decimalPoint, lang.decimalPoint);
            thousandsSep = H.pick(thousandsSep, lang.thousandsSep);
            ret = number &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>;
            ret += thousands ? strinteger.substr(<span class="hljs-number">0</span>, thousands) + thousandsSep : <span class="hljs-string">''</span>;
            ret += strinteger
                .substr(thousands)
                .replace(<span class="hljs-regexp">/(\d{3})(?=\d)/g</span>, <span class="hljs-string">'$1'</span> + thousandsSep);
            <span class="hljs-keyword">if</span> (decimals) {
                ret += decimalPoint + roundedNumber.slice(-decimals);
            }
            <span class="hljs-keyword">return</span> ret;
        };
        <span class="hljs-built_in">Math</span>.easeInOutSine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-number">-0.5</span> * (<span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">Math</span>.PI * pos) - <span class="hljs-number">1</span>);
        };
        H.getStyle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, prop</span>) </span>{
            <span class="hljs-keyword">var</span> style;
            <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'width'</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(el.offsetWidth, el.scrollWidth) -
                    H.getStyle(el, <span class="hljs-string">'padding-left'</span>) -
                    H.getStyle(el, <span class="hljs-string">'padding-right'</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'height'</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min(el.offsetHeight, el.scrollHeight) -
                    H.getStyle(el, <span class="hljs-string">'padding-top'</span>) -
                    H.getStyle(el, <span class="hljs-string">'padding-bottom'</span>);
            }
            style = win.getComputedStyle(el, <span class="hljs-literal">undefined</span>);
            <span class="hljs-keyword">return</span> style &amp;&amp; H.pInt(style.getPropertyValue(prop));
        };
        H.inArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, arr</span>) </span>{
            <span class="hljs-keyword">return</span> arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);
        };
        H.grep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, callback</span>) </span>{
            <span class="hljs-keyword">return</span> [].filter.call(arr, callback);
        };
        H.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, callback</span>) </span>{
            <span class="hljs-keyword">return</span> [].find.call(arr, callback);
        };
        H.map = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, fn</span>) </span>{
            <span class="hljs-keyword">var</span> results = [],
                i = <span class="hljs-number">0</span>,
                len = arr.length;
            <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                results[i] = fn.call(arr[i], arr[i], i, arr);
            }
            <span class="hljs-keyword">return</span> results;
        };
        H.offset = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
            <span class="hljs-keyword">var</span> docElem = doc.documentElement,
                box = el.getBoundingClientRect();
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">top</span>: box.top + (win.pageYOffset || docElem.scrollTop) -
                    (docElem.clientTop || <span class="hljs-number">0</span>),
                <span class="hljs-attr">left</span>: box.left + (win.pageXOffset || docElem.scrollLeft) -
                    (docElem.clientLeft || <span class="hljs-number">0</span>)
            };
        };
        H.stop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, prop</span>) </span>{
            <span class="hljs-keyword">var</span> i = timers.length;
            <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (timers[i].elem === el &amp;&amp; (!prop || prop === timers[i].prop)) {
                    timers[i].stopped = <span class="hljs-literal">true</span>;
                }
            }
        };
        H.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, fn, ctx</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.forEach.call(arr, fn, ctx);
        };
        H.addEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type, fn</span>) </span>{
            <span class="hljs-keyword">var</span> events = el.hcEvents = el.hcEvents || {};

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedFn</span>(<span class="hljs-params">e</span>) </span>{
                e.target = e.srcElement || win;
                fn.call(el, e);
            }
            <span class="hljs-keyword">if</span> (el.addEventListener) {
                el.addEventListener(type, fn, <span class="hljs-literal">false</span>);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.attachEvent) {
                <span class="hljs-keyword">if</span> (!el.hcEventsIE) {
                    el.hcEventsIE = {};
                }
                el.hcEventsIE[fn.toString()] = wrappedFn;
                el.attachEvent(<span class="hljs-string">'on'</span> + type, wrappedFn);
            }
            <span class="hljs-keyword">if</span> (!events[type]) {
                events[type] = [];
            }
            events[type].push(fn);
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                H.removeEvent(el, type, fn);
            };
        };
        H.removeEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type, fn</span>) </span>{
            <span class="hljs-keyword">var</span> events,
                hcEvents = el.hcEvents,
                index;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeOneEvent</span>(<span class="hljs-params">type, fn</span>) </span>{
                <span class="hljs-keyword">if</span> (el.removeEventListener) {
                    el.removeEventListener(type, fn, <span class="hljs-literal">false</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.attachEvent) {
                    fn = el.hcEventsIE[fn.toString()];
                    el.detachEvent(<span class="hljs-string">'on'</span> + type, fn);
                }
            }

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeAllEvents</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> types,
                    len,
                    n;
                <span class="hljs-keyword">if</span> (!el.nodeName) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (type) {
                    types = {};
                    types[type] = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> {
                    types = hcEvents;
                }
                <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> types) {
                    <span class="hljs-keyword">if</span> (hcEvents[n]) {
                        len = hcEvents[n].length;
                        <span class="hljs-keyword">while</span> (len--) {
                            removeOneEvent(n, hcEvents[n][len]);
                        }
                    }
                }
            }
            <span class="hljs-keyword">if</span> (hcEvents) {
                <span class="hljs-keyword">if</span> (type) {
                    events = hcEvents[type] || [];
                    <span class="hljs-keyword">if</span> (fn) {
                        index = H.inArray(fn, events);
                        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">-1</span>) {
                            events.splice(index, <span class="hljs-number">1</span>);
                            hcEvents[type] = events;
                        }
                        removeOneEvent(type, fn);
                    } <span class="hljs-keyword">else</span> {
                        removeAllEvents();
                        hcEvents[type] = [];
                    }
                } <span class="hljs-keyword">else</span> {
                    removeAllEvents();
                    el.hcEvents = {};
                }
            }
        };
        H.fireEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, type, eventArguments, defaultFunction</span>) </span>{
            <span class="hljs-keyword">var</span> e,
                hcEvents = el.hcEvents,
                events,
                len,
                i,
                fn;
            eventArguments = eventArguments || {};
            <span class="hljs-keyword">if</span> (doc.createEvent &amp;&amp; (el.dispatchEvent || el.fireEvent)) {
                e = doc.createEvent(<span class="hljs-string">'Events'</span>);
                e.initEvent(type, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
                H.extend(e, eventArguments);
                <span class="hljs-keyword">if</span> (el.dispatchEvent) {
                    el.dispatchEvent(e);
                } <span class="hljs-keyword">else</span> {
                    el.fireEvent(type, e);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hcEvents) {
                events = hcEvents[type] || [];
                len = events.length;
                <span class="hljs-keyword">if</span> (!eventArguments.target) {
                    H.extend(eventArguments, {
                        <span class="hljs-attr">preventDefault</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            eventArguments.defaultPrevented = <span class="hljs-literal">true</span>;
                        },
                        <span class="hljs-attr">target</span>: el,
                        <span class="hljs-attr">type</span>: type
                    });
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    fn = events[i];
                    <span class="hljs-keyword">if</span> (fn &amp;&amp; fn.call(el, eventArguments) === <span class="hljs-literal">false</span>) {
                        eventArguments.preventDefault();
                    }
                }
            }
            <span class="hljs-keyword">if</span> (defaultFunction &amp;&amp; !eventArguments.defaultPrevented) {
                defaultFunction(eventArguments);
            }
        };
        H.animate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, params, opt</span>) </span>{
            <span class="hljs-keyword">var</span> start,
                unit = <span class="hljs-string">''</span>,
                end,
                fx,
                args,
                prop;
            <span class="hljs-keyword">if</span> (!H.isObject(opt)) {
                args = <span class="hljs-built_in">arguments</span>;
                opt = {
                    <span class="hljs-attr">duration</span>: args[<span class="hljs-number">2</span>],
                    <span class="hljs-attr">easing</span>: args[<span class="hljs-number">3</span>],
                    <span class="hljs-attr">complete</span>: args[<span class="hljs-number">4</span>]
                };
            }
            <span class="hljs-keyword">if</span> (!H.isNumber(opt.duration)) {
                opt.duration = <span class="hljs-number">400</span>;
            }
            opt.easing = <span class="hljs-keyword">typeof</span> opt.easing === <span class="hljs-string">'function'</span> ?
                opt.easing :
                (<span class="hljs-built_in">Math</span>[opt.easing] || <span class="hljs-built_in">Math</span>.easeInOutSine);
            opt.curAnim = H.merge(params);
            <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> params) {
                H.stop(el, prop);
                fx = <span class="hljs-keyword">new</span> H.Fx(el, opt, prop);
                end = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'d'</span>) {
                    fx.paths = fx.initPath(
                        el,
                        el.d,
                        params.d
                    );
                    fx.toD = params.d;
                    start = <span class="hljs-number">0</span>;
                    end = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.attr) {
                    start = el.attr(prop);
                } <span class="hljs-keyword">else</span> {
                    start = <span class="hljs-built_in">parseFloat</span>(H.getStyle(el, prop)) || <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">if</span> (prop !== <span class="hljs-string">'opacity'</span>) {
                        unit = <span class="hljs-string">'px'</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (!end) {
                    end = params[prop];
                }
                <span class="hljs-keyword">if</span> (end.match &amp;&amp; end.match(<span class="hljs-string">'px'</span>)) {
                    end = end.replace(<span class="hljs-regexp">/px/g</span>, <span class="hljs-string">''</span>);
                }
                fx.run(start, end, unit);
            }
        };
        H.seriesType = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">type, parent, options, props, pointProps</span>) </span>{
            <span class="hljs-keyword">var</span> defaultOptions = H.getOptions(),
                seriesTypes = H.seriesTypes;
            defaultOptions.plotOptions[type] = H.merge(
                defaultOptions.plotOptions[parent],
                options
            );
            seriesTypes[type] = H.extendClass(seriesTypes[parent] ||
                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}, props);
            seriesTypes[type].prototype.type = type;
            <span class="hljs-keyword">if</span> (pointProps) {
                seriesTypes[type].prototype.pointClass =
                    H.extendClass(H.Point, pointProps);
            }
            <span class="hljs-keyword">return</span> seriesTypes[type];
        };
        H.uniqueKey = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> uniqueKeyHash = <span class="hljs-built_in">Math</span>.random().toString(<span class="hljs-number">36</span>).substring(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>),
                idCounter = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-string">'highcharts-'</span> + uniqueKeyHash + <span class="hljs-string">'-'</span> + idCounter++;
            };
        }());
        <span class="hljs-keyword">if</span> (win.jQuery) {
            win.jQuery.fn.highcharts = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>]) {
                    <span class="hljs-keyword">if</span> (args[<span class="hljs-number">0</span>]) {
                        <span class="hljs-keyword">new</span> H[
                            H.isString(args[<span class="hljs-number">0</span>]) ? args.shift() : <span class="hljs-string">'Chart'</span>
                        ](<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>], args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                    }
                    <span class="hljs-keyword">return</span> charts[H.attr(<span class="hljs-keyword">this</span>[<span class="hljs-number">0</span>], <span class="hljs-string">'data-highcharts-chart'</span>)];
                }
            };
        }
        <span class="hljs-keyword">if</span> (doc &amp;&amp; !doc.defaultView) {
            H.getStyle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el, prop</span>) </span>{
                <span class="hljs-keyword">var</span> val,
                    alias = {
                        <span class="hljs-attr">width</span>: <span class="hljs-string">'clientWidth'</span>,
                        <span class="hljs-attr">height</span>: <span class="hljs-string">'clientHeight'</span>
                    }[prop];
                <span class="hljs-keyword">if</span> (el.style[prop]) {
                    <span class="hljs-keyword">return</span> H.pInt(el.style[prop]);
                }
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'opacity'</span>) {
                    prop = <span class="hljs-string">'filter'</span>;
                }
                <span class="hljs-keyword">if</span> (alias) {
                    el.style.zoom = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max(el[alias] - <span class="hljs-number">2</span> * H.getStyle(el, <span class="hljs-string">'padding'</span>), <span class="hljs-number">0</span>);
                }
                val = el.currentStyle[prop.replace(<span class="hljs-regexp">/\-(\w)/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                    <span class="hljs-keyword">return</span> b.toUpperCase();
                })];
                <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'filter'</span>) {
                    val = val.replace(
                        <span class="hljs-regexp">/alpha\(opacity=([0-9]+)\)/</span>,
                        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                            <span class="hljs-keyword">return</span> b / <span class="hljs-number">100</span>;
                        }
                    );
                }
                <span class="hljs-keyword">return</span> val === <span class="hljs-string">''</span> ? <span class="hljs-number">1</span> : H.pInt(val);
            };
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.forEach) {
            H.each = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, fn, ctx</span>) </span>{
                <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,
                    len = arr.length;
                <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                    <span class="hljs-keyword">if</span> (fn.call(ctx, arr[i], i, arr) === <span class="hljs-literal">false</span>) {
                        <span class="hljs-keyword">return</span> i;
                    }
                }
            };
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.indexOf) {
            H.inArray = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, arr</span>) </span>{
                <span class="hljs-keyword">var</span> len,
                    i = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (arr) {
                    len = arr.length;
                    <span class="hljs-keyword">for</span> (; i &lt; len; i++) {
                        <span class="hljs-keyword">if</span> (arr[i] === item) {
                            <span class="hljs-keyword">return</span> i;
                        }
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
            };
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.filter) {
            H.grep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elements, fn</span>) </span>{
                <span class="hljs-keyword">var</span> ret = [],
                    i = <span class="hljs-number">0</span>,
                    length = elements.length;
                <span class="hljs-keyword">for</span> (; i &lt; length; i++) {
                    <span class="hljs-keyword">if</span> (fn(elements[i], i)) {
                        ret.push(elements[i]);
                    }
                }
                <span class="hljs-keyword">return</span> ret;
            };
        }
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.prototype.find) {
            H.find = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, fn</span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    length = arr.length;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) {
                    <span class="hljs-keyword">if</span> (fn(arr[i], i)) {
                        <span class="hljs-keyword">return</span> arr[i];
                    }
                }
            };
        }
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> each = H.each,
            isNumber = H.isNumber,
            map = H.map,
            merge = H.merge,
            pInt = H.pInt;
        H.Color = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> H.Color)) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> H.Color(input);
            }
            <span class="hljs-keyword">this</span>.init(input);
        };
        H.Color.prototype = {
            <span class="hljs-attr">parsers</span>: [{
                <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/</span>,
                <span class="hljs-attr">parse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
                    <span class="hljs-keyword">return</span> [pInt(result[<span class="hljs-number">1</span>]), pInt(result[<span class="hljs-number">2</span>]), pInt(result[<span class="hljs-number">3</span>]), <span class="hljs-built_in">parseFloat</span>(result[<span class="hljs-number">4</span>], <span class="hljs-number">10</span>)];
                }
            }, {
                <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/</span>,
                <span class="hljs-attr">parse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
                    <span class="hljs-keyword">return</span> [pInt(result[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>), pInt(result[<span class="hljs-number">2</span>], <span class="hljs-number">16</span>), pInt(result[<span class="hljs-number">3</span>], <span class="hljs-number">16</span>), <span class="hljs-number">1</span>];
                }
            }, {
                <span class="hljs-attr">regex</span>: <span class="hljs-regexp">/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/</span>,
                <span class="hljs-attr">parse</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>{
                    <span class="hljs-keyword">return</span> [pInt(result[<span class="hljs-number">1</span>]), pInt(result[<span class="hljs-number">2</span>]), pInt(result[<span class="hljs-number">3</span>]), <span class="hljs-number">1</span>];
                }
            }],
            <span class="hljs-attr">names</span>: {
                <span class="hljs-attr">white</span>: <span class="hljs-string">'#ffffff'</span>,
                <span class="hljs-attr">black</span>: <span class="hljs-string">'#000000'</span>
            },
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
                <span class="hljs-keyword">var</span> result,
                    rgba,
                    i,
                    parser;
                <span class="hljs-keyword">this</span>.input = input = <span class="hljs-keyword">this</span>.names[input] || input;
                <span class="hljs-keyword">if</span> (input &amp;&amp; input.stops) {
                    <span class="hljs-keyword">this</span>.stops = map(input.stops, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stop</span>) </span>{
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> H.Color(stop[<span class="hljs-number">1</span>]);
                    });
                } <span class="hljs-keyword">else</span> {
                    i = <span class="hljs-keyword">this</span>.parsers.length;
                    <span class="hljs-keyword">while</span> (i-- &amp;&amp; !rgba) {
                        parser = <span class="hljs-keyword">this</span>.parsers[i];
                        result = parser.regex.exec(input);
                        <span class="hljs-keyword">if</span> (result) {
                            rgba = parser.parse(result);
                        }
                    }
                }
                <span class="hljs-keyword">this</span>.rgba = rgba || [];
            },
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">format</span>) </span>{
                <span class="hljs-keyword">var</span> input = <span class="hljs-keyword">this</span>.input,
                    rgba = <span class="hljs-keyword">this</span>.rgba,
                    ret;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stops) {
                    ret = merge(input);
                    ret.stops = [].concat(ret.stops);
                    each(<span class="hljs-keyword">this</span>.stops, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stop, i</span>) </span>{
                        ret.stops[i] = [ret.stops[i][<span class="hljs-number">0</span>], stop.get(format)];
                    });
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rgba &amp;&amp; isNumber(rgba[<span class="hljs-number">0</span>])) {
                    <span class="hljs-keyword">if</span> (format === <span class="hljs-string">'rgb'</span> || (!format &amp;&amp; rgba[<span class="hljs-number">3</span>] === <span class="hljs-number">1</span>)) {
                        ret = <span class="hljs-string">'rgb('</span> + rgba[<span class="hljs-number">0</span>] + <span class="hljs-string">','</span> + rgba[<span class="hljs-number">1</span>] + <span class="hljs-string">','</span> + rgba[<span class="hljs-number">2</span>] + <span class="hljs-string">')'</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (format === <span class="hljs-string">'a'</span>) {
                        ret = rgba[<span class="hljs-number">3</span>];
                    } <span class="hljs-keyword">else</span> {
                        ret = <span class="hljs-string">'rgba('</span> + rgba.join(<span class="hljs-string">','</span>) + <span class="hljs-string">')'</span>;
                    }
                } <span class="hljs-keyword">else</span> {
                    ret = input;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">brighten</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alpha</span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    rgba = <span class="hljs-keyword">this</span>.rgba;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stops) {
                    each(<span class="hljs-keyword">this</span>.stops, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stop</span>) </span>{
                        stop.brighten(alpha);
                    });
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNumber(alpha) &amp;&amp; alpha !== <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
                        rgba[i] += pInt(alpha * <span class="hljs-number">255</span>);
                        <span class="hljs-keyword">if</span> (rgba[i] &lt; <span class="hljs-number">0</span>) {
                            rgba[i] = <span class="hljs-number">0</span>;
                        }
                        <span class="hljs-keyword">if</span> (rgba[i] &gt; <span class="hljs-number">255</span>) {
                            rgba[i] = <span class="hljs-number">255</span>;
                        }
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">setOpacity</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alpha</span>) </span>{
                <span class="hljs-keyword">this</span>.rgba[<span class="hljs-number">3</span>] = alpha;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            }
        };
        H.color = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">input</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> H.Color(input);
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> SVGElement,
            SVGRenderer,
            addEvent = H.addEvent,
            animate = H.animate,
            attr = H.attr,
            charts = H.charts,
            color = H.color,
            css = H.css,
            createElement = H.createElement,
            defined = H.defined,
            deg2rad = H.deg2rad,
            destroyObjectProperties = H.destroyObjectProperties,
            doc = H.doc,
            each = H.each,
            extend = H.extend,
            erase = H.erase,
            grep = H.grep,
            hasTouch = H.hasTouch,
            inArray = H.inArray,
            isArray = H.isArray,
            isFirefox = H.isFirefox,
            isMS = H.isMS,
            isObject = H.isObject,
            isString = H.isString,
            isWebKit = H.isWebKit,
            merge = H.merge,
            noop = H.noop,
            pick = H.pick,
            pInt = H.pInt,
            removeEvent = H.removeEvent,
            splat = H.splat,
            stop = H.stop,
            svg = H.svg,
            SVG_NS = H.SVG_NS,
            symbolSizes = H.symbolSizes,
            win = H.win;
        SVGElement = H.SVGElement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        };
        SVGElement.prototype = {
            <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">SVG_NS</span>: SVG_NS,
            <span class="hljs-attr">textProps</span>: [<span class="hljs-string">'direction'</span>, <span class="hljs-string">'fontSize'</span>, <span class="hljs-string">'fontWeight'</span>, <span class="hljs-string">'fontFamily'</span>,
                <span class="hljs-string">'fontStyle'</span>, <span class="hljs-string">'color'</span>, <span class="hljs-string">'lineHeight'</span>, <span class="hljs-string">'width'</span>, <span class="hljs-string">'textDecoration'</span>,
                <span class="hljs-string">'textOverflow'</span>, <span class="hljs-string">'textOutline'</span>
            ],
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">renderer, nodeName</span>) </span>{
                <span class="hljs-keyword">this</span>.element = nodeName === <span class="hljs-string">'span'</span> ?
                    createElement(nodeName) :
                    doc.createElementNS(<span class="hljs-keyword">this</span>.SVG_NS, nodeName);
                <span class="hljs-keyword">this</span>.renderer = renderer;
            },
            <span class="hljs-attr">animate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params, options, complete</span>) </span>{
                <span class="hljs-keyword">var</span> animOptions = H.animObject(
                    pick(options, <span class="hljs-keyword">this</span>.renderer.globalAnimation, <span class="hljs-literal">true</span>)
                );
                <span class="hljs-keyword">if</span> (animOptions.duration !== <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (complete) {
                        animOptions.complete = complete;
                    }
                    animate(<span class="hljs-keyword">this</span>, params, animOptions);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.attr(params, <span class="hljs-literal">null</span>, complete);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">colorGradient</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">color, prop, elem</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>.renderer,
                    colorObject,
                    gradName,
                    gradAttr,
                    radAttr,
                    gradients,
                    gradientObject,
                    stops,
                    stopColor,
                    stopOpacity,
                    radialReference,
                    n,
                    id,
                    key = [],
                    value;
                <span class="hljs-keyword">if</span> (color.linearGradient) {
                    gradName = <span class="hljs-string">'linearGradient'</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color.radialGradient) {
                    gradName = <span class="hljs-string">'radialGradient'</span>;
                }
                <span class="hljs-keyword">if</span> (gradName) {
                    gradAttr = color[gradName];
                    gradients = renderer.gradients;
                    stops = color.stops;
                    radialReference = elem.radialReference;
                    <span class="hljs-keyword">if</span> (isArray(gradAttr)) {
                        color[gradName] = gradAttr = {
                            <span class="hljs-attr">x1</span>: gradAttr[<span class="hljs-number">0</span>],
                            <span class="hljs-attr">y1</span>: gradAttr[<span class="hljs-number">1</span>],
                            <span class="hljs-attr">x2</span>: gradAttr[<span class="hljs-number">2</span>],
                            <span class="hljs-attr">y2</span>: gradAttr[<span class="hljs-number">3</span>],
                            <span class="hljs-attr">gradientUnits</span>: <span class="hljs-string">'userSpaceOnUse'</span>
                        };
                    }
                    <span class="hljs-keyword">if</span> (gradName === <span class="hljs-string">'radialGradient'</span> &amp;&amp; radialReference &amp;&amp; !defined(gradAttr.gradientUnits)) {
                        radAttr = gradAttr;
                        gradAttr = merge(gradAttr,
                            renderer.getRadialAttr(radialReference, radAttr), {
                                <span class="hljs-attr">gradientUnits</span>: <span class="hljs-string">'userSpaceOnUse'</span>
                            }
                        );
                    }
                    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> gradAttr) {
                        <span class="hljs-keyword">if</span> (n !== <span class="hljs-string">'id'</span>) {
                            key.push(n, gradAttr[n]);
                        }
                    }
                    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> stops) {
                        key.push(stops[n]);
                    }
                    key = key.join(<span class="hljs-string">','</span>);
                    <span class="hljs-keyword">if</span> (gradients[key]) {
                        id = gradients[key].attr(<span class="hljs-string">'id'</span>);
                    } <span class="hljs-keyword">else</span> {
                        gradAttr.id = id = H.uniqueKey();
                        gradients[key] = gradientObject = renderer.createElement(gradName)
                            .attr(gradAttr)
                            .add(renderer.defs);
                        gradientObject.radAttr = radAttr;
                        gradientObject.stops = [];
                        each(stops, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stop</span>) </span>{
                            <span class="hljs-keyword">var</span> stopObject;
                            <span class="hljs-keyword">if</span> (stop[<span class="hljs-number">1</span>].indexOf(<span class="hljs-string">'rgba'</span>) === <span class="hljs-number">0</span>) {
                                colorObject = H.color(stop[<span class="hljs-number">1</span>]);
                                stopColor = colorObject.get(<span class="hljs-string">'rgb'</span>);
                                stopOpacity = colorObject.get(<span class="hljs-string">'a'</span>);
                            } <span class="hljs-keyword">else</span> {
                                stopColor = stop[<span class="hljs-number">1</span>];
                                stopOpacity = <span class="hljs-number">1</span>;
                            }
                            stopObject = renderer.createElement(<span class="hljs-string">'stop'</span>).attr({
                                <span class="hljs-attr">offset</span>: stop[<span class="hljs-number">0</span>],
                                <span class="hljs-string">'stop-color'</span>: stopColor,
                                <span class="hljs-string">'stop-opacity'</span>: stopOpacity
                            }).add(gradientObject);
                            gradientObject.stops.push(stopObject);
                        });
                    }
                    value = <span class="hljs-string">'url('</span> + renderer.url + <span class="hljs-string">'#'</span> + id + <span class="hljs-string">')'</span>;
                    elem.setAttribute(prop, value);
                    elem.gradient = key;
                    color.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">return</span> value;
                    };
                }
            },
            <span class="hljs-attr">applyTextOutline</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">textOutline</span>) </span>{
                <span class="hljs-keyword">var</span> elem = <span class="hljs-keyword">this</span>.element,
                    tspans,
                    hasContrast = textOutline.indexOf(<span class="hljs-string">'contrast'</span>) !== <span class="hljs-number">-1</span>,
                    styles = {},
                    color,
                    strokeWidth,
                    firstRealChild;
                <span class="hljs-keyword">if</span> (hasContrast) {
                    styles.textOutline = textOutline = textOutline.replace(
                        <span class="hljs-regexp">/contrast/g</span>,
                        <span class="hljs-keyword">this</span>.renderer.getContrast(elem.style.fill)
                    );
                }
                <span class="hljs-keyword">this</span>.fakeTS = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.ySetter = <span class="hljs-keyword">this</span>.xSetter;
                tspans = [].slice.call(elem.getElementsByTagName(<span class="hljs-string">'tspan'</span>));
                textOutline = textOutline.split(<span class="hljs-string">' '</span>);
                color = textOutline[textOutline.length - <span class="hljs-number">1</span>];
                strokeWidth = textOutline[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">if</span> (strokeWidth &amp;&amp; strokeWidth !== <span class="hljs-string">'none'</span>) {
                    strokeWidth = strokeWidth.replace(
                        <span class="hljs-regexp">/(^[\d\.]+)(.*?)$/g</span>,
                        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, digit, unit</span>) </span>{
                            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * digit) + unit;
                        }
                    );
                    each(tspans, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tspan</span>) </span>{
                        <span class="hljs-keyword">if</span> (tspan.getAttribute(<span class="hljs-string">'class'</span>) === <span class="hljs-string">'highcharts-text-outline'</span>) {
                            erase(tspans, elem.removeChild(tspan));
                        }
                    });
                    firstRealChild = elem.firstChild;
                    each(tspans, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tspan, y</span>) </span>{
                        <span class="hljs-keyword">var</span> clone;
                        <span class="hljs-keyword">if</span> (y === <span class="hljs-number">0</span>) {
                            tspan.setAttribute(<span class="hljs-string">'x'</span>, elem.getAttribute(<span class="hljs-string">'x'</span>));
                            y = elem.getAttribute(<span class="hljs-string">'y'</span>);
                            tspan.setAttribute(<span class="hljs-string">'y'</span>, y || <span class="hljs-number">0</span>);
                            <span class="hljs-keyword">if</span> (y === <span class="hljs-literal">null</span>) {
                                elem.setAttribute(<span class="hljs-string">'y'</span>, <span class="hljs-number">0</span>);
                            }
                        }
                        clone = tspan.cloneNode(<span class="hljs-number">1</span>);
                        attr(clone, {
                            <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-text-outline'</span>,
                            <span class="hljs-string">'fill'</span>: color,
                            <span class="hljs-string">'stroke'</span>: color,
                            <span class="hljs-string">'stroke-width'</span>: strokeWidth,
                            <span class="hljs-string">'stroke-linejoin'</span>: <span class="hljs-string">'round'</span>
                        });
                        elem.insertBefore(clone, firstRealChild);
                    });
                }
            },
            <span class="hljs-attr">attr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hash, val, complete, continueAnimation</span>) </span>{
                <span class="hljs-keyword">var</span> key,
                    value,
                    element = <span class="hljs-keyword">this</span>.element,
                    hasSetSymbolSize,
                    ret = <span class="hljs-keyword">this</span>,
                    skipAttr,
                    setter;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> hash === <span class="hljs-string">'string'</span> &amp;&amp; val !== <span class="hljs-literal">undefined</span>) {
                    key = hash;
                    hash = {};
                    hash[key] = val;
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> hash === <span class="hljs-string">'string'</span>) {
                    ret = (<span class="hljs-keyword">this</span>[hash + <span class="hljs-string">'Getter'</span>] || <span class="hljs-keyword">this</span>._defaultGetter).call(<span class="hljs-keyword">this</span>, hash, element);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> hash) {
                        value = hash[key];
                        skipAttr = <span class="hljs-literal">false</span>;
                        <span class="hljs-keyword">if</span> (!continueAnimation) {
                            stop(<span class="hljs-keyword">this</span>, key);
                        }
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.symbolName &amp;&amp; <span class="hljs-regexp">/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/</span>.test(key)) {
                            <span class="hljs-keyword">if</span> (!hasSetSymbolSize) {
                                <span class="hljs-keyword">this</span>.symbolAttr(hash);
                                hasSetSymbolSize = <span class="hljs-literal">true</span>;
                            }
                            skipAttr = <span class="hljs-literal">true</span>;
                        }
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rotation &amp;&amp; (key === <span class="hljs-string">'x'</span> || key === <span class="hljs-string">'y'</span>)) {
                            <span class="hljs-keyword">this</span>.doTransform = <span class="hljs-literal">true</span>;
                        }
                        <span class="hljs-keyword">if</span> (!skipAttr) {
                            setter = <span class="hljs-keyword">this</span>[key + <span class="hljs-string">'Setter'</span>] || <span class="hljs-keyword">this</span>._defaultSetter;
                            setter.call(<span class="hljs-keyword">this</span>, value, key, element);
                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shadows &amp;&amp; <span class="hljs-regexp">/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/</span>.test(key)) {
                                <span class="hljs-keyword">this</span>.updateShadows(key, value, setter);
                            }
                        }
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.doTransform) {
                        <span class="hljs-keyword">this</span>.updateTransform();
                        <span class="hljs-keyword">this</span>.doTransform = <span class="hljs-literal">false</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (complete) {
                    complete();
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">updateShadows</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value, setter</span>) </span>{
                <span class="hljs-keyword">var</span> shadows = <span class="hljs-keyword">this</span>.shadows,
                    i = shadows.length;
                <span class="hljs-keyword">while</span> (i--) {
                    setter.call(
                        shadows[i],
                        key === <span class="hljs-string">'height'</span> ?
                        <span class="hljs-built_in">Math</span>.max(value - (shadows[i].cutHeight || <span class="hljs-number">0</span>), <span class="hljs-number">0</span>) :
                        key === <span class="hljs-string">'d'</span> ? <span class="hljs-keyword">this</span>.d : value,
                        key,
                        shadows[i]
                    );
                }
            },
            <span class="hljs-attr">addClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className, replace</span>) </span>{
                <span class="hljs-keyword">var</span> currentClassName = <span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'class'</span>) || <span class="hljs-string">''</span>;
                <span class="hljs-keyword">if</span> (currentClassName.indexOf(className) === <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">if</span> (!replace) {
                        className =
                            (currentClassName + (currentClassName ? <span class="hljs-string">' '</span> : <span class="hljs-string">''</span>) +
                                className).replace(<span class="hljs-string">'  '</span>, <span class="hljs-string">' '</span>);
                    }
                    <span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'class'</span>, className);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">hasClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                <span class="hljs-keyword">return</span> attr(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">'class'</span>).indexOf(className) !== <span class="hljs-number">-1</span>;
            },
            <span class="hljs-attr">removeClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                attr(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">'class'</span>, (attr(<span class="hljs-keyword">this</span>.element, <span class="hljs-string">'class'</span>) || <span class="hljs-string">''</span>).replace(className, <span class="hljs-string">''</span>));
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">symbolAttr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hash</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>;
                each([<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'start'</span>, <span class="hljs-string">'end'</span>, <span class="hljs-string">'width'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'innerR'</span>, <span class="hljs-string">'anchorX'</span>, <span class="hljs-string">'anchorY'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    wrapper[key] = pick(hash[key], wrapper[key]);
                });
                wrapper.attr({
                    <span class="hljs-attr">d</span>: wrapper.renderer.symbols[wrapper.symbolName](
                        wrapper.x,
                        wrapper.y,
                        wrapper.width,
                        wrapper.height,
                        wrapper
                    )
                });
            },
            <span class="hljs-attr">clip</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">clipRect</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attr(
                    <span class="hljs-string">'clip-path'</span>,
                    clipRect ?
                    <span class="hljs-string">'url('</span> + <span class="hljs-keyword">this</span>.renderer.url + <span class="hljs-string">'#'</span> + clipRect.id + <span class="hljs-string">')'</span> :
                    <span class="hljs-string">'none'</span>
                );
            },
            <span class="hljs-attr">crisp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rect, strokeWidth</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    key,
                    attribs = {},
                    normalizer;
                strokeWidth = strokeWidth || rect.strokeWidth || <span class="hljs-number">0</span>;
                normalizer = <span class="hljs-built_in">Math</span>.round(strokeWidth) % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>;
                rect.x = <span class="hljs-built_in">Math</span>.floor(rect.x || wrapper.x || <span class="hljs-number">0</span>) + normalizer;
                rect.y = <span class="hljs-built_in">Math</span>.floor(rect.y || wrapper.y || <span class="hljs-number">0</span>) + normalizer;
                rect.width = <span class="hljs-built_in">Math</span>.floor((rect.width || wrapper.width || <span class="hljs-number">0</span>) - <span class="hljs-number">2</span> * normalizer);
                rect.height = <span class="hljs-built_in">Math</span>.floor((rect.height || wrapper.height || <span class="hljs-number">0</span>) - <span class="hljs-number">2</span> * normalizer);
                <span class="hljs-keyword">if</span> (defined(rect.strokeWidth)) {
                    rect.strokeWidth = strokeWidth;
                }
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> rect) {
                    <span class="hljs-keyword">if</span> (wrapper[key] !== rect[key]) {
                        wrapper[key] = attribs[key] = rect[key];
                    }
                }
                <span class="hljs-keyword">return</span> attribs;
            },
            <span class="hljs-attr">css</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">styles</span>) </span>{
                <span class="hljs-keyword">var</span> elemWrapper = <span class="hljs-keyword">this</span>,
                    oldStyles = elemWrapper.styles,
                    newStyles = {},
                    elem = elemWrapper.element,
                    textWidth,
                    n,
                    serializedCss = <span class="hljs-string">''</span>,
                    hyphenate,
                    hasNew = !oldStyles,
                    svgPseudoProps = [<span class="hljs-string">'textOverflow'</span>, <span class="hljs-string">'width'</span>];
                <span class="hljs-keyword">if</span> (styles &amp;&amp; styles.color) {
                    styles.fill = styles.color;
                }
                <span class="hljs-keyword">if</span> (oldStyles) {
                    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> styles) {
                        <span class="hljs-keyword">if</span> (styles[n] !== oldStyles[n]) {
                            newStyles[n] = styles[n];
                            hasNew = <span class="hljs-literal">true</span>;
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (hasNew) {
                    textWidth = elemWrapper.textWidth =
                        (styles &amp;&amp; styles.width &amp;&amp; elem.nodeName.toLowerCase() === <span class="hljs-string">'text'</span> &amp;&amp; pInt(styles.width)) ||
                        elemWrapper.textWidth;
                    <span class="hljs-keyword">if</span> (oldStyles) {
                        styles = extend(
                            oldStyles,
                            newStyles
                        );
                    }
                    elemWrapper.styles = styles;
                    <span class="hljs-keyword">if</span> (textWidth &amp;&amp; (!svg &amp;&amp; elemWrapper.renderer.forExport)) {
                        <span class="hljs-keyword">delete</span> styles.width;
                    }
                    <span class="hljs-keyword">if</span> (isMS &amp;&amp; !svg) {
                        css(elemWrapper.element, styles);
                    } <span class="hljs-keyword">else</span> {
                        hyphenate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                            <span class="hljs-keyword">return</span> <span class="hljs-string">'-'</span> + b.toLowerCase();
                        };
                        <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> styles) {
                            <span class="hljs-keyword">if</span> (inArray(n, svgPseudoProps) === <span class="hljs-number">-1</span>) {
                                serializedCss +=
                                    n.replace(<span class="hljs-regexp">/([A-Z])/g</span>, hyphenate) + <span class="hljs-string">':'</span> +
                                    styles[n] + <span class="hljs-string">';'</span>;
                            }
                        }
                        <span class="hljs-keyword">if</span> (serializedCss) {
                            attr(elem, <span class="hljs-string">'style'</span>, serializedCss);
                        }
                    }
                    <span class="hljs-keyword">if</span> (elemWrapper.added) {
                        <span class="hljs-keyword">if</span> (textWidth) {
                            elemWrapper.renderer.buildText(elemWrapper);
                        }
                        <span class="hljs-keyword">if</span> (styles &amp;&amp; styles.textOutline) {
                            elemWrapper.applyTextOutline(styles.textOutline);
                        }
                    }
                }
                <span class="hljs-keyword">return</span> elemWrapper;
            },
            <span class="hljs-attr">strokeWidth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[<span class="hljs-string">'stroke-width'</span>] || <span class="hljs-number">0</span>;
            },
            <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, handler</span>) </span>{
                <span class="hljs-keyword">var</span> svgElement = <span class="hljs-keyword">this</span>,
                    element = svgElement.element;
                <span class="hljs-keyword">if</span> (hasTouch &amp;&amp; eventType === <span class="hljs-string">'click'</span>) {
                    element.ontouchstart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        svgElement.touchEventFired = <span class="hljs-built_in">Date</span>.now();
                        e.preventDefault();
                        handler.call(element, e);
                    };
                    element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">if</span> (win.navigator.userAgent.indexOf(<span class="hljs-string">'Android'</span>) === <span class="hljs-number">-1</span> ||
                            <span class="hljs-built_in">Date</span>.now() - (svgElement.touchEventFired || <span class="hljs-number">0</span>) &gt; <span class="hljs-number">1100</span>) {
                            handler.call(element, e);
                        }
                    };
                } <span class="hljs-keyword">else</span> {
                    element[<span class="hljs-string">'on'</span> + eventType] = handler;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">setRadialReference</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coordinates</span>) </span>{
                <span class="hljs-keyword">var</span> existingGradient = <span class="hljs-keyword">this</span>.renderer.gradients[<span class="hljs-keyword">this</span>.element.gradient];
                <span class="hljs-keyword">this</span>.element.radialReference = coordinates;
                <span class="hljs-keyword">if</span> (existingGradient &amp;&amp; existingGradient.radAttr) {
                    existingGradient.animate(
                        <span class="hljs-keyword">this</span>.renderer.getRadialAttr(
                            coordinates,
                            existingGradient.radAttr
                        )
                    );
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attr({
                    <span class="hljs-attr">translateX</span>: x,
                    <span class="hljs-attr">translateY</span>: y
                });
            },
            <span class="hljs-attr">invert</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inverted</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>;
                wrapper.inverted = inverted;
                wrapper.updateTransform();
                <span class="hljs-keyword">return</span> wrapper;
            },
            <span class="hljs-attr">updateTransform</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    translateX = wrapper.translateX || <span class="hljs-number">0</span>,
                    translateY = wrapper.translateY || <span class="hljs-number">0</span>,
                    scaleX = wrapper.scaleX,
                    scaleY = wrapper.scaleY,
                    inverted = wrapper.inverted,
                    rotation = wrapper.rotation,
                    element = wrapper.element,
                    transform;
                <span class="hljs-keyword">if</span> (inverted) {
                    translateX += wrapper.width;
                    translateY += wrapper.height;
                }
                transform = [<span class="hljs-string">'translate('</span> + translateX + <span class="hljs-string">','</span> + translateY + <span class="hljs-string">')'</span>];
                <span class="hljs-keyword">if</span> (inverted) {
                    transform.push(<span class="hljs-string">'rotate(90) scale(-1,1)'</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotation) {
                    transform.push(<span class="hljs-string">'rotate('</span> + rotation + <span class="hljs-string">' '</span> + (element.getAttribute(<span class="hljs-string">'x'</span>) || <span class="hljs-number">0</span>) + <span class="hljs-string">' '</span> + (element.getAttribute(<span class="hljs-string">'y'</span>) || <span class="hljs-number">0</span>) + <span class="hljs-string">')'</span>);
                }
                <span class="hljs-keyword">if</span> (defined(scaleX) || defined(scaleY)) {
                    transform.push(<span class="hljs-string">'scale('</span> + pick(scaleX, <span class="hljs-number">1</span>) + <span class="hljs-string">' '</span> + pick(scaleY, <span class="hljs-number">1</span>) + <span class="hljs-string">')'</span>);
                }
                <span class="hljs-keyword">if</span> (transform.length) {
                    element.setAttribute(<span class="hljs-string">'transform'</span>, transform.join(<span class="hljs-string">' '</span>));
                }
            },
            <span class="hljs-attr">toFront</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> element = <span class="hljs-keyword">this</span>.element;
                element.parentNode.appendChild(element);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">align</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alignOptions, alignByTranslate, box</span>) </span>{
                <span class="hljs-keyword">var</span> align,
                    vAlign,
                    x,
                    y,
                    attribs = {},
                    alignTo,
                    renderer = <span class="hljs-keyword">this</span>.renderer,
                    alignedObjects = renderer.alignedObjects,
                    alignFactor,
                    vAlignFactor;
                <span class="hljs-keyword">if</span> (alignOptions) {
                    <span class="hljs-keyword">this</span>.alignOptions = alignOptions;
                    <span class="hljs-keyword">this</span>.alignByTranslate = alignByTranslate;
                    <span class="hljs-keyword">if</span> (!box || isString(box)) {
                        <span class="hljs-keyword">this</span>.alignTo = alignTo = box || <span class="hljs-string">'renderer'</span>;
                        erase(alignedObjects, <span class="hljs-keyword">this</span>);
                        alignedObjects.push(<span class="hljs-keyword">this</span>);
                        box = <span class="hljs-literal">null</span>;
                    }
                } <span class="hljs-keyword">else</span> {
                    alignOptions = <span class="hljs-keyword">this</span>.alignOptions;
                    alignByTranslate = <span class="hljs-keyword">this</span>.alignByTranslate;
                    alignTo = <span class="hljs-keyword">this</span>.alignTo;
                }
                box = pick(box, renderer[alignTo], renderer);
                align = alignOptions.align;
                vAlign = alignOptions.verticalAlign;
                x = (box.x || <span class="hljs-number">0</span>) + (alignOptions.x || <span class="hljs-number">0</span>);
                y = (box.y || <span class="hljs-number">0</span>) + (alignOptions.y || <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'right'</span>) {
                    alignFactor = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'center'</span>) {
                    alignFactor = <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (alignFactor) {
                    x += (box.width - (alignOptions.width || <span class="hljs-number">0</span>)) / alignFactor;
                }
                attribs[alignByTranslate ? <span class="hljs-string">'translateX'</span> : <span class="hljs-string">'x'</span>] = <span class="hljs-built_in">Math</span>.round(x);
                <span class="hljs-keyword">if</span> (vAlign === <span class="hljs-string">'bottom'</span>) {
                    vAlignFactor = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vAlign === <span class="hljs-string">'middle'</span>) {
                    vAlignFactor = <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (vAlignFactor) {
                    y += (box.height - (alignOptions.height || <span class="hljs-number">0</span>)) / vAlignFactor;
                }
                attribs[alignByTranslate ? <span class="hljs-string">'translateY'</span> : <span class="hljs-string">'y'</span>] = <span class="hljs-built_in">Math</span>.round(y);
                <span class="hljs-keyword">this</span>[<span class="hljs-keyword">this</span>.placed ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>](attribs);
                <span class="hljs-keyword">this</span>.placed = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.alignAttr = attribs;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">getBBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reload, rot</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    bBox,
                    renderer = wrapper.renderer,
                    width,
                    height,
                    rotation,
                    rad,
                    element = wrapper.element,
                    styles = wrapper.styles,
                    fontSize,
                    textStr = wrapper.textStr,
                    toggleTextShadowShim,
                    cache = renderer.cache,
                    cacheKeys = renderer.cacheKeys,
                    cacheKey;
                rotation = pick(rot, wrapper.rotation);
                rad = rotation * deg2rad;
                fontSize = styles &amp;&amp; styles.fontSize;
                <span class="hljs-keyword">if</span> (textStr !== <span class="hljs-literal">undefined</span>) {
                    cacheKey = textStr.toString();
                    <span class="hljs-keyword">if</span> (cacheKey.indexOf(<span class="hljs-string">'&lt;'</span>) === <span class="hljs-number">-1</span>) {
                        cacheKey = cacheKey.replace(<span class="hljs-regexp">/[0-9]/g</span>, <span class="hljs-string">'0'</span>);
                    }
                    cacheKey += [
                            <span class="hljs-string">''</span>,
                            rotation || <span class="hljs-number">0</span>,
                            fontSize,
                            styles &amp;&amp; styles.width,
                            styles &amp;&amp; styles.textOverflow
                        ]
                        .join(<span class="hljs-string">','</span>);
                }
                <span class="hljs-keyword">if</span> (cacheKey &amp;&amp; !reload) {
                    bBox = cache[cacheKey];
                }
                <span class="hljs-keyword">if</span> (!bBox) {
                    <span class="hljs-keyword">if</span> (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {
                        <span class="hljs-keyword">try</span> {
                            toggleTextShadowShim = <span class="hljs-keyword">this</span>.fakeTS &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">display</span>) </span>{
                                each(element.querySelectorAll(<span class="hljs-string">'.highcharts-text-outline'</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tspan</span>) </span>{
                                    tspan.style.display = display;
                                });
                            };
                            <span class="hljs-keyword">if</span> (toggleTextShadowShim) {
                                toggleTextShadowShim(<span class="hljs-string">'none'</span>);
                            }
                            bBox = element.getBBox ?
                                extend({}, element.getBBox()) : {
                                    <span class="hljs-attr">width</span>: element.offsetWidth,
                                    <span class="hljs-attr">height</span>: element.offsetHeight
                                };
                            <span class="hljs-keyword">if</span> (toggleTextShadowShim) {
                                toggleTextShadowShim(<span class="hljs-string">''</span>);
                            }
                        } <span class="hljs-keyword">catch</span> (e) {}
                        <span class="hljs-keyword">if</span> (!bBox || bBox.width &lt; <span class="hljs-number">0</span>) {
                            bBox = {
                                <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>,
                                <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>
                            };
                        }
                    } <span class="hljs-keyword">else</span> {
                        bBox = wrapper.htmlGetBBox();
                    }
                    <span class="hljs-keyword">if</span> (renderer.isSVG) {
                        width = bBox.width;
                        height = bBox.height;
                        <span class="hljs-keyword">if</span> (
                            styles &amp;&amp;
                            styles.fontSize === <span class="hljs-string">'11px'</span> &amp;&amp;
                            <span class="hljs-built_in">Math</span>.round(height) === <span class="hljs-number">17</span>
                        ) {
                            bBox.height = height = <span class="hljs-number">14</span>;
                        }
                        <span class="hljs-keyword">if</span> (rotation) {
                            bBox.width = <span class="hljs-built_in">Math</span>.abs(height * <span class="hljs-built_in">Math</span>.sin(rad)) + <span class="hljs-built_in">Math</span>.abs(width * <span class="hljs-built_in">Math</span>.cos(rad));
                            bBox.height = <span class="hljs-built_in">Math</span>.abs(height * <span class="hljs-built_in">Math</span>.cos(rad)) + <span class="hljs-built_in">Math</span>.abs(width * <span class="hljs-built_in">Math</span>.sin(rad));
                        }
                    }
                    <span class="hljs-keyword">if</span> (cacheKey &amp;&amp; bBox.height &gt; <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">while</span> (cacheKeys.length &gt; <span class="hljs-number">250</span>) {
                            <span class="hljs-keyword">delete</span> cache[cacheKeys.shift()];
                        }
                        <span class="hljs-keyword">if</span> (!cache[cacheKey]) {
                            cacheKeys.push(cacheKey);
                        }
                        cache[cacheKey] = bBox;
                    }
                }
                <span class="hljs-keyword">return</span> bBox;
            },
            <span class="hljs-attr">show</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inherit</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attr({
                    <span class="hljs-attr">visibility</span>: inherit ? <span class="hljs-string">'inherit'</span> : <span class="hljs-string">'visible'</span>
                });
            },
            <span class="hljs-attr">hide</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attr({
                    <span class="hljs-attr">visibility</span>: <span class="hljs-string">'hidden'</span>
                });
            },
            <span class="hljs-attr">fadeOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">duration</span>) </span>{
                <span class="hljs-keyword">var</span> elemWrapper = <span class="hljs-keyword">this</span>;
                elemWrapper.animate({
                    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>
                }, {
                    <span class="hljs-attr">duration</span>: duration || <span class="hljs-number">150</span>,
                    <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        elemWrapper.attr({
                            <span class="hljs-attr">y</span>: <span class="hljs-number">-9999</span>
                        });
                    }
                });
            },
            <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">parent</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>.renderer,
                    element = <span class="hljs-keyword">this</span>.element,
                    inserted;
                <span class="hljs-keyword">if</span> (parent) {
                    <span class="hljs-keyword">this</span>.parentGroup = parent;
                }
                <span class="hljs-keyword">this</span>.parentInverted = parent &amp;&amp; parent.inverted;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.textStr !== <span class="hljs-literal">undefined</span>) {
                    renderer.buildText(<span class="hljs-keyword">this</span>);
                }
                <span class="hljs-keyword">this</span>.added = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (!parent || parent.handleZ || <span class="hljs-keyword">this</span>.zIndex) {
                    inserted = <span class="hljs-keyword">this</span>.zIndexSetter();
                }
                <span class="hljs-keyword">if</span> (!inserted) {
                    (parent ? parent.element : renderer.box).appendChild(element);
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.onAdd) {
                    <span class="hljs-keyword">this</span>.onAdd();
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">safeRemoveChild</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
                <span class="hljs-keyword">var</span> parentNode = element.parentNode;
                <span class="hljs-keyword">if</span> (parentNode) {
                    parentNode.removeChild(element);
                }
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    element = wrapper.element || {},
                    parentToClean = wrapper.renderer.isSVG &amp;&amp; element.nodeName === <span class="hljs-string">'SPAN'</span> &amp;&amp; wrapper.parentGroup,
                    grandParent,
                    key,
                    i;
                element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = <span class="hljs-literal">null</span>;
                stop(wrapper);
                <span class="hljs-keyword">if</span> (wrapper.clipPath) {
                    wrapper.clipPath = wrapper.clipPath.destroy();
                }
                <span class="hljs-keyword">if</span> (wrapper.stops) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; wrapper.stops.length; i++) {
                        wrapper.stops[i] = wrapper.stops[i].destroy();
                    }
                    wrapper.stops = <span class="hljs-literal">null</span>;
                }
                wrapper.safeRemoveChild(element);
                wrapper.destroyShadows();
                <span class="hljs-keyword">while</span> (parentToClean &amp;&amp; parentToClean.div &amp;&amp; parentToClean.div.childNodes.length === <span class="hljs-number">0</span>) {
                    grandParent = parentToClean.parentGroup;
                    wrapper.safeRemoveChild(parentToClean.div);
                    <span class="hljs-keyword">delete</span> parentToClean.div;
                    parentToClean = grandParent;
                }
                <span class="hljs-keyword">if</span> (wrapper.alignTo) {
                    erase(wrapper.renderer.alignedObjects, wrapper);
                }
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> wrapper) {
                    <span class="hljs-keyword">delete</span> wrapper[key];
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">shadow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shadowOptions, group, cutOff</span>) </span>{
                <span class="hljs-keyword">var</span> shadows = [],
                    i,
                    shadow,
                    element = <span class="hljs-keyword">this</span>.element,
                    strokeWidth,
                    shadowWidth,
                    shadowElementOpacity,
                    transform;
                <span class="hljs-keyword">if</span> (!shadowOptions) {
                    <span class="hljs-keyword">this</span>.destroyShadows();
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.shadows) {
                    shadowWidth = pick(shadowOptions.width, <span class="hljs-number">3</span>);
                    shadowElementOpacity = (shadowOptions.opacity || <span class="hljs-number">0.15</span>) / shadowWidth;
                    transform = <span class="hljs-keyword">this</span>.parentInverted ?
                        <span class="hljs-string">'(-1,-1)'</span> :
                        <span class="hljs-string">'('</span> + pick(shadowOptions.offsetX, <span class="hljs-number">1</span>) + <span class="hljs-string">', '</span> + pick(shadowOptions.offsetY, <span class="hljs-number">1</span>) + <span class="hljs-string">')'</span>;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= shadowWidth; i++) {
                        shadow = element.cloneNode(<span class="hljs-number">0</span>);
                        strokeWidth = (shadowWidth * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span> - (<span class="hljs-number">2</span> * i);
                        attr(shadow, {
                            <span class="hljs-string">'isShadow'</span>: <span class="hljs-string">'true'</span>,
                            <span class="hljs-string">'stroke'</span>: shadowOptions.color || <span class="hljs-string">'#000000'</span>,
                            <span class="hljs-string">'stroke-opacity'</span>: shadowElementOpacity * i,
                            <span class="hljs-string">'stroke-width'</span>: strokeWidth,
                            <span class="hljs-string">'transform'</span>: <span class="hljs-string">'translate'</span> + transform,
                            <span class="hljs-string">'fill'</span>: <span class="hljs-string">'none'</span>
                        });
                        <span class="hljs-keyword">if</span> (cutOff) {
                            attr(shadow, <span class="hljs-string">'height'</span>, <span class="hljs-built_in">Math</span>.max(attr(shadow, <span class="hljs-string">'height'</span>) - strokeWidth, <span class="hljs-number">0</span>));
                            shadow.cutHeight = strokeWidth;
                        }
                        <span class="hljs-keyword">if</span> (group) {
                            group.element.appendChild(shadow);
                        } <span class="hljs-keyword">else</span> {
                            element.parentNode.insertBefore(shadow, element);
                        }
                        shadows.push(shadow);
                    }
                    <span class="hljs-keyword">this</span>.shadows = shadows;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
            },
            <span class="hljs-attr">destroyShadows</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                each(<span class="hljs-keyword">this</span>.shadows || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shadow</span>) </span>{
                    <span class="hljs-keyword">this</span>.safeRemoveChild(shadow);
                }, <span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">this</span>.shadows = <span class="hljs-literal">undefined</span>;
            },
            <span class="hljs-attr">xGetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element.nodeName === <span class="hljs-string">'circle'</span>) {
                    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'x'</span>) {
                        key = <span class="hljs-string">'cx'</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'y'</span>) {
                        key = <span class="hljs-string">'cy'</span>;
                    }
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._defaultGetter(key);
            },
            <span class="hljs-attr">_defaultGetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                <span class="hljs-keyword">var</span> ret = pick(<span class="hljs-keyword">this</span>[key], <span class="hljs-keyword">this</span>.element ? <span class="hljs-keyword">this</span>.element.getAttribute(key) : <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^[\-0-9\.]+$/</span>.test(ret)) {
                    ret = <span class="hljs-built_in">parseFloat</span>(ret);
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">dSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                <span class="hljs-keyword">if</span> (value &amp;&amp; value.join) {
                    value = value.join(<span class="hljs-string">' '</span>);
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/(NaN| {2}|^$)/</span>.test(value)) {
                    value = <span class="hljs-string">'M 0 0'</span>;
                }
                element.setAttribute(key, value);
                <span class="hljs-keyword">this</span>[key] = value;
            },
            <span class="hljs-attr">dashstyleSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    strokeWidth = <span class="hljs-keyword">this</span>[<span class="hljs-string">'stroke-width'</span>];
                <span class="hljs-keyword">if</span> (strokeWidth === <span class="hljs-string">'inherit'</span>) {
                    strokeWidth = <span class="hljs-number">1</span>;
                }
                value = value &amp;&amp; value.toLowerCase();
                <span class="hljs-keyword">if</span> (value) {
                    value = value
                        .replace(<span class="hljs-string">'shortdashdotdot'</span>, <span class="hljs-string">'3,1,1,1,1,1,'</span>)
                        .replace(<span class="hljs-string">'shortdashdot'</span>, <span class="hljs-string">'3,1,1,1'</span>)
                        .replace(<span class="hljs-string">'shortdot'</span>, <span class="hljs-string">'1,1,'</span>)
                        .replace(<span class="hljs-string">'shortdash'</span>, <span class="hljs-string">'3,1,'</span>)
                        .replace(<span class="hljs-string">'longdash'</span>, <span class="hljs-string">'8,3,'</span>)
                        .replace(<span class="hljs-regexp">/dot/g</span>, <span class="hljs-string">'1,3,'</span>)
                        .replace(<span class="hljs-string">'dash'</span>, <span class="hljs-string">'4,3,'</span>)
                        .replace(<span class="hljs-regexp">/,$/</span>, <span class="hljs-string">''</span>)
                        .split(<span class="hljs-string">','</span>);
                    i = value.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        value[i] = pInt(value[i]) * strokeWidth;
                    }
                    value = value.join(<span class="hljs-string">','</span>)
                        .replace(<span class="hljs-regexp">/NaN/g</span>, <span class="hljs-string">'none'</span>);
                    <span class="hljs-keyword">this</span>.element.setAttribute(<span class="hljs-string">'stroke-dasharray'</span>, value);
                }
            },
            <span class="hljs-attr">alignSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                <span class="hljs-keyword">var</span> convert = {
                    <span class="hljs-attr">left</span>: <span class="hljs-string">'start'</span>,
                    <span class="hljs-attr">center</span>: <span class="hljs-string">'middle'</span>,
                    <span class="hljs-attr">right</span>: <span class="hljs-string">'end'</span>
                };
                <span class="hljs-keyword">this</span>.element.setAttribute(<span class="hljs-string">'text-anchor'</span>, convert[value]);
            },
            <span class="hljs-attr">opacitySetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                <span class="hljs-keyword">this</span>[key] = value;
                element.setAttribute(key, value);
            },
            <span class="hljs-attr">titleSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                <span class="hljs-keyword">var</span> titleNode = <span class="hljs-keyword">this</span>.element.getElementsByTagName(<span class="hljs-string">'title'</span>)[<span class="hljs-number">0</span>];
                <span class="hljs-keyword">if</span> (!titleNode) {
                    titleNode = doc.createElementNS(<span class="hljs-keyword">this</span>.SVG_NS, <span class="hljs-string">'title'</span>);
                    <span class="hljs-keyword">this</span>.element.appendChild(titleNode);
                }
                <span class="hljs-keyword">if</span> (titleNode.firstChild) {
                    titleNode.removeChild(titleNode.firstChild);
                }
                titleNode.appendChild(
                    doc.createTextNode(
                        (<span class="hljs-built_in">String</span>(pick(value), <span class="hljs-string">''</span>)).replace(<span class="hljs-regexp">/&lt;[^&gt;]*&gt;/g</span>, <span class="hljs-string">''</span>)
                    )
                );
            },
            <span class="hljs-attr">textSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                <span class="hljs-keyword">if</span> (value !== <span class="hljs-keyword">this</span>.textStr) {
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.bBox;
                    <span class="hljs-keyword">this</span>.textStr = value;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.added) {
                        <span class="hljs-keyword">this</span>.renderer.buildText(<span class="hljs-keyword">this</span>);
                    }
                }
            },
            <span class="hljs-attr">fillSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
                    element.setAttribute(key, value);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value) {
                    <span class="hljs-keyword">this</span>.colorGradient(value, key, element);
                }
            },
            <span class="hljs-attr">visibilitySetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'inherit'</span>) {
                    element.removeAttribute(key);
                } <span class="hljs-keyword">else</span> {
                    element.setAttribute(key, value);
                }
            },
            <span class="hljs-attr">zIndexSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>.renderer,
                    parentGroup = <span class="hljs-keyword">this</span>.parentGroup,
                    parentWrapper = parentGroup || renderer,
                    parentNode = parentWrapper.element || renderer.box,
                    childNodes,
                    otherElement,
                    otherZIndex,
                    element = <span class="hljs-keyword">this</span>.element,
                    inserted,
                    run = <span class="hljs-keyword">this</span>.added,
                    i;
                <span class="hljs-keyword">if</span> (defined(value)) {
                    element.zIndex = value;
                    value = +value;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key] === value) {
                        run = <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">this</span>[key] = value;
                }
                <span class="hljs-keyword">if</span> (run) {
                    value = <span class="hljs-keyword">this</span>.zIndex;
                    <span class="hljs-keyword">if</span> (value &amp;&amp; parentGroup) {
                        parentGroup.handleZ = <span class="hljs-literal">true</span>;
                    }
                    childNodes = parentNode.childNodes;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; childNodes.length &amp;&amp; !inserted; i++) {
                        otherElement = childNodes[i];
                        otherZIndex = otherElement.zIndex;
                        <span class="hljs-keyword">if</span> (otherElement !== element &amp;&amp; (
                                pInt(otherZIndex) &gt; value ||
                                (!defined(value) &amp;&amp; defined(otherZIndex)) ||
                                (value &lt; <span class="hljs-number">0</span> &amp;&amp; !defined(otherZIndex) &amp;&amp; parentNode !== renderer.box)
                            )) {
                            parentNode.insertBefore(element, otherElement);
                            inserted = <span class="hljs-literal">true</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (!inserted) {
                        parentNode.appendChild(element);
                    }
                }
                <span class="hljs-keyword">return</span> inserted;
            },
            <span class="hljs-attr">_defaultSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                element.setAttribute(key, value);
            }
        };
        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =
            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =
            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                <span class="hljs-keyword">this</span>[key] = value;
                <span class="hljs-keyword">this</span>.doTransform = <span class="hljs-literal">true</span>;
            };
        SVGElement.prototype[<span class="hljs-string">'stroke-widthSetter'</span>] = SVGElement.prototype.strokeSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
            <span class="hljs-keyword">this</span>[key] = value;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.stroke &amp;&amp; <span class="hljs-keyword">this</span>[<span class="hljs-string">'stroke-width'</span>]) {
                SVGElement.prototype.fillSetter.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.stroke, <span class="hljs-string">'stroke'</span>, element);
                element.setAttribute(<span class="hljs-string">'stroke-width'</span>, <span class="hljs-keyword">this</span>[<span class="hljs-string">'stroke-width'</span>]);
                <span class="hljs-keyword">this</span>.hasStroke = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'stroke-width'</span> &amp;&amp; value === <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.hasStroke) {
                element.removeAttribute(<span class="hljs-string">'stroke'</span>);
                <span class="hljs-keyword">this</span>.hasStroke = <span class="hljs-literal">false</span>;
            }
        };
        SVGRenderer = H.SVGRenderer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
        SVGRenderer.prototype = {
            <span class="hljs-attr">Element</span>: SVGElement,
            <span class="hljs-attr">SVG_NS</span>: SVG_NS,
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">container, width, height, style, forExport, allowHTML</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                    boxWrapper,
                    element,
                    desc;
                boxWrapper = renderer.createElement(<span class="hljs-string">'svg'</span>)
                    .attr({
                        <span class="hljs-string">'version'</span>: <span class="hljs-string">'1.1'</span>,
                        <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-root'</span>
                    })
                    .css(<span class="hljs-keyword">this</span>.getStyle(style));
                element = boxWrapper.element;
                container.appendChild(element);
                <span class="hljs-keyword">if</span> (container.innerHTML.indexOf(<span class="hljs-string">'xmlns'</span>) === <span class="hljs-number">-1</span>) {
                    attr(element, <span class="hljs-string">'xmlns'</span>, <span class="hljs-keyword">this</span>.SVG_NS);
                }
                renderer.isSVG = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.box = element;
                <span class="hljs-keyword">this</span>.boxWrapper = boxWrapper;
                renderer.alignedObjects = [];
                <span class="hljs-keyword">this</span>.url = (isFirefox || isWebKit) &amp;&amp; doc.getElementsByTagName(<span class="hljs-string">'base'</span>).length ?
                    win.location.href
                    .replace(<span class="hljs-regexp">/#.*?$/</span>, <span class="hljs-string">''</span>)
                    .replace(<span class="hljs-regexp">/&lt;[^&gt;]*&gt;/g</span>, <span class="hljs-string">''</span>)
                    .replace(<span class="hljs-regexp">/([\('\)])/g</span>, <span class="hljs-string">'\\$1'</span>)
                    .replace(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">'%20'</span>) :
                    <span class="hljs-string">''</span>;
                desc = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'desc'</span>).add();
                desc.element.appendChild(doc.createTextNode(<span class="hljs-string">'Created with Highstock 5.0.7'</span>));
                renderer.defs = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'defs'</span>).add();
                renderer.allowHTML = allowHTML;
                renderer.forExport = forExport;
                renderer.gradients = {};
                renderer.cache = {};
                renderer.cacheKeys = [];
                renderer.imgCount = <span class="hljs-number">0</span>;
                renderer.setSize(width, height, <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">var</span> subPixelFix, rect;
                <span class="hljs-keyword">if</span> (isFirefox &amp;&amp; container.getBoundingClientRect) {
                    subPixelFix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        css(container, {
                            <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>
                        });
                        rect = container.getBoundingClientRect();
                        css(container, {
                            <span class="hljs-attr">left</span>: (<span class="hljs-built_in">Math</span>.ceil(rect.left) - rect.left) + <span class="hljs-string">'px'</span>,
                            <span class="hljs-attr">top</span>: (<span class="hljs-built_in">Math</span>.ceil(rect.top) - rect.top) + <span class="hljs-string">'px'</span>
                        });
                    };
                    subPixelFix();
                    renderer.unSubPixelFix = addEvent(win, <span class="hljs-string">'resize'</span>, subPixelFix);
                }
            },
            <span class="hljs-attr">getStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">style</span>) </span>{
                <span class="hljs-keyword">this</span>.style = extend({
                    <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">'"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif'</span>,
                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'12px'</span>
                }, style);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.style;
            },
            <span class="hljs-attr">setStyle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">style</span>) </span>{
                <span class="hljs-keyword">this</span>.boxWrapper.css(<span class="hljs-keyword">this</span>.getStyle(style));
            },
            <span class="hljs-attr">isHidden</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.boxWrapper.getBBox().width;
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                    rendererDefs = renderer.defs;
                renderer.box = <span class="hljs-literal">null</span>;
                renderer.boxWrapper = renderer.boxWrapper.destroy();
                destroyObjectProperties(renderer.gradients || {});
                renderer.gradients = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">if</span> (rendererDefs) {
                    renderer.defs = rendererDefs.destroy();
                }
                <span class="hljs-keyword">if</span> (renderer.unSubPixelFix) {
                    renderer.unSubPixelFix();
                }
                renderer.alignedObjects = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">createElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodeName</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.Element();
                wrapper.init(<span class="hljs-keyword">this</span>, nodeName);
                <span class="hljs-keyword">return</span> wrapper;
            },
            <span class="hljs-attr">draw</span>: noop,
            <span class="hljs-attr">getRadialAttr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">radialReference, gradAttr</span>) </span>{
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">cx</span>: (radialReference[<span class="hljs-number">0</span>] - radialReference[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>) + gradAttr.cx * radialReference[<span class="hljs-number">2</span>],
                    <span class="hljs-attr">cy</span>: (radialReference[<span class="hljs-number">1</span>] - radialReference[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>) + gradAttr.cy * radialReference[<span class="hljs-number">2</span>],
                    <span class="hljs-attr">r</span>: gradAttr.r * radialReference[<span class="hljs-number">2</span>]
                };
            },
            <span class="hljs-attr">buildText</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">wrapper</span>) </span>{
                <span class="hljs-keyword">var</span> textNode = wrapper.element,
                    renderer = <span class="hljs-keyword">this</span>,
                    forExport = renderer.forExport,
                    textStr = pick(wrapper.textStr, <span class="hljs-string">''</span>).toString(),
                    hasMarkup = textStr.indexOf(<span class="hljs-string">'&lt;'</span>) !== <span class="hljs-number">-1</span>,
                    lines,
                    childNodes = textNode.childNodes,
                    clsRegex,
                    styleRegex,
                    hrefRegex,
                    wasTooLong,
                    parentX = attr(textNode, <span class="hljs-string">'x'</span>),
                    textStyles = wrapper.styles,
                    width = wrapper.textWidth,
                    textLineHeight = textStyles &amp;&amp; textStyles.lineHeight,
                    textOutline = textStyles &amp;&amp; textStyles.textOutline,
                    ellipsis = textStyles &amp;&amp; textStyles.textOverflow === <span class="hljs-string">'ellipsis'</span>,
                    noWrap = textStyles &amp;&amp; textStyles.whiteSpace === <span class="hljs-string">'nowrap'</span>,
                    fontSize = textStyles &amp;&amp; textStyles.fontSize,
                    textCache,
                    i = childNodes.length,
                    tempParent = width &amp;&amp; !wrapper.added &amp;&amp; <span class="hljs-keyword">this</span>.box,
                    getLineHeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tspan</span>) </span>{
                        <span class="hljs-keyword">var</span> fontSizeStyle;
                        fontSizeStyle = <span class="hljs-regexp">/(px|em)$/</span>.test(tspan &amp;&amp; tspan.style.fontSize) ?
                            tspan.style.fontSize :
                            (fontSize || renderer.style.fontSize || <span class="hljs-number">12</span>);
                        <span class="hljs-keyword">return</span> textLineHeight ?
                            pInt(textLineHeight) :
                            renderer.fontMetrics(
                                fontSizeStyle,
                                tspan.getAttribute(<span class="hljs-string">'style'</span>) ? tspan : textNode
                            ).h;
                    },
                    unescapeAngleBrackets = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inputStr</span>) </span>{
                        <span class="hljs-keyword">return</span> inputStr.replace(<span class="hljs-regexp">/&amp;lt;/g</span>, <span class="hljs-string">'&lt;'</span>).replace(<span class="hljs-regexp">/&amp;gt;/g</span>, <span class="hljs-string">'&gt;'</span>);
                    };
                textCache = [
                    textStr,
                    ellipsis,
                    noWrap,
                    textLineHeight,
                    textOutline,
                    fontSize,
                    width
                ].join(<span class="hljs-string">','</span>);
                <span class="hljs-keyword">if</span> (textCache === wrapper.textCache) {
                    <span class="hljs-keyword">return</span>;
                }
                wrapper.textCache = textCache;
                <span class="hljs-keyword">while</span> (i--) {
                    textNode.removeChild(childNodes[i]);
                }
                <span class="hljs-keyword">if</span> (!hasMarkup &amp;&amp; !textOutline &amp;&amp; !ellipsis &amp;&amp; !width &amp;&amp; textStr.indexOf(<span class="hljs-string">' '</span>) === <span class="hljs-number">-1</span>) {
                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));
                } <span class="hljs-keyword">else</span> {
                    clsRegex = <span class="hljs-regexp">/&lt;.*class="([^"]+)".*&gt;/</span>;
                    styleRegex = <span class="hljs-regexp">/&lt;.*style="([^"]+)".*&gt;/</span>;
                    hrefRegex = <span class="hljs-regexp">/&lt;.*href="(http[^"]+)".*&gt;/</span>;
                    <span class="hljs-keyword">if</span> (tempParent) {
                        tempParent.appendChild(textNode);
                    }
                    <span class="hljs-keyword">if</span> (hasMarkup) {
                        lines = textStr
                            .replace(<span class="hljs-regexp">/&lt;(b|strong)&gt;/g</span>, <span class="hljs-string">'&lt;span style="font-weight:bold"&gt;'</span>)
                            .replace(<span class="hljs-regexp">/&lt;(i|em)&gt;/g</span>, <span class="hljs-string">'&lt;span style="font-style:italic"&gt;'</span>)
                            .replace(<span class="hljs-regexp">/&lt;a/g</span>, <span class="hljs-string">'&lt;span'</span>)
                            .replace(<span class="hljs-regexp">/&lt;\/(b|strong|i|em|a)&gt;/g</span>, <span class="hljs-string">'&lt;/span&gt;'</span>)
                            .split(<span class="hljs-regexp">/&lt;br.*?&gt;/g</span>);
                    } <span class="hljs-keyword">else</span> {
                        lines = [textStr];
                    }
                    lines = grep(lines, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">line</span>) </span>{
                        <span class="hljs-keyword">return</span> line !== <span class="hljs-string">''</span>;
                    });
                    each(lines, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildTextLines</span>(<span class="hljs-params">line, lineNo</span>) </span>{
                        <span class="hljs-keyword">var</span> spans,
                            spanNo = <span class="hljs-number">0</span>;
                        line = line
                            .replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">''</span>)
                            .replace(<span class="hljs-regexp">/&lt;span/g</span>, <span class="hljs-string">'|||&lt;span'</span>)
                            .replace(<span class="hljs-regexp">/&lt;\/span&gt;/g</span>, <span class="hljs-string">'&lt;/span&gt;|||'</span>);
                        spans = line.split(<span class="hljs-string">'|||'</span>);
                        each(spans, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildTextSpans</span>(<span class="hljs-params">span</span>) </span>{
                            <span class="hljs-keyword">if</span> (span !== <span class="hljs-string">''</span> || spans.length === <span class="hljs-number">1</span>) {
                                <span class="hljs-keyword">var</span> attributes = {},
                                    tspan = doc.createElementNS(renderer.SVG_NS, <span class="hljs-string">'tspan'</span>),
                                    spanCls,
                                    spanStyle;
                                <span class="hljs-keyword">if</span> (clsRegex.test(span)) {
                                    spanCls = span.match(clsRegex)[<span class="hljs-number">1</span>];
                                    attr(tspan, <span class="hljs-string">'class'</span>, spanCls);
                                }
                                <span class="hljs-keyword">if</span> (styleRegex.test(span)) {
                                    spanStyle = span.match(styleRegex)[<span class="hljs-number">1</span>].replace(<span class="hljs-regexp">/(;| |^)color([ :])/</span>, <span class="hljs-string">'$1fill$2'</span>);
                                    attr(tspan, <span class="hljs-string">'style'</span>, spanStyle);
                                }
                                <span class="hljs-keyword">if</span> (hrefRegex.test(span) &amp;&amp; !forExport) {
                                    attr(tspan, <span class="hljs-string">'onclick'</span>, <span class="hljs-string">'location.href=\"'</span> + span.match(hrefRegex)[<span class="hljs-number">1</span>] + <span class="hljs-string">'\"'</span>);
                                    css(tspan, {
                                        <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>
                                    });
                                }
                                span = unescapeAngleBrackets(span.replace(<span class="hljs-regexp">/&lt;(.|\n)*?&gt;/g</span>, <span class="hljs-string">''</span>) || <span class="hljs-string">' '</span>);
                                <span class="hljs-keyword">if</span> (span !== <span class="hljs-string">' '</span>) {
                                    tspan.appendChild(doc.createTextNode(span));
                                    <span class="hljs-keyword">if</span> (!spanNo) {
                                        <span class="hljs-keyword">if</span> (lineNo &amp;&amp; parentX !== <span class="hljs-literal">null</span>) {
                                            attributes.x = parentX;
                                        }
                                    } <span class="hljs-keyword">else</span> {
                                        attributes.dx = <span class="hljs-number">0</span>;
                                    }
                                    attr(tspan, attributes);
                                    textNode.appendChild(tspan);
                                    <span class="hljs-keyword">if</span> (!spanNo &amp;&amp; lineNo) {
                                        <span class="hljs-keyword">if</span> (!svg &amp;&amp; forExport) {
                                            css(tspan, {
                                                <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>
                                            });
                                        }
                                        attr(
                                            tspan,
                                            <span class="hljs-string">'dy'</span>,
                                            getLineHeight(tspan)
                                        );
                                    }
                                    <span class="hljs-keyword">if</span> (width) {
                                        <span class="hljs-keyword">var</span> words = span.replace(<span class="hljs-regexp">/([^\^])-/g</span>, <span class="hljs-string">'$1- '</span>).split(<span class="hljs-string">' '</span>),
                                            hasWhiteSpace = spans.length &gt; <span class="hljs-number">1</span> || lineNo || (words.length &gt; <span class="hljs-number">1</span> &amp;&amp; !noWrap),
                                            tooLong,
                                            actualWidth,
                                            rest = [],
                                            dy = getLineHeight(tspan),
                                            rotation = wrapper.rotation,
                                            wordStr = span,
                                            cursor = wordStr.length,
                                            bBox;
                                        <span class="hljs-keyword">while</span> ((hasWhiteSpace || ellipsis) &amp;&amp; (words.length || rest.length)) {
                                            wrapper.rotation = <span class="hljs-number">0</span>;
                                            bBox = wrapper.getBBox(<span class="hljs-literal">true</span>);
                                            actualWidth = bBox.width;
                                            <span class="hljs-keyword">if</span> (!svg &amp;&amp; renderer.forExport) {
                                                actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);
                                            }
                                            tooLong = actualWidth &gt; width;
                                            <span class="hljs-keyword">if</span> (wasTooLong === <span class="hljs-literal">undefined</span>) {
                                                wasTooLong = tooLong;
                                            }
                                            <span class="hljs-keyword">if</span> (ellipsis &amp;&amp; wasTooLong) {
                                                cursor /= <span class="hljs-number">2</span>;
                                                <span class="hljs-keyword">if</span> (wordStr === <span class="hljs-string">''</span> || (!tooLong &amp;&amp; cursor &lt; <span class="hljs-number">0.5</span>)) {
                                                    words = [];
                                                } <span class="hljs-keyword">else</span> {
                                                    wordStr = span.substring(<span class="hljs-number">0</span>, wordStr.length + (tooLong ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * <span class="hljs-built_in">Math</span>.ceil(cursor));
                                                    words = [wordStr + (width &gt; <span class="hljs-number">3</span> ? <span class="hljs-string">'\u2026'</span> : <span class="hljs-string">''</span>)];
                                                    tspan.removeChild(tspan.firstChild);
                                                }
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tooLong || words.length === <span class="hljs-number">1</span>) {
                                                words = rest;
                                                rest = [];
                                                <span class="hljs-keyword">if</span> (words.length &amp;&amp; !noWrap) {
                                                    tspan = doc.createElementNS(SVG_NS, <span class="hljs-string">'tspan'</span>);
                                                    attr(tspan, {
                                                        <span class="hljs-attr">dy</span>: dy,
                                                        <span class="hljs-attr">x</span>: parentX
                                                    });
                                                    <span class="hljs-keyword">if</span> (spanStyle) {
                                                        attr(tspan, <span class="hljs-string">'style'</span>, spanStyle);
                                                    }
                                                    textNode.appendChild(tspan);
                                                }
                                                <span class="hljs-keyword">if</span> (actualWidth &gt; width) {
                                                    width = actualWidth;
                                                }
                                            } <span class="hljs-keyword">else</span> {
                                                tspan.removeChild(tspan.firstChild);
                                                rest.unshift(words.pop());
                                            }
                                            <span class="hljs-keyword">if</span> (words.length) {
                                                tspan.appendChild(doc.createTextNode(words.join(<span class="hljs-string">' '</span>).replace(<span class="hljs-regexp">/- /g</span>, <span class="hljs-string">'-'</span>)));
                                            }
                                        }
                                        wrapper.rotation = rotation;
                                    }
                                    spanNo++;
                                }
                            }
                        });
                    });
                    <span class="hljs-keyword">if</span> (wasTooLong) {
                        wrapper.attr(<span class="hljs-string">'title'</span>, wrapper.textStr);
                    }
                    <span class="hljs-keyword">if</span> (tempParent) {
                        tempParent.removeChild(textNode);
                    }
                    <span class="hljs-keyword">if</span> (textOutline &amp;&amp; wrapper.applyTextOutline) {
                        wrapper.applyTextOutline(textOutline);
                    }
                }
            },
            <span class="hljs-attr">getContrast</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rgba</span>) </span>{
                rgba = color(rgba).rgba;
                <span class="hljs-keyword">return</span> rgba[<span class="hljs-number">0</span>] + rgba[<span class="hljs-number">1</span>] + rgba[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">2</span> * <span class="hljs-number">255</span> ? <span class="hljs-string">'#000000'</span> : <span class="hljs-string">'#FFFFFF'</span>;
            },
            <span class="hljs-attr">button</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape</span>) </span>{
                <span class="hljs-keyword">var</span> label = <span class="hljs-keyword">this</span>.label(text, x, y, shape, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'button'</span>),
                    curState = <span class="hljs-number">0</span>;
                label.attr(merge({
                    <span class="hljs-string">'padding'</span>: <span class="hljs-number">8</span>,
                    <span class="hljs-string">'r'</span>: <span class="hljs-number">2</span>
                }, normalState));
                <span class="hljs-keyword">var</span> normalStyle,
                    hoverStyle,
                    pressedStyle,
                    disabledStyle;
                normalState = merge({
                    <span class="hljs-attr">fill</span>: <span class="hljs-string">'#f7f7f7'</span>,
                    <span class="hljs-attr">stroke</span>: <span class="hljs-string">'#cccccc'</span>,
                    <span class="hljs-string">'stroke-width'</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>,
                        <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>,
                        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'normal'</span>
                    }
                }, normalState);
                normalStyle = normalState.style;
                <span class="hljs-keyword">delete</span> normalState.style;
                hoverState = merge(normalState, {
                    <span class="hljs-attr">fill</span>: <span class="hljs-string">'#e6e6e6'</span>
                }, hoverState);
                hoverStyle = hoverState.style;
                <span class="hljs-keyword">delete</span> hoverState.style;
                pressedState = merge(normalState, {
                    <span class="hljs-attr">fill</span>: <span class="hljs-string">'#e6ebf5'</span>,
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>,
                        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>
                    }
                }, pressedState);
                pressedStyle = pressedState.style;
                <span class="hljs-keyword">delete</span> pressedState.style;
                disabledState = merge(normalState, {
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#cccccc'</span>
                    }
                }, disabledState);
                disabledStyle = disabledState.style;
                <span class="hljs-keyword">delete</span> disabledState.style;
                addEvent(label.element, isMS ? <span class="hljs-string">'mouseover'</span> : <span class="hljs-string">'mouseenter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">if</span> (curState !== <span class="hljs-number">3</span>) {
                        label.setState(<span class="hljs-number">1</span>);
                    }
                });
                addEvent(label.element, isMS ? <span class="hljs-string">'mouseout'</span> : <span class="hljs-string">'mouseleave'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">if</span> (curState !== <span class="hljs-number">3</span>) {
                        label.setState(curState);
                    }
                });
                label.setState = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>) </span>{
                    <span class="hljs-keyword">if</span> (state !== <span class="hljs-number">1</span>) {
                        label.state = curState = state;
                    }
                    label.removeClass(<span class="hljs-regexp">/highcharts-button-(normal|hover|pressed|disabled)/</span>)
                        .addClass(<span class="hljs-string">'highcharts-button-'</span> + [<span class="hljs-string">'normal'</span>, <span class="hljs-string">'hover'</span>, <span class="hljs-string">'pressed'</span>, <span class="hljs-string">'disabled'</span>][state || <span class="hljs-number">0</span>]);
                    label.attr([normalState, hoverState, pressedState, disabledState][state || <span class="hljs-number">0</span>])
                        .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || <span class="hljs-number">0</span>]);
                };
                label
                    .attr(normalState)
                    .css(extend({
                        <span class="hljs-attr">cursor</span>: <span class="hljs-string">'default'</span>
                    }, normalStyle));
                <span class="hljs-keyword">return</span> label
                    .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">if</span> (curState !== <span class="hljs-number">3</span>) {
                            callback.call(label, e);
                        }
                    });
            },
            <span class="hljs-attr">crispLine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, width</span>) </span>{
                <span class="hljs-keyword">if</span> (points[<span class="hljs-number">1</span>] === points[<span class="hljs-number">4</span>]) {
                    points[<span class="hljs-number">1</span>] = points[<span class="hljs-number">4</span>] = <span class="hljs-built_in">Math</span>.round(points[<span class="hljs-number">1</span>]) - (width % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>);
                }
                <span class="hljs-keyword">if</span> (points[<span class="hljs-number">2</span>] === points[<span class="hljs-number">5</span>]) {
                    points[<span class="hljs-number">2</span>] = points[<span class="hljs-number">5</span>] = <span class="hljs-built_in">Math</span>.round(points[<span class="hljs-number">2</span>]) + (width % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>);
                }
                <span class="hljs-keyword">return</span> points;
            },
            <span class="hljs-attr">path</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
                <span class="hljs-keyword">var</span> attribs = {
                    <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>
                };
                <span class="hljs-keyword">if</span> (isArray(path)) {
                    attribs.d = path;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(path)) {
                    extend(attribs, path);
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'path'</span>).attr(attribs);
            },
            <span class="hljs-attr">circle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, r</span>) </span>{
                <span class="hljs-keyword">var</span> attribs = isObject(x) ? x : {
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y,
                        <span class="hljs-attr">r</span>: r
                    },
                    wrapper = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'circle'</span>);
                wrapper.xSetter = wrapper.ySetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    element.setAttribute(<span class="hljs-string">'c'</span> + key, value);
                };
                <span class="hljs-keyword">return</span> wrapper.attr(attribs);
            },
            <span class="hljs-attr">arc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, r, innerR, start, end</span>) </span>{
                <span class="hljs-keyword">var</span> arc;
                <span class="hljs-keyword">if</span> (isObject(x)) {
                    y = x.y;
                    r = x.r;
                    innerR = x.innerR;
                    start = x.start;
                    end = x.end;
                    x = x.x;
                }
                arc = <span class="hljs-keyword">this</span>.symbol(<span class="hljs-string">'arc'</span>, x || <span class="hljs-number">0</span>, y || <span class="hljs-number">0</span>, r || <span class="hljs-number">0</span>, r || <span class="hljs-number">0</span>, {
                    <span class="hljs-attr">innerR</span>: innerR || <span class="hljs-number">0</span>,
                    <span class="hljs-attr">start</span>: start || <span class="hljs-number">0</span>,
                    <span class="hljs-attr">end</span>: end || <span class="hljs-number">0</span>
                });
                arc.r = r;
                <span class="hljs-keyword">return</span> arc;
            },
            <span class="hljs-attr">rect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, width, height, r, strokeWidth</span>) </span>{
                r = isObject(x) ? x.r : r;
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'rect'</span>),
                    attribs = isObject(x) ? x : x === <span class="hljs-literal">undefined</span> ? {} : {
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y,
                        <span class="hljs-attr">width</span>: <span class="hljs-built_in">Math</span>.max(width, <span class="hljs-number">0</span>),
                        <span class="hljs-attr">height</span>: <span class="hljs-built_in">Math</span>.max(height, <span class="hljs-number">0</span>)
                    };
                <span class="hljs-keyword">if</span> (strokeWidth !== <span class="hljs-literal">undefined</span>) {
                    attribs.strokeWidth = strokeWidth;
                    attribs = wrapper.crisp(attribs);
                }
                attribs.fill = <span class="hljs-string">'none'</span>;
                <span class="hljs-keyword">if</span> (r) {
                    attribs.r = r;
                }
                wrapper.rSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    attr(element, {
                        <span class="hljs-attr">rx</span>: value,
                        <span class="hljs-attr">ry</span>: value
                    });
                };
                <span class="hljs-keyword">return</span> wrapper.attr(attribs);
            },
            <span class="hljs-attr">setSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height, animate</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                    alignedObjects = renderer.alignedObjects,
                    i = alignedObjects.length;
                renderer.width = width;
                renderer.height = height;
                renderer.boxWrapper.animate({
                    <span class="hljs-attr">width</span>: width,
                    <span class="hljs-attr">height</span>: height
                }, {
                    <span class="hljs-attr">step</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">this</span>.attr({
                            <span class="hljs-attr">viewBox</span>: <span class="hljs-string">'0 0 '</span> + <span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'width'</span>) + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'height'</span>)
                        });
                    },
                    <span class="hljs-attr">duration</span>: pick(animate, <span class="hljs-literal">true</span>) ? <span class="hljs-literal">undefined</span> : <span class="hljs-number">0</span>
                });
                <span class="hljs-keyword">while</span> (i--) {
                    alignedObjects[i].align();
                }
            },
            <span class="hljs-attr">g</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                <span class="hljs-keyword">var</span> elem = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'g'</span>);
                <span class="hljs-keyword">return</span> name ? elem.attr({
                    <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-'</span> + name
                }) : elem;
            },
            <span class="hljs-attr">image</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, x, y, width, height</span>) </span>{
                <span class="hljs-keyword">var</span> attribs = {
                        <span class="hljs-attr">preserveAspectRatio</span>: <span class="hljs-string">'none'</span>
                    },
                    elemWrapper;
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>) {
                    extend(attribs, {
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y,
                        <span class="hljs-attr">width</span>: width,
                        <span class="hljs-attr">height</span>: height
                    });
                }
                elemWrapper = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'image'</span>).attr(attribs);
                <span class="hljs-keyword">if</span> (elemWrapper.element.setAttributeNS) {
                    elemWrapper.element.setAttributeNS(<span class="hljs-string">'http://www.w3.org/1999/xlink'</span>,
                        <span class="hljs-string">'href'</span>, src);
                } <span class="hljs-keyword">else</span> {
                    elemWrapper.element.setAttribute(<span class="hljs-string">'hc-svg-href'</span>, src);
                }
                <span class="hljs-keyword">return</span> elemWrapper;
            },
            <span class="hljs-attr">symbol</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">symbol, x, y, width, height, options</span>) </span>{
                <span class="hljs-keyword">var</span> ren = <span class="hljs-keyword">this</span>,
                    obj,
                    symbolFn = <span class="hljs-keyword">this</span>.symbols[symbol],
                    path = defined(x) &amp;&amp; symbolFn &amp;&amp; <span class="hljs-keyword">this</span>.symbols[symbol](
                        <span class="hljs-built_in">Math</span>.round(x),
                        <span class="hljs-built_in">Math</span>.round(y),
                        width,
                        height,
                        options
                    ),
                    imageRegex = <span class="hljs-regexp">/^url\((.*?)\)$/</span>,
                    imageSrc,
                    centerImage;
                <span class="hljs-keyword">if</span> (symbolFn) {
                    obj = <span class="hljs-keyword">this</span>.path(path);
                    obj.attr(<span class="hljs-string">'fill'</span>, <span class="hljs-string">'none'</span>);
                    extend(obj, {
                        <span class="hljs-attr">symbolName</span>: symbol,
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y,
                        <span class="hljs-attr">width</span>: width,
                        <span class="hljs-attr">height</span>: height
                    });
                    <span class="hljs-keyword">if</span> (options) {
                        extend(obj, options);
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (imageRegex.test(symbol)) {
                    imageSrc = symbol.match(imageRegex)[<span class="hljs-number">1</span>];
                    obj = <span class="hljs-keyword">this</span>.image(imageSrc);
                    obj.imgwidth = pick(
                        symbolSizes[imageSrc] &amp;&amp; symbolSizes[imageSrc].width,
                        options &amp;&amp; options.width
                    );
                    obj.imgheight = pick(
                        symbolSizes[imageSrc] &amp;&amp; symbolSizes[imageSrc].height,
                        options &amp;&amp; options.height
                    );
                    centerImage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        obj.attr({
                            <span class="hljs-attr">width</span>: obj.width,
                            <span class="hljs-attr">height</span>: obj.height
                        });
                    };
                    each([<span class="hljs-string">'width'</span>, <span class="hljs-string">'height'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        obj[key + <span class="hljs-string">'Setter'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                            <span class="hljs-keyword">var</span> attribs = {},
                                imgSize = <span class="hljs-keyword">this</span>[<span class="hljs-string">'img'</span> + key],
                                trans = key === <span class="hljs-string">'width'</span> ? <span class="hljs-string">'translateX'</span> : <span class="hljs-string">'translateY'</span>;
                            <span class="hljs-keyword">this</span>[key] = value;
                            <span class="hljs-keyword">if</span> (defined(imgSize)) {
                                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element) {
                                    <span class="hljs-keyword">this</span>.element.setAttribute(key, imgSize);
                                }
                                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.alignByTranslate) {
                                    attribs[trans] = ((<span class="hljs-keyword">this</span>[key] || <span class="hljs-number">0</span>) - imgSize) / <span class="hljs-number">2</span>;
                                    <span class="hljs-keyword">this</span>.attr(attribs);
                                }
                            }
                        };
                    });
                    <span class="hljs-keyword">if</span> (defined(x)) {
                        obj.attr({
                            <span class="hljs-attr">x</span>: x,
                            <span class="hljs-attr">y</span>: y
                        });
                    }
                    obj.isImg = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">if</span> (defined(obj.imgwidth) &amp;&amp; defined(obj.imgheight)) {
                        centerImage();
                    } <span class="hljs-keyword">else</span> {
                        obj.attr({
                            <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>
                        });
                        createElement(<span class="hljs-string">'img'</span>, {
                            <span class="hljs-attr">onload</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                <span class="hljs-keyword">var</span> chart = charts[ren.chartIndex];
                                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.width === <span class="hljs-number">0</span>) {
                                    css(<span class="hljs-keyword">this</span>, {
                                        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                                        <span class="hljs-attr">top</span>: <span class="hljs-string">'-999em'</span>
                                    });
                                    doc.body.appendChild(<span class="hljs-keyword">this</span>);
                                }
                                symbolSizes[imageSrc] = {
                                    <span class="hljs-attr">width</span>: <span class="hljs-keyword">this</span>.width,
                                    <span class="hljs-attr">height</span>: <span class="hljs-keyword">this</span>.height
                                };
                                obj.imgwidth = <span class="hljs-keyword">this</span>.width;
                                obj.imgheight = <span class="hljs-keyword">this</span>.height;
                                <span class="hljs-keyword">if</span> (obj.element) {
                                    centerImage();
                                }
                                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parentNode) {
                                    <span class="hljs-keyword">this</span>.parentNode.removeChild(<span class="hljs-keyword">this</span>);
                                }
                                ren.imgCount--;
                                <span class="hljs-keyword">if</span> (!ren.imgCount &amp;&amp; chart &amp;&amp; chart.onload) {
                                    chart.onload();
                                }
                            },
                            <span class="hljs-attr">src</span>: imageSrc
                        });
                        <span class="hljs-keyword">this</span>.imgCount++;
                    }
                }
                <span class="hljs-keyword">return</span> obj;
            },
            <span class="hljs-attr">symbols</span>: {
                <span class="hljs-string">'circle'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arc(x + w / <span class="hljs-number">2</span>, y + h / <span class="hljs-number">2</span>, w / <span class="hljs-number">2</span>, h / <span class="hljs-number">2</span>, {
                        <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">end</span>: <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>,
                        <span class="hljs-attr">open</span>: <span class="hljs-literal">false</span>
                    });
                },
                <span class="hljs-string">'square'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                    <span class="hljs-keyword">return</span> [
                        <span class="hljs-string">'M'</span>, x, y,
                        <span class="hljs-string">'L'</span>, x + w, y,
                        x + w, y + h,
                        x, y + h,
                        <span class="hljs-string">'Z'</span>
                    ];
                },
                <span class="hljs-string">'triangle'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                    <span class="hljs-keyword">return</span> [
                        <span class="hljs-string">'M'</span>, x + w / <span class="hljs-number">2</span>, y,
                        <span class="hljs-string">'L'</span>, x + w, y + h,
                        x, y + h,
                        <span class="hljs-string">'Z'</span>
                    ];
                },
                <span class="hljs-string">'triangle-down'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                    <span class="hljs-keyword">return</span> [
                        <span class="hljs-string">'M'</span>, x, y,
                        <span class="hljs-string">'L'</span>, x + w, y,
                        x + w / <span class="hljs-number">2</span>, y + h,
                        <span class="hljs-string">'Z'</span>
                    ];
                },
                <span class="hljs-string">'diamond'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                    <span class="hljs-keyword">return</span> [
                        <span class="hljs-string">'M'</span>, x + w / <span class="hljs-number">2</span>, y,
                        <span class="hljs-string">'L'</span>, x + w, y + h / <span class="hljs-number">2</span>,
                        x + w / <span class="hljs-number">2</span>, y + h,
                        x, y + h / <span class="hljs-number">2</span>,
                        <span class="hljs-string">'Z'</span>
                    ];
                },
                <span class="hljs-string">'arc'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
                    <span class="hljs-keyword">var</span> start = options.start,
                        rx = options.r || w,
                        ry = options.r || h || w,
                        end = options.end - <span class="hljs-number">0.001</span>,
                        innerRadius = options.innerR,
                        open = options.open,
                        cosStart = <span class="hljs-built_in">Math</span>.cos(start),
                        sinStart = <span class="hljs-built_in">Math</span>.sin(start),
                        cosEnd = <span class="hljs-built_in">Math</span>.cos(end),
                        sinEnd = <span class="hljs-built_in">Math</span>.sin(end),
                        longArc = options.end - start &lt; <span class="hljs-built_in">Math</span>.PI ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>,
                        arc;
                    arc = [
                        <span class="hljs-string">'M'</span>,
                        x + rx * cosStart,
                        y + ry * sinStart,
                        <span class="hljs-string">'A'</span>,
                        rx,
                        ry,
                        <span class="hljs-number">0</span>,
                        longArc,
                        <span class="hljs-number">1</span>,
                        x + rx * cosEnd,
                        y + ry * sinEnd
                    ];
                    <span class="hljs-keyword">if</span> (defined(innerRadius)) {
                        arc.push(
                            open ? <span class="hljs-string">'M'</span> : <span class="hljs-string">'L'</span>,
                            x + innerRadius * cosEnd,
                            y + innerRadius * sinEnd,
                            <span class="hljs-string">'A'</span>,
                            innerRadius,
                            innerRadius,
                            <span class="hljs-number">0</span>,
                            longArc,
                            <span class="hljs-number">0</span>,
                            x + innerRadius * cosStart,
                            y + innerRadius * sinStart
                        );
                    }
                    arc.push(open ? <span class="hljs-string">''</span> : <span class="hljs-string">'Z'</span>);
                    <span class="hljs-keyword">return</span> arc;
                },
                <span class="hljs-attr">callout</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
                    <span class="hljs-keyword">var</span> arrowLength = <span class="hljs-number">6</span>,
                        halfDistance = <span class="hljs-number">6</span>,
                        r = <span class="hljs-built_in">Math</span>.min((options &amp;&amp; options.r) || <span class="hljs-number">0</span>, w, h),
                        safeDistance = r + halfDistance,
                        anchorX = options &amp;&amp; options.anchorX,
                        anchorY = options &amp;&amp; options.anchorY,
                        path;
                    path = [
                        <span class="hljs-string">'M'</span>, x + r, y,
                        <span class="hljs-string">'L'</span>, x + w - r, y,
                        <span class="hljs-string">'C'</span>, x + w, y, x + w, y, x + w, y + r,
                        <span class="hljs-string">'L'</span>, x + w, y + h - r,
                        <span class="hljs-string">'C'</span>, x + w, y + h, x + w, y + h, x + w - r, y + h,
                        <span class="hljs-string">'L'</span>, x + r, y + h,
                        <span class="hljs-string">'C'</span>, x, y + h, x, y + h, x, y + h - r,
                        <span class="hljs-string">'L'</span>, x, y + r,
                        <span class="hljs-string">'C'</span>, x, y, x, y, x + r, y
                    ];
                    <span class="hljs-keyword">if</span> (anchorX &amp;&amp; anchorX &gt; w) {
                        <span class="hljs-keyword">if</span> (anchorY &gt; y + safeDistance &amp;&amp; anchorY &lt; y + h - safeDistance) {
                            path.splice(<span class="hljs-number">13</span>, <span class="hljs-number">3</span>,
                                <span class="hljs-string">'L'</span>, x + w, anchorY - halfDistance,
                                x + w + arrowLength, anchorY,
                                x + w, anchorY + halfDistance,
                                x + w, y + h - r
                            );
                        } <span class="hljs-keyword">else</span> {
                            path.splice(<span class="hljs-number">13</span>, <span class="hljs-number">3</span>,
                                <span class="hljs-string">'L'</span>, x + w, h / <span class="hljs-number">2</span>,
                                anchorX, anchorY,
                                x + w, h / <span class="hljs-number">2</span>,
                                x + w, y + h - r
                            );
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anchorX &amp;&amp; anchorX &lt; <span class="hljs-number">0</span>) {
                        <span class="hljs-keyword">if</span> (anchorY &gt; y + safeDistance &amp;&amp; anchorY &lt; y + h - safeDistance) {
                            path.splice(<span class="hljs-number">33</span>, <span class="hljs-number">3</span>,
                                <span class="hljs-string">'L'</span>, x, anchorY + halfDistance,
                                x - arrowLength, anchorY,
                                x, anchorY - halfDistance,
                                x, y + r
                            );
                        } <span class="hljs-keyword">else</span> {
                            path.splice(<span class="hljs-number">33</span>, <span class="hljs-number">3</span>,
                                <span class="hljs-string">'L'</span>, x, h / <span class="hljs-number">2</span>,
                                anchorX, anchorY,
                                x, h / <span class="hljs-number">2</span>,
                                x, y + r
                            );
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anchorY &amp;&amp; anchorY &gt; h &amp;&amp; anchorX &gt; x + safeDistance &amp;&amp; anchorX &lt; x + w - safeDistance) {
                        path.splice(<span class="hljs-number">23</span>, <span class="hljs-number">3</span>,
                            <span class="hljs-string">'L'</span>, anchorX + halfDistance, y + h,
                            anchorX, y + h + arrowLength,
                            anchorX - halfDistance, y + h,
                            x + r, y + h
                        );
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (anchorY &amp;&amp; anchorY &lt; <span class="hljs-number">0</span> &amp;&amp; anchorX &gt; x + safeDistance &amp;&amp; anchorX &lt; x + w - safeDistance) {
                        path.splice(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>,
                            <span class="hljs-string">'L'</span>, anchorX - halfDistance, y,
                            anchorX, y - arrowLength,
                            anchorX + halfDistance, y,
                            w - r, y
                        );
                    }
                    <span class="hljs-keyword">return</span> path;
                }
            },
            <span class="hljs-attr">clipRect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, width, height</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper,
                    id = H.uniqueKey(),
                    clipPath = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'clipPath'</span>).attr({
                        <span class="hljs-attr">id</span>: id
                    }).add(<span class="hljs-keyword">this</span>.defs);
                wrapper = <span class="hljs-keyword">this</span>.rect(x, y, width, height, <span class="hljs-number">0</span>).add(clipPath);
                wrapper.id = id;
                wrapper.clipPath = clipPath;
                wrapper.count = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span> wrapper;
            },
            <span class="hljs-attr">text</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, x, y, useHTML</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                    fakeSVG = !svg &amp;&amp; renderer.forExport,
                    wrapper,
                    attribs = {};
                <span class="hljs-keyword">if</span> (useHTML &amp;&amp; (renderer.allowHTML || !renderer.forExport)) {
                    <span class="hljs-keyword">return</span> renderer.html(str, x, y);
                }
                attribs.x = <span class="hljs-built_in">Math</span>.round(x || <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (y) {
                    attribs.y = <span class="hljs-built_in">Math</span>.round(y);
                }
                <span class="hljs-keyword">if</span> (str || str === <span class="hljs-number">0</span>) {
                    attribs.text = str;
                }
                wrapper = renderer.createElement(<span class="hljs-string">'text'</span>)
                    .attr(attribs);
                <span class="hljs-keyword">if</span> (fakeSVG) {
                    wrapper.css({
                        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>
                    });
                }
                <span class="hljs-keyword">if</span> (!useHTML) {
                    wrapper.xSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                        <span class="hljs-keyword">var</span> tspans = element.getElementsByTagName(<span class="hljs-string">'tspan'</span>),
                            tspan,
                            parentVal = element.getAttribute(key),
                            i;
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tspans.length; i++) {
                            tspan = tspans[i];
                            <span class="hljs-keyword">if</span> (tspan.getAttribute(key) === parentVal) {
                                tspan.setAttribute(key, value);
                            }
                        }
                        element.setAttribute(key, value);
                    };
                }
                <span class="hljs-keyword">return</span> wrapper;
            },
            <span class="hljs-attr">fontMetrics</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fontSize, elem</span>) </span>{
                <span class="hljs-keyword">var</span> lineHeight,
                    baseline;
                fontSize = fontSize ||
                    (elem &amp;&amp; elem.style &amp;&amp; elem.style.fontSize) ||
                    (<span class="hljs-keyword">this</span>.style &amp;&amp; <span class="hljs-keyword">this</span>.style.fontSize);
                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/px/</span>.test(fontSize)) {
                    fontSize = pInt(fontSize);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/em/</span>.test(fontSize)) {
                    fontSize = <span class="hljs-built_in">parseFloat</span>(fontSize) *
                        (elem ? <span class="hljs-keyword">this</span>.fontMetrics(<span class="hljs-literal">null</span>, elem.parentNode).f : <span class="hljs-number">16</span>);
                } <span class="hljs-keyword">else</span> {
                    fontSize = <span class="hljs-number">12</span>;
                }
                lineHeight = fontSize &lt; <span class="hljs-number">24</span> ? fontSize + <span class="hljs-number">3</span> : <span class="hljs-built_in">Math</span>.round(fontSize * <span class="hljs-number">1.2</span>);
                baseline = <span class="hljs-built_in">Math</span>.round(lineHeight * <span class="hljs-number">0.8</span>);
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">h</span>: lineHeight,
                    <span class="hljs-attr">b</span>: baseline,
                    <span class="hljs-attr">f</span>: fontSize
                };
            },
            <span class="hljs-attr">rotCorr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">baseline, rotation, alterY</span>) </span>{
                <span class="hljs-keyword">var</span> y = baseline;
                <span class="hljs-keyword">if</span> (rotation &amp;&amp; alterY) {
                    y = <span class="hljs-built_in">Math</span>.max(y * <span class="hljs-built_in">Math</span>.cos(rotation * deg2rad), <span class="hljs-number">4</span>);
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: (-baseline / <span class="hljs-number">3</span>) * <span class="hljs-built_in">Math</span>.sin(rotation * deg2rad),
                    <span class="hljs-attr">y</span>: y
                };
            },
            <span class="hljs-attr">label</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, x, y, shape, anchorX, anchorY, useHTML, baseline, className</span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                    wrapper = renderer.g(className !== <span class="hljs-string">'button'</span> &amp;&amp; <span class="hljs-string">'label'</span>),
                    text = wrapper.text = renderer.text(<span class="hljs-string">''</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, useHTML)
                    .attr({
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                    }),
                    box,
                    bBox,
                    alignFactor = <span class="hljs-number">0</span>,
                    padding = <span class="hljs-number">3</span>,
                    paddingLeft = <span class="hljs-number">0</span>,
                    width,
                    height,
                    wrapperX,
                    wrapperY,
                    textAlign,
                    deferredAttr = {},
                    strokeWidth,
                    baselineOffset,
                    hasBGImage = <span class="hljs-regexp">/^url\((.*?)\)$/</span>.test(shape),
                    needsBox = hasBGImage,
                    getCrispAdjust,
                    updateBoxSize,
                    updateTextPadding,
                    boxAttr;
                <span class="hljs-keyword">if</span> (className) {
                    wrapper.addClass(<span class="hljs-string">'highcharts-'</span> + className);
                }
                needsBox = hasBGImage;
                getCrispAdjust = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> (strokeWidth || <span class="hljs-number">0</span>) % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>;
                };
                updateBoxSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> style = text.element.style,
                        crispAdjust,
                        attribs = {};
                    bBox = (width === <span class="hljs-literal">undefined</span> || height === <span class="hljs-literal">undefined</span> || textAlign) &amp;&amp; defined(text.textStr) &amp;&amp;
                        text.getBBox();
                    wrapper.width = (width || bBox.width || <span class="hljs-number">0</span>) + <span class="hljs-number">2</span> * padding + paddingLeft;
                    wrapper.height = (height || bBox.height || <span class="hljs-number">0</span>) + <span class="hljs-number">2</span> * padding;
                    baselineOffset = padding + renderer.fontMetrics(style &amp;&amp; style.fontSize, text).b;
                    <span class="hljs-keyword">if</span> (needsBox) {
                        <span class="hljs-keyword">if</span> (!box) {
                            wrapper.box = box = renderer.symbols[shape] || hasBGImage ?
                                renderer.symbol(shape) :
                                renderer.rect();
                            box.addClass(
                                (className === <span class="hljs-string">'button'</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'highcharts-label-box'</span>) +
                                (className ? <span class="hljs-string">' highcharts-'</span> + className + <span class="hljs-string">'-box'</span> : <span class="hljs-string">''</span>)
                            );
                            box.add(wrapper);
                            crispAdjust = getCrispAdjust();
                            attribs.x = crispAdjust;
                            attribs.y = (baseline ? -baselineOffset : <span class="hljs-number">0</span>) + crispAdjust;
                        }
                        attribs.width = <span class="hljs-built_in">Math</span>.round(wrapper.width);
                        attribs.height = <span class="hljs-built_in">Math</span>.round(wrapper.height);
                        box.attr(extend(attribs, deferredAttr));
                        deferredAttr = {};
                    }
                };
                updateTextPadding = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> textX = paddingLeft + padding,
                        textY;
                    textY = baseline ? <span class="hljs-number">0</span> : baselineOffset;
                    <span class="hljs-keyword">if</span> (defined(width) &amp;&amp; bBox &amp;&amp; (textAlign === <span class="hljs-string">'center'</span> || textAlign === <span class="hljs-string">'right'</span>)) {
                        textX += {
                            <span class="hljs-attr">center</span>: <span class="hljs-number">0.5</span>,
                            <span class="hljs-attr">right</span>: <span class="hljs-number">1</span>
                        }[textAlign] * (width - bBox.width);
                    }
                    <span class="hljs-keyword">if</span> (textX !== text.x || textY !== text.y) {
                        text.attr(<span class="hljs-string">'x'</span>, textX);
                        <span class="hljs-keyword">if</span> (textY !== <span class="hljs-literal">undefined</span>) {
                            text.attr(<span class="hljs-string">'y'</span>, textY);
                        }
                    }
                    text.x = textX;
                    text.y = textY;
                };
                boxAttr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
                    <span class="hljs-keyword">if</span> (box) {
                        box.attr(key, value);
                    } <span class="hljs-keyword">else</span> {
                        deferredAttr[key] = value;
                    }
                };
                wrapper.onAdd = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    text.add(wrapper);
                    wrapper.attr({
                        <span class="hljs-attr">text</span>: (str || str === <span class="hljs-number">0</span>) ? str : <span class="hljs-string">''</span>,
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y
                    });
                    <span class="hljs-keyword">if</span> (box &amp;&amp; defined(anchorX)) {
                        wrapper.attr({
                            <span class="hljs-attr">anchorX</span>: anchorX,
                            <span class="hljs-attr">anchorY</span>: anchorY
                        });
                    }
                };
                wrapper.widthSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    width = value;
                };
                wrapper.heightSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    height = value;
                };
                wrapper[<span class="hljs-string">'text-alignSetter'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    textAlign = value;
                };
                wrapper.paddingSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">if</span> (defined(value) &amp;&amp; value !== padding) {
                        padding = wrapper.padding = value;
                        updateTextPadding();
                    }
                };
                wrapper.paddingLeftSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">if</span> (defined(value) &amp;&amp; value !== paddingLeft) {
                        paddingLeft = value;
                        updateTextPadding();
                    }
                };
                wrapper.alignSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    value = {
                        <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">center</span>: <span class="hljs-number">0.5</span>,
                        <span class="hljs-attr">right</span>: <span class="hljs-number">1</span>
                    }[value];
                    <span class="hljs-keyword">if</span> (value !== alignFactor) {
                        alignFactor = value;
                        <span class="hljs-keyword">if</span> (bBox) {
                            wrapper.attr({
                                <span class="hljs-attr">x</span>: wrapperX
                            });
                        }
                    }
                };
                wrapper.textSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) {
                        text.textSetter(value);
                    }
                    updateBoxSize();
                    updateTextPadding();
                };
                wrapper[<span class="hljs-string">'stroke-widthSetter'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    <span class="hljs-keyword">if</span> (value) {
                        needsBox = <span class="hljs-literal">true</span>;
                    }
                    strokeWidth = <span class="hljs-keyword">this</span>[<span class="hljs-string">'stroke-width'</span>] = value;
                    boxAttr(key, value);
                };
                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'fill'</span> &amp;&amp; value) {
                        needsBox = <span class="hljs-literal">true</span>;
                    }
                    boxAttr(key, value);
                };
                wrapper.anchorXSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    anchorX = value;
                    boxAttr(key, <span class="hljs-built_in">Math</span>.round(value) - getCrispAdjust() - wrapperX);
                };
                wrapper.anchorYSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    anchorY = value;
                    boxAttr(key, value - wrapperY);
                };
                wrapper.xSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    wrapper.x = value;
                    <span class="hljs-keyword">if</span> (alignFactor) {
                        value -= alignFactor * ((width || bBox.width) + <span class="hljs-number">2</span> * padding);
                    }
                    wrapperX = <span class="hljs-built_in">Math</span>.round(value);
                    wrapper.attr(<span class="hljs-string">'translateX'</span>, wrapperX);
                };
                wrapper.ySetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    wrapperY = wrapper.y = <span class="hljs-built_in">Math</span>.round(value);
                    wrapper.attr(<span class="hljs-string">'translateY'</span>, wrapperY);
                };
                <span class="hljs-keyword">var</span> baseCss = wrapper.css;
                <span class="hljs-keyword">return</span> extend(wrapper, {
                    <span class="hljs-attr">css</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">styles</span>) </span>{
                        <span class="hljs-keyword">if</span> (styles) {
                            <span class="hljs-keyword">var</span> textStyles = {};
                            styles = merge(styles);
                            each(wrapper.textProps, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                                <span class="hljs-keyword">if</span> (styles[prop] !== <span class="hljs-literal">undefined</span>) {
                                    textStyles[prop] = styles[prop];
                                    <span class="hljs-keyword">delete</span> styles[prop];
                                }
                            });
                            text.css(textStyles);
                        }
                        <span class="hljs-keyword">return</span> baseCss.call(wrapper, styles);
                    },
                    <span class="hljs-attr">getBBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">return</span> {
                            <span class="hljs-attr">width</span>: bBox.width + <span class="hljs-number">2</span> * padding,
                            <span class="hljs-attr">height</span>: bBox.height + <span class="hljs-number">2</span> * padding,
                            <span class="hljs-attr">x</span>: bBox.x - padding,
                            <span class="hljs-attr">y</span>: bBox.y - padding
                        };
                    },
                    <span class="hljs-attr">shadow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) </span>{
                        <span class="hljs-keyword">if</span> (b) {
                            updateBoxSize();
                            <span class="hljs-keyword">if</span> (box) {
                                box.shadow(b);
                            }
                        }
                        <span class="hljs-keyword">return</span> wrapper;
                    },
                    <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        removeEvent(wrapper.element, <span class="hljs-string">'mouseenter'</span>);
                        removeEvent(wrapper.element, <span class="hljs-string">'mouseleave'</span>);
                        <span class="hljs-keyword">if</span> (text) {
                            text = text.destroy();
                        }
                        <span class="hljs-keyword">if</span> (box) {
                            box = box.destroy();
                        }
                        SVGElement.prototype.destroy.call(wrapper);
                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = <span class="hljs-literal">null</span>;
                    }
                });
            }
        };
        H.Renderer = SVGRenderer;
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> attr = H.attr,
            createElement = H.createElement,
            css = H.css,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            isFirefox = H.isFirefox,
            isMS = H.isMS,
            isWebKit = H.isWebKit,
            pInt = H.pInt,
            SVGElement = H.SVGElement,
            SVGRenderer = H.SVGRenderer,
            win = H.win,
            wrap = H.wrap;
        extend(SVGElement.prototype, {
            <span class="hljs-attr">htmlCss</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">styles</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    element = wrapper.element,
                    textWidth = styles &amp;&amp; element.tagName === <span class="hljs-string">'SPAN'</span> &amp;&amp; styles.width;
                <span class="hljs-keyword">if</span> (textWidth) {
                    <span class="hljs-keyword">delete</span> styles.width;
                    wrapper.textWidth = textWidth;
                    wrapper.updateTransform();
                }
                <span class="hljs-keyword">if</span> (styles &amp;&amp; styles.textOverflow === <span class="hljs-string">'ellipsis'</span>) {
                    styles.whiteSpace = <span class="hljs-string">'nowrap'</span>;
                    styles.overflow = <span class="hljs-string">'hidden'</span>;
                }
                wrapper.styles = extend(wrapper.styles, styles);
                css(wrapper.element, styles);
                <span class="hljs-keyword">return</span> wrapper;
            },
            <span class="hljs-attr">htmlGetBBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    element = wrapper.element;
                <span class="hljs-keyword">if</span> (element.nodeName === <span class="hljs-string">'text'</span>) {
                    element.style.position = <span class="hljs-string">'absolute'</span>;
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: element.offsetLeft,
                    <span class="hljs-attr">y</span>: element.offsetTop,
                    <span class="hljs-attr">width</span>: element.offsetWidth,
                    <span class="hljs-attr">height</span>: element.offsetHeight
                };
            },
            <span class="hljs-attr">htmlUpdateTransform</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.added) {
                    <span class="hljs-keyword">this</span>.alignOnAdd = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                    renderer = wrapper.renderer,
                    elem = wrapper.element,
                    translateX = wrapper.translateX || <span class="hljs-number">0</span>,
                    translateY = wrapper.translateY || <span class="hljs-number">0</span>,
                    x = wrapper.x || <span class="hljs-number">0</span>,
                    y = wrapper.y || <span class="hljs-number">0</span>,
                    align = wrapper.textAlign || <span class="hljs-string">'left'</span>,
                    alignCorrection = {
                        <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">center</span>: <span class="hljs-number">0.5</span>,
                        <span class="hljs-attr">right</span>: <span class="hljs-number">1</span>
                    }[align],
                    styles = wrapper.styles;
                css(elem, {
                    <span class="hljs-attr">marginLeft</span>: translateX,
                    <span class="hljs-attr">marginTop</span>: translateY
                });
                <span class="hljs-keyword">if</span> (wrapper.shadows) {
                    each(wrapper.shadows, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shadow</span>) </span>{
                        css(shadow, {
                            <span class="hljs-attr">marginLeft</span>: translateX + <span class="hljs-number">1</span>,
                            <span class="hljs-attr">marginTop</span>: translateY + <span class="hljs-number">1</span>
                        });
                    });
                }
                <span class="hljs-keyword">if</span> (wrapper.inverted) {
                    each(elem.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
                        renderer.invertChild(child, elem);
                    });
                }
                <span class="hljs-keyword">if</span> (elem.tagName === <span class="hljs-string">'SPAN'</span>) {
                    <span class="hljs-keyword">var</span> rotation = wrapper.rotation,
                        baseline,
                        textWidth = pInt(wrapper.textWidth),
                        whiteSpace = styles &amp;&amp; styles.whiteSpace,
                        currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(<span class="hljs-string">','</span>);
                    <span class="hljs-keyword">if</span> (currentTextTransform !== wrapper.cTT) {
                        baseline = renderer.fontMetrics(elem.style.fontSize).b;
                        <span class="hljs-keyword">if</span> (defined(rotation)) {
                            wrapper.setSpanRotation(rotation, alignCorrection, baseline);
                        }
                        css(elem, {
                            <span class="hljs-attr">width</span>: <span class="hljs-string">''</span>,
                            <span class="hljs-attr">whiteSpace</span>: whiteSpace || <span class="hljs-string">'nowrap'</span>
                        });
                        <span class="hljs-keyword">if</span> (elem.offsetWidth &gt; textWidth &amp;&amp; <span class="hljs-regexp">/[ \-]/</span>.test(elem.textContent || elem.innerText)) {
                            css(elem, {
                                <span class="hljs-attr">width</span>: textWidth + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>,
                                <span class="hljs-attr">whiteSpace</span>: whiteSpace || <span class="hljs-string">'normal'</span>
                            });
                        }
                        wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);
                    }
                    css(elem, {
                        <span class="hljs-attr">left</span>: (x + (wrapper.xCorr || <span class="hljs-number">0</span>)) + <span class="hljs-string">'px'</span>,
                        <span class="hljs-attr">top</span>: (y + (wrapper.yCorr || <span class="hljs-number">0</span>)) + <span class="hljs-string">'px'</span>
                    });
                    <span class="hljs-keyword">if</span> (isWebKit) {
                        baseline = elem.offsetHeight;
                    }
                    wrapper.cTT = currentTextTransform;
                }
            },
            <span class="hljs-attr">setSpanRotation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rotation, alignCorrection, baseline</span>) </span>{
                <span class="hljs-keyword">var</span> rotationStyle = {},
                    cssTransformKey = isMS ? <span class="hljs-string">'-ms-transform'</span> : isWebKit ? <span class="hljs-string">'-webkit-transform'</span> : isFirefox ? <span class="hljs-string">'MozTransform'</span> : win.opera ? <span class="hljs-string">'-o-transform'</span> : <span class="hljs-string">''</span>;
                rotationStyle[cssTransformKey] = rotationStyle.transform = <span class="hljs-string">'rotate('</span> + rotation + <span class="hljs-string">'deg)'</span>;
                rotationStyle[cssTransformKey + (isFirefox ? <span class="hljs-string">'Origin'</span> : <span class="hljs-string">'-origin'</span>)] = rotationStyle.transformOrigin = (alignCorrection * <span class="hljs-number">100</span>) + <span class="hljs-string">'% '</span> + baseline + <span class="hljs-string">'px'</span>;
                css(<span class="hljs-keyword">this</span>.element, rotationStyle);
            },
            <span class="hljs-attr">getSpanCorrection</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, baseline, alignCorrection</span>) </span>{
                <span class="hljs-keyword">this</span>.xCorr = -width * alignCorrection;
                <span class="hljs-keyword">this</span>.yCorr = -baseline;
            }
        });
        extend(SVGRenderer.prototype, {
            <span class="hljs-attr">html</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, x, y</span>) </span>{
                <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'span'</span>),
                    element = wrapper.element,
                    renderer = wrapper.renderer,
                    isSVG = renderer.isSVG,
                    addSetters = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, style</span>) </span>{
                        each([<span class="hljs-string">'opacity'</span>, <span class="hljs-string">'visibility'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                            wrap(element, prop + <span class="hljs-string">'Setter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, value, key, elem</span>) </span>{
                                proceed.call(<span class="hljs-keyword">this</span>, value, key, elem);
                                style[key] = value;
                            });
                        });
                    };
                wrapper.textSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">if</span> (value !== element.innerHTML) {
                        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.bBox;
                    }
                    element.innerHTML = <span class="hljs-keyword">this</span>.textStr = value;
                    wrapper.htmlUpdateTransform();
                };
                <span class="hljs-keyword">if</span> (isSVG) {
                    addSetters(wrapper, wrapper.element.style);
                }
                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'align'</span>) {
                        key = <span class="hljs-string">'textAlign'</span>;
                    }
                    wrapper[key] = value;
                    wrapper.htmlUpdateTransform();
                };
                wrapper
                    .attr({
                        <span class="hljs-attr">text</span>: str,
                        <span class="hljs-attr">x</span>: <span class="hljs-built_in">Math</span>.round(x),
                        <span class="hljs-attr">y</span>: <span class="hljs-built_in">Math</span>.round(y)
                    })
                    .css({
                        <span class="hljs-attr">fontFamily</span>: <span class="hljs-keyword">this</span>.style.fontFamily,
                        <span class="hljs-attr">fontSize</span>: <span class="hljs-keyword">this</span>.style.fontSize,
                        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>
                    });
                element.style.whiteSpace = <span class="hljs-string">'nowrap'</span>;
                wrapper.css = wrapper.htmlCss;
                <span class="hljs-keyword">if</span> (isSVG) {
                    wrapper.add = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">svgGroupWrapper</span>) </span>{
                        <span class="hljs-keyword">var</span> htmlGroup,
                            container = renderer.box.parentNode,
                            parentGroup,
                            parents = [];
                        <span class="hljs-keyword">this</span>.parentGroup = svgGroupWrapper;
                        <span class="hljs-keyword">if</span> (svgGroupWrapper) {
                            htmlGroup = svgGroupWrapper.div;
                            <span class="hljs-keyword">if</span> (!htmlGroup) {
                                parentGroup = svgGroupWrapper;
                                <span class="hljs-keyword">while</span> (parentGroup) {
                                    parents.push(parentGroup);
                                    parentGroup = parentGroup.parentGroup;
                                }
                                each(parents.reverse(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">parentGroup</span>) </span>{
                                    <span class="hljs-keyword">var</span> htmlGroupStyle,
                                        cls = attr(parentGroup.element, <span class="hljs-string">'class'</span>);
                                    <span class="hljs-keyword">if</span> (cls) {
                                        cls = {
                                            <span class="hljs-attr">className</span>: cls
                                        };
                                    }
                                    htmlGroup = parentGroup.div = parentGroup.div || createElement(<span class="hljs-string">'div'</span>, cls, {
                                        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                                        <span class="hljs-attr">left</span>: (parentGroup.translateX || <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>,
                                        <span class="hljs-attr">top</span>: (parentGroup.translateY || <span class="hljs-number">0</span>) + <span class="hljs-string">'px'</span>,
                                        <span class="hljs-attr">display</span>: parentGroup.display,
                                        <span class="hljs-attr">opacity</span>: parentGroup.opacity,
                                        <span class="hljs-attr">pointerEvents</span>: parentGroup.styles &amp;&amp; parentGroup.styles.pointerEvents
                                    }, htmlGroup || container);
                                    htmlGroupStyle = htmlGroup.style;
                                    extend(parentGroup, {
                                        <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                            wrapper.on.apply({
                                                <span class="hljs-attr">element</span>: parents[<span class="hljs-number">0</span>].div
                                            }, <span class="hljs-built_in">arguments</span>);
                                            <span class="hljs-keyword">return</span> parentGroup;
                                        },
                                        <span class="hljs-attr">translateXSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                                            htmlGroupStyle.left = value + <span class="hljs-string">'px'</span>;
                                            parentGroup[key] = value;
                                            parentGroup.doTransform = <span class="hljs-literal">true</span>;
                                        },
                                        <span class="hljs-attr">translateYSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                                            htmlGroupStyle.top = value + <span class="hljs-string">'px'</span>;
                                            parentGroup[key] = value;
                                            parentGroup.doTransform = <span class="hljs-literal">true</span>;
                                        }
                                    });
                                    addSetters(parentGroup, htmlGroupStyle);
                                });
                            }
                        } <span class="hljs-keyword">else</span> {
                            htmlGroup = container;
                        }
                        htmlGroup.appendChild(element);
                        wrapper.added = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (wrapper.alignOnAdd) {
                            wrapper.htmlUpdateTransform();
                        }
                        <span class="hljs-keyword">return</span> wrapper;
                    };
                }
                <span class="hljs-keyword">return</span> wrapper;
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> VMLRenderer,
            VMLRendererExtension,
            VMLElement,
            createElement = H.createElement,
            css = H.css,
            defined = H.defined,
            deg2rad = H.deg2rad,
            discardElement = H.discardElement,
            doc = H.doc,
            each = H.each,
            erase = H.erase,
            extend = H.extend,
            extendClass = H.extendClass,
            isArray = H.isArray,
            isNumber = H.isNumber,
            isObject = H.isObject,
            merge = H.merge,
            noop = H.noop,
            pick = H.pick,
            pInt = H.pInt,
            svg = H.svg,
            SVGElement = H.SVGElement,
            SVGRenderer = H.SVGRenderer,
            win = H.win;
        <span class="hljs-keyword">if</span> (!svg) {
            VMLElement = {
                <span class="hljs-attr">docMode8</span>: doc &amp;&amp; doc.documentMode === <span class="hljs-number">8</span>,
                <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">renderer, nodeName</span>) </span>{
                    <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                        markup = [<span class="hljs-string">'&lt;'</span>, nodeName, <span class="hljs-string">' filled="f" stroked="f"'</span>],
                        style = [<span class="hljs-string">'position: '</span>, <span class="hljs-string">'absolute'</span>, <span class="hljs-string">';'</span>],
                        isDiv = nodeName === <span class="hljs-string">'div'</span>;
                    <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">'shape'</span> || isDiv) {
                        style.push(<span class="hljs-string">'left:0;top:0;width:1px;height:1px;'</span>);
                    }
                    style.push(<span class="hljs-string">'visibility: '</span>, isDiv ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'visible'</span>);
                    markup.push(<span class="hljs-string">' style="'</span>, style.join(<span class="hljs-string">''</span>), <span class="hljs-string">'"/&gt;'</span>);
                    <span class="hljs-keyword">if</span> (nodeName) {
                        markup = isDiv || nodeName === <span class="hljs-string">'span'</span> || nodeName === <span class="hljs-string">'img'</span> ?
                            markup.join(<span class="hljs-string">''</span>) :
                            renderer.prepVML(markup);
                        wrapper.element = createElement(markup);
                    }
                    wrapper.renderer = renderer;
                },
                <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">parent</span>) </span>{
                    <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                        renderer = wrapper.renderer,
                        element = wrapper.element,
                        box = renderer.box,
                        inverted = parent &amp;&amp; parent.inverted,
                        parentNode = parent ?
                        parent.element || parent :
                        box;
                    <span class="hljs-keyword">if</span> (parent) {
                        <span class="hljs-keyword">this</span>.parentGroup = parent;
                    }
                    <span class="hljs-keyword">if</span> (inverted) {
                        renderer.invertChild(element, parentNode);
                    }
                    parentNode.appendChild(element);
                    wrapper.added = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">if</span> (wrapper.alignOnAdd &amp;&amp; !wrapper.deferUpdateTransform) {
                        wrapper.updateTransform();
                    }
                    <span class="hljs-keyword">if</span> (wrapper.onAdd) {
                        wrapper.onAdd();
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.className) {
                        <span class="hljs-keyword">this</span>.attr(<span class="hljs-string">'class'</span>, <span class="hljs-keyword">this</span>.className);
                    }
                    <span class="hljs-keyword">return</span> wrapper;
                },
                <span class="hljs-attr">updateTransform</span>: SVGElement.prototype.htmlUpdateTransform,
                <span class="hljs-attr">setSpanRotation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> rotation = <span class="hljs-keyword">this</span>.rotation,
                        costheta = <span class="hljs-built_in">Math</span>.cos(rotation * deg2rad),
                        sintheta = <span class="hljs-built_in">Math</span>.sin(rotation * deg2rad);
                    css(<span class="hljs-keyword">this</span>.element, {
                        <span class="hljs-attr">filter</span>: rotation ? [<span class="hljs-string">'progid:DXImageTransform.Microsoft.Matrix(M11='</span>, costheta,
                            <span class="hljs-string">', M12='</span>, -sintheta, <span class="hljs-string">', M21='</span>, sintheta, <span class="hljs-string">', M22='</span>, costheta,
                            <span class="hljs-string">', sizingMethod=\'auto expand\')'</span>
                        ].join(<span class="hljs-string">''</span>) : <span class="hljs-string">'none'</span>
                    });
                },
                <span class="hljs-attr">getSpanCorrection</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, baseline, alignCorrection, rotation, align</span>) </span>{
                    <span class="hljs-keyword">var</span> costheta = rotation ? <span class="hljs-built_in">Math</span>.cos(rotation * deg2rad) : <span class="hljs-number">1</span>,
                        sintheta = rotation ? <span class="hljs-built_in">Math</span>.sin(rotation * deg2rad) : <span class="hljs-number">0</span>,
                        height = pick(<span class="hljs-keyword">this</span>.elemHeight, <span class="hljs-keyword">this</span>.element.offsetHeight),
                        quad,
                        nonLeft = align &amp;&amp; align !== <span class="hljs-string">'left'</span>;
                    <span class="hljs-keyword">this</span>.xCorr = costheta &lt; <span class="hljs-number">0</span> &amp;&amp; -width;
                    <span class="hljs-keyword">this</span>.yCorr = sintheta &lt; <span class="hljs-number">0</span> &amp;&amp; -height;
                    quad = costheta * sintheta &lt; <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">this</span>.xCorr += sintheta * baseline * (quad ? <span class="hljs-number">1</span> - alignCorrection : alignCorrection);
                    <span class="hljs-keyword">this</span>.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : <span class="hljs-number">1</span> - alignCorrection) : <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">if</span> (nonLeft) {
                        <span class="hljs-keyword">this</span>.xCorr -= width * alignCorrection * (costheta &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (rotation) {
                            <span class="hljs-keyword">this</span>.yCorr -= height * alignCorrection * (sintheta &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
                        }
                        css(<span class="hljs-keyword">this</span>.element, {
                            <span class="hljs-attr">textAlign</span>: align
                        });
                    }
                },
                <span class="hljs-attr">pathToVML</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">var</span> i = value.length,
                        path = [];
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (isNumber(value[i])) {
                            path[i] = <span class="hljs-built_in">Math</span>.round(value[i] * <span class="hljs-number">10</span>) - <span class="hljs-number">5</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value[i] === <span class="hljs-string">'Z'</span>) {
                            path[i] = <span class="hljs-string">'x'</span>;
                        } <span class="hljs-keyword">else</span> {
                            path[i] = value[i];
                            <span class="hljs-keyword">if</span> (value.isArc &amp;&amp; (value[i] === <span class="hljs-string">'wa'</span> || value[i] === <span class="hljs-string">'at'</span>)) {
                                <span class="hljs-keyword">if</span> (path[i + <span class="hljs-number">5</span>] === path[i + <span class="hljs-number">7</span>]) {
                                    path[i + <span class="hljs-number">7</span>] += value[i + <span class="hljs-number">7</span>] &gt; value[i + <span class="hljs-number">5</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
                                }
                                <span class="hljs-keyword">if</span> (path[i + <span class="hljs-number">6</span>] === path[i + <span class="hljs-number">8</span>]) {
                                    path[i + <span class="hljs-number">8</span>] += value[i + <span class="hljs-number">8</span>] &gt; value[i + <span class="hljs-number">6</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
                                }
                            }
                        }
                    }
                    <span class="hljs-keyword">return</span> path.join(<span class="hljs-string">' '</span>) || <span class="hljs-string">'x'</span>;
                },
                <span class="hljs-attr">clip</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">clipRect</span>) </span>{
                    <span class="hljs-keyword">var</span> wrapper = <span class="hljs-keyword">this</span>,
                        clipMembers,
                        cssRet;
                    <span class="hljs-keyword">if</span> (clipRect) {
                        clipMembers = clipRect.members;
                        erase(clipMembers, wrapper);
                        clipMembers.push(wrapper);
                        wrapper.destroyClip = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            erase(clipMembers, wrapper);
                        };
                        cssRet = clipRect.getCSS(wrapper);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (wrapper.destroyClip) {
                            wrapper.destroyClip();
                        }
                        cssRet = {
                            <span class="hljs-attr">clip</span>: wrapper.docMode8 ? <span class="hljs-string">'inherit'</span> : <span class="hljs-string">'rect(auto)'</span>
                        };
                    }
                    <span class="hljs-keyword">return</span> wrapper.css(cssRet);
                },
                <span class="hljs-attr">css</span>: SVGElement.prototype.htmlCss,
                <span class="hljs-attr">safeRemoveChild</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
                    <span class="hljs-keyword">if</span> (element.parentNode) {
                        discardElement(element);
                    }
                },
                <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.destroyClip) {
                        <span class="hljs-keyword">this</span>.destroyClip();
                    }
                    <span class="hljs-keyword">return</span> SVGElement.prototype.destroy.apply(<span class="hljs-keyword">this</span>);
                },
                <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, handler</span>) </span>{
                    <span class="hljs-keyword">this</span>.element[<span class="hljs-string">'on'</span> + eventType] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">var</span> evt = win.event;
                        evt.target = evt.srcElement;
                        handler(evt);
                    };
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                },
                <span class="hljs-attr">cutOffPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path, length</span>) </span>{
                    <span class="hljs-keyword">var</span> len;
                    path = path.split(<span class="hljs-regexp">/[ ,]/</span>);
                    len = path.length;
                    <span class="hljs-keyword">if</span> (len === <span class="hljs-number">9</span> || len === <span class="hljs-number">11</span>) {
                        path[len - <span class="hljs-number">4</span>] = path[len - <span class="hljs-number">2</span>] = pInt(path[len - <span class="hljs-number">2</span>]) - <span class="hljs-number">10</span> * length;
                    }
                    <span class="hljs-keyword">return</span> path.join(<span class="hljs-string">' '</span>);
                },
                <span class="hljs-attr">shadow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shadowOptions, group, cutOff</span>) </span>{
                    <span class="hljs-keyword">var</span> shadows = [],
                        i,
                        element = <span class="hljs-keyword">this</span>.element,
                        renderer = <span class="hljs-keyword">this</span>.renderer,
                        shadow,
                        elemStyle = element.style,
                        markup,
                        path = element.path,
                        strokeWidth,
                        modifiedPath,
                        shadowWidth,
                        shadowElementOpacity;
                    <span class="hljs-keyword">if</span> (path &amp;&amp; <span class="hljs-keyword">typeof</span> path.value !== <span class="hljs-string">'string'</span>) {
                        path = <span class="hljs-string">'x'</span>;
                    }
                    modifiedPath = path;
                    <span class="hljs-keyword">if</span> (shadowOptions) {
                        shadowWidth = pick(shadowOptions.width, <span class="hljs-number">3</span>);
                        shadowElementOpacity = (shadowOptions.opacity || <span class="hljs-number">0.15</span>) / shadowWidth;
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) {
                            strokeWidth = (shadowWidth * <span class="hljs-number">2</span>) + <span class="hljs-number">1</span> - (<span class="hljs-number">2</span> * i);
                            <span class="hljs-keyword">if</span> (cutOff) {
                                modifiedPath = <span class="hljs-keyword">this</span>.cutOffPath(path.value, strokeWidth + <span class="hljs-number">0.5</span>);
                            }
                            markup = [<span class="hljs-string">'&lt;shape isShadow="true" strokeweight="'</span>, strokeWidth,
                                <span class="hljs-string">'" filled="false" path="'</span>, modifiedPath,
                                <span class="hljs-string">'" coordsize="10 10" style="'</span>, element.style.cssText, <span class="hljs-string">'" /&gt;'</span>
                            ];
                            shadow = createElement(renderer.prepVML(markup),
                                <span class="hljs-literal">null</span>, {
                                    <span class="hljs-attr">left</span>: pInt(elemStyle.left) + pick(shadowOptions.offsetX, <span class="hljs-number">1</span>),
                                    <span class="hljs-attr">top</span>: pInt(elemStyle.top) + pick(shadowOptions.offsetY, <span class="hljs-number">1</span>)
                                }
                            );
                            <span class="hljs-keyword">if</span> (cutOff) {
                                shadow.cutOff = strokeWidth + <span class="hljs-number">1</span>;
                            }
                            markup = [
                                <span class="hljs-string">'&lt;stroke color="'</span>,
                                shadowOptions.color || <span class="hljs-string">'#000000'</span>,
                                <span class="hljs-string">'" opacity="'</span>, shadowElementOpacity * i, <span class="hljs-string">'"/&gt;'</span>
                            ];
                            createElement(renderer.prepVML(markup), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, shadow);
                            <span class="hljs-keyword">if</span> (group) {
                                group.element.appendChild(shadow);
                            } <span class="hljs-keyword">else</span> {
                                element.parentNode.insertBefore(shadow, element);
                            }
                            shadows.push(shadow);
                        }
                        <span class="hljs-keyword">this</span>.shadows = shadows;
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
                },
                <span class="hljs-attr">updateShadows</span>: noop,
                <span class="hljs-attr">setAttr</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, value</span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.docMode8) {
                        <span class="hljs-keyword">this</span>.element[key] = value;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.element.setAttribute(key, value);
                    }
                },
                <span class="hljs-attr">classSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                    (<span class="hljs-keyword">this</span>.added ? <span class="hljs-keyword">this</span>.element : <span class="hljs-keyword">this</span>).className = value;
                },
                <span class="hljs-attr">dashstyleSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">var</span> strokeElem = element.getElementsByTagName(<span class="hljs-string">'stroke'</span>)[<span class="hljs-number">0</span>] ||
                        createElement(<span class="hljs-keyword">this</span>.renderer.prepVML([<span class="hljs-string">'&lt;stroke/&gt;'</span>]), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, element);
                    strokeElem[key] = value || <span class="hljs-string">'solid'</span>;
                    <span class="hljs-keyword">this</span>[key] = value;
                },
                <span class="hljs-attr">dSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">var</span> i,
                        shadows = <span class="hljs-keyword">this</span>.shadows;
                    value = value || [];
                    <span class="hljs-keyword">this</span>.d = value.join &amp;&amp; value.join(<span class="hljs-string">' '</span>);
                    element.path = value = <span class="hljs-keyword">this</span>.pathToVML(value);
                    <span class="hljs-keyword">if</span> (shadows) {
                        i = shadows.length;
                        <span class="hljs-keyword">while</span> (i--) {
                            shadows[i].path = shadows[i].cutOff ? <span class="hljs-keyword">this</span>.cutOffPath(value, shadows[i].cutOff) : value;
                        }
                    }
                    <span class="hljs-keyword">this</span>.setAttr(key, value);
                },
                <span class="hljs-attr">fillSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">var</span> nodeName = element.nodeName;
                    <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">'SPAN'</span>) {
                        element.style.color = value;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nodeName !== <span class="hljs-string">'IMG'</span>) {
                        element.filled = value !== <span class="hljs-string">'none'</span>;
                        <span class="hljs-keyword">this</span>.setAttr(<span class="hljs-string">'fillcolor'</span>, <span class="hljs-keyword">this</span>.renderer.color(value, element, key, <span class="hljs-keyword">this</span>));
                    }
                },
                <span class="hljs-string">'fill-opacitySetter'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    createElement(
                        <span class="hljs-keyword">this</span>.renderer.prepVML([<span class="hljs-string">'&lt;'</span>, key.split(<span class="hljs-string">'-'</span>)[<span class="hljs-number">0</span>], <span class="hljs-string">' opacity="'</span>, value, <span class="hljs-string">'"/&gt;'</span>]),
                        <span class="hljs-literal">null</span>,
                        <span class="hljs-literal">null</span>,
                        element
                    );
                },
                <span class="hljs-attr">opacitySetter</span>: noop,
                <span class="hljs-attr">rotationSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">var</span> style = element.style;
                    <span class="hljs-keyword">this</span>[key] = style[key] = value;
                    style.left = -<span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.sin(value * deg2rad) + <span class="hljs-number">1</span>) + <span class="hljs-string">'px'</span>;
                    style.top = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.cos(value * deg2rad)) + <span class="hljs-string">'px'</span>;
                },
                <span class="hljs-attr">strokeSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">this</span>.setAttr(<span class="hljs-string">'strokecolor'</span>, <span class="hljs-keyword">this</span>.renderer.color(value, element, key, <span class="hljs-keyword">this</span>));
                },
                <span class="hljs-string">'stroke-widthSetter'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    element.stroked = !!value;
                    <span class="hljs-keyword">this</span>[key] = value;
                    <span class="hljs-keyword">if</span> (isNumber(value)) {
                        value += <span class="hljs-string">'px'</span>;
                    }
                    <span class="hljs-keyword">this</span>.setAttr(<span class="hljs-string">'strokeweight'</span>, value);
                },
                <span class="hljs-attr">titleSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key</span>) </span>{
                    <span class="hljs-keyword">this</span>.setAttr(key, value);
                },
                <span class="hljs-attr">visibilitySetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">if</span> (value === <span class="hljs-string">'inherit'</span>) {
                        value = <span class="hljs-string">'visible'</span>;
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.shadows) {
                        each(<span class="hljs-keyword">this</span>.shadows, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shadow</span>) </span>{
                            shadow.style[key] = value;
                        });
                    }
                    <span class="hljs-keyword">if</span> (element.nodeName === <span class="hljs-string">'DIV'</span>) {
                        value = value === <span class="hljs-string">'hidden'</span> ? <span class="hljs-string">'-999em'</span> : <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.docMode8) {
                            element.style[key] = value ? <span class="hljs-string">'visible'</span> : <span class="hljs-string">'hidden'</span>;
                        }
                        key = <span class="hljs-string">'top'</span>;
                    }
                    element.style[key] = value;
                },
                <span class="hljs-attr">xSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    <span class="hljs-keyword">this</span>[key] = value;
                    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'x'</span>) {
                        key = <span class="hljs-string">'left'</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">'y'</span>) {
                        key = <span class="hljs-string">'top'</span>;
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.updateClipping) {
                        <span class="hljs-keyword">this</span>[key] = value;
                        <span class="hljs-keyword">this</span>.updateClipping();
                    } <span class="hljs-keyword">else</span> {
                        element.style[key] = value;
                    }
                },
                <span class="hljs-attr">zIndexSetter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, key, element</span>) </span>{
                    element.style[key] = value;
                }
            };
            VMLElement[<span class="hljs-string">'stroke-opacitySetter'</span>] = VMLElement[<span class="hljs-string">'fill-opacitySetter'</span>];
            H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);
            VMLElement.prototype.ySetter =
                VMLElement.prototype.widthSetter =
                VMLElement.prototype.heightSetter =
                VMLElement.prototype.xSetter;
            VMLRendererExtension = {
                <span class="hljs-attr">Element</span>: VMLElement,
                <span class="hljs-attr">isIE8</span>: win.navigator.userAgent.indexOf(<span class="hljs-string">'MSIE 8.0'</span>) &gt; <span class="hljs-number">-1</span>,
                <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">container, width, height</span>) </span>{
                    <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                        boxWrapper,
                        box,
                        css;
                    renderer.alignedObjects = [];
                    boxWrapper = renderer.createElement(<span class="hljs-string">'div'</span>)
                        .css({
                            <span class="hljs-attr">position</span>: <span class="hljs-string">'relative'</span>
                        });
                    box = boxWrapper.element;
                    container.appendChild(boxWrapper.element);
                    renderer.isVML = <span class="hljs-literal">true</span>;
                    renderer.box = box;
                    renderer.boxWrapper = boxWrapper;
                    renderer.gradients = {};
                    renderer.cache = {};
                    renderer.cacheKeys = [];
                    renderer.imgCount = <span class="hljs-number">0</span>;
                    renderer.setSize(width, height, <span class="hljs-literal">false</span>);
                    <span class="hljs-keyword">if</span> (!doc.namespaces.hcv) {
                        doc.namespaces.add(<span class="hljs-string">'hcv'</span>, <span class="hljs-string">'urn:schemas-microsoft-com:vml'</span>);
                        css = <span class="hljs-string">'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'</span> +
                            <span class="hljs-string">'{ behavior:url(#default#VML); display: inline-block; } '</span>;
                        <span class="hljs-keyword">try</span> {
                            doc.createStyleSheet().cssText = css;
                        } <span class="hljs-keyword">catch</span> (e) {
                            doc.styleSheets[<span class="hljs-number">0</span>].cssText += css;
                        }
                    }
                },
                <span class="hljs-attr">isHidden</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.box.offsetWidth;
                },
                <span class="hljs-attr">clipRect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, width, height</span>) </span>{
                    <span class="hljs-keyword">var</span> clipRect = <span class="hljs-keyword">this</span>.createElement(),
                        isObj = isObject(x);
                    <span class="hljs-keyword">return</span> extend(clipRect, {
                        <span class="hljs-attr">members</span>: [],
                        <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">left</span>: (isObj ? x.x : x) + <span class="hljs-number">1</span>,
                        <span class="hljs-attr">top</span>: (isObj ? x.y : y) + <span class="hljs-number">1</span>,
                        <span class="hljs-attr">width</span>: (isObj ? x.width : width) - <span class="hljs-number">1</span>,
                        <span class="hljs-attr">height</span>: (isObj ? x.height : height) - <span class="hljs-number">1</span>,
                        <span class="hljs-attr">getCSS</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">wrapper</span>) </span>{
                            <span class="hljs-keyword">var</span> element = wrapper.element,
                                nodeName = element.nodeName,
                                isShape = nodeName === <span class="hljs-string">'shape'</span>,
                                inverted = wrapper.inverted,
                                rect = <span class="hljs-keyword">this</span>,
                                top = rect.top - (isShape ? element.offsetTop : <span class="hljs-number">0</span>),
                                left = rect.left,
                                right = left + rect.width,
                                bottom = top + rect.height,
                                ret = {
                                    <span class="hljs-attr">clip</span>: <span class="hljs-string">'rect('</span> +
                                        <span class="hljs-built_in">Math</span>.round(inverted ? left : top) + <span class="hljs-string">'px,'</span> +
                                        <span class="hljs-built_in">Math</span>.round(inverted ? bottom : right) + <span class="hljs-string">'px,'</span> +
                                        <span class="hljs-built_in">Math</span>.round(inverted ? right : bottom) + <span class="hljs-string">'px,'</span> +
                                        <span class="hljs-built_in">Math</span>.round(inverted ? top : left) + <span class="hljs-string">'px)'</span>
                                };
                            <span class="hljs-keyword">if</span> (!inverted &amp;&amp; wrapper.docMode8 &amp;&amp; nodeName === <span class="hljs-string">'DIV'</span>) {
                                extend(ret, {
                                    <span class="hljs-attr">width</span>: right + <span class="hljs-string">'px'</span>,
                                    <span class="hljs-attr">height</span>: bottom + <span class="hljs-string">'px'</span>
                                });
                            }
                            <span class="hljs-keyword">return</span> ret;
                        },
                        <span class="hljs-attr">updateClipping</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            each(clipRect.members, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">member</span>) </span>{
                                <span class="hljs-keyword">if</span> (member.element) {
                                    member.css(clipRect.getCSS(member));
                                }
                            });
                        }
                    });
                },
                <span class="hljs-attr">color</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">color, elem, prop, wrapper</span>) </span>{
                    <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>,
                        colorObject,
                        regexRgba = <span class="hljs-regexp">/^rgba/</span>,
                        markup,
                        fillType,
                        ret = <span class="hljs-string">'none'</span>;
                    <span class="hljs-keyword">if</span> (color &amp;&amp; color.linearGradient) {
                        fillType = <span class="hljs-string">'gradient'</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color &amp;&amp; color.radialGradient) {
                        fillType = <span class="hljs-string">'pattern'</span>;
                    }
                    <span class="hljs-keyword">if</span> (fillType) {
                        <span class="hljs-keyword">var</span> stopColor,
                            stopOpacity,
                            gradient = color.linearGradient || color.radialGradient,
                            x1,
                            y1,
                            x2,
                            y2,
                            opacity1,
                            opacity2,
                            color1,
                            color2,
                            fillAttr = <span class="hljs-string">''</span>,
                            stops = color.stops,
                            firstStop,
                            lastStop,
                            colors = [],
                            addFillNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                markup = [<span class="hljs-string">'&lt;fill colors="'</span> + colors.join(<span class="hljs-string">','</span>) +
                                    <span class="hljs-string">'" opacity="'</span>, opacity2, <span class="hljs-string">'" o:opacity2="'</span>,
                                    opacity1, <span class="hljs-string">'" type="'</span>, fillType, <span class="hljs-string">'" '</span>, fillAttr,
                                    <span class="hljs-string">'focus="100%" method="any" /&gt;'</span>
                                ];
                                createElement(renderer.prepVML(markup), <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, elem);
                            };
                        firstStop = stops[<span class="hljs-number">0</span>];
                        lastStop = stops[stops.length - <span class="hljs-number">1</span>];
                        <span class="hljs-keyword">if</span> (firstStop[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span>) {
                            stops.unshift([
                                <span class="hljs-number">0</span>,
                                firstStop[<span class="hljs-number">1</span>]
                            ]);
                        }
                        <span class="hljs-keyword">if</span> (lastStop[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">1</span>) {
                            stops.push([
                                <span class="hljs-number">1</span>,
                                lastStop[<span class="hljs-number">1</span>]
                            ]);
                        }
                        each(stops, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stop, i</span>) </span>{
                            <span class="hljs-keyword">if</span> (regexRgba.test(stop[<span class="hljs-number">1</span>])) {
                                colorObject = H.color(stop[<span class="hljs-number">1</span>]);
                                stopColor = colorObject.get(<span class="hljs-string">'rgb'</span>);
                                stopOpacity = colorObject.get(<span class="hljs-string">'a'</span>);
                            } <span class="hljs-keyword">else</span> {
                                stopColor = stop[<span class="hljs-number">1</span>];
                                stopOpacity = <span class="hljs-number">1</span>;
                            }
                            colors.push((stop[<span class="hljs-number">0</span>] * <span class="hljs-number">100</span>) + <span class="hljs-string">'% '</span> + stopColor);
                            <span class="hljs-keyword">if</span> (!i) {
                                opacity1 = stopOpacity;
                                color2 = stopColor;
                            } <span class="hljs-keyword">else</span> {
                                opacity2 = stopOpacity;
                                color1 = stopColor;
                            }
                        });
                        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">'fill'</span>) {
                            <span class="hljs-keyword">if</span> (fillType === <span class="hljs-string">'gradient'</span>) {
                                x1 = gradient.x1 || gradient[<span class="hljs-number">0</span>] || <span class="hljs-number">0</span>;
                                y1 = gradient.y1 || gradient[<span class="hljs-number">1</span>] || <span class="hljs-number">0</span>;
                                x2 = gradient.x2 || gradient[<span class="hljs-number">2</span>] || <span class="hljs-number">0</span>;
                                y2 = gradient.y2 || gradient[<span class="hljs-number">3</span>] || <span class="hljs-number">0</span>;
                                fillAttr = <span class="hljs-string">'angle="'</span> + (<span class="hljs-number">90</span> - <span class="hljs-built_in">Math</span>.atan(
                                    (y2 - y1) /
                                    (x2 - x1)
                                ) * <span class="hljs-number">180</span> / <span class="hljs-built_in">Math</span>.PI) + <span class="hljs-string">'"'</span>;
                                addFillNode();
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">var</span> r = gradient.r,
                                    sizex = r * <span class="hljs-number">2</span>,
                                    sizey = r * <span class="hljs-number">2</span>,
                                    cx = gradient.cx,
                                    cy = gradient.cy,
                                    radialReference = elem.radialReference,
                                    bBox,
                                    applyRadialGradient = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                        <span class="hljs-keyword">if</span> (radialReference) {
                                            bBox = wrapper.getBBox();
                                            cx += (radialReference[<span class="hljs-number">0</span>] - bBox.x) / bBox.width - <span class="hljs-number">0.5</span>;
                                            cy += (radialReference[<span class="hljs-number">1</span>] - bBox.y) / bBox.height - <span class="hljs-number">0.5</span>;
                                            sizex *= radialReference[<span class="hljs-number">2</span>] / bBox.width;
                                            sizey *= radialReference[<span class="hljs-number">2</span>] / bBox.height;
                                        }
                                        fillAttr = <span class="hljs-string">'src="'</span> + H.getOptions().global.VMLRadialGradientURL + <span class="hljs-string">'" '</span> +
                                            <span class="hljs-string">'size="'</span> + sizex + <span class="hljs-string">','</span> + sizey + <span class="hljs-string">'" '</span> +
                                            <span class="hljs-string">'origin="0.5,0.5" '</span> +
                                            <span class="hljs-string">'position="'</span> + cx + <span class="hljs-string">','</span> + cy + <span class="hljs-string">'" '</span> +
                                            <span class="hljs-string">'color2="'</span> + color2 + <span class="hljs-string">'" '</span>;
                                        addFillNode();
                                    };
                                <span class="hljs-keyword">if</span> (wrapper.added) {
                                    applyRadialGradient();
                                } <span class="hljs-keyword">else</span> {
                                    wrapper.onAdd = applyRadialGradient;
                                }
                                ret = color1;
                            }
                        } <span class="hljs-keyword">else</span> {
                            ret = stopColor;
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regexRgba.test(color) &amp;&amp; elem.tagName !== <span class="hljs-string">'IMG'</span>) {
                        colorObject = H.color(color);
                        wrapper[prop + <span class="hljs-string">'-opacitySetter'</span>](colorObject.get(<span class="hljs-string">'a'</span>), prop, elem);
                        ret = colorObject.get(<span class="hljs-string">'rgb'</span>);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">var</span> propNodes = elem.getElementsByTagName(prop);
                        <span class="hljs-keyword">if</span> (propNodes.length) {
                            propNodes[<span class="hljs-number">0</span>].opacity = <span class="hljs-number">1</span>;
                            propNodes[<span class="hljs-number">0</span>].type = <span class="hljs-string">'solid'</span>;
                        }
                        ret = color;
                    }
                    <span class="hljs-keyword">return</span> ret;
                },
                <span class="hljs-attr">prepVML</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">markup</span>) </span>{
                    <span class="hljs-keyword">var</span> vmlStyle = <span class="hljs-string">'display:inline-block;behavior:url(#default#VML);'</span>,
                        isIE8 = <span class="hljs-keyword">this</span>.isIE8;
                    markup = markup.join(<span class="hljs-string">''</span>);
                    <span class="hljs-keyword">if</span> (isIE8) {
                        markup = markup.replace(<span class="hljs-string">'/&gt;'</span>, <span class="hljs-string">' xmlns="urn:schemas-microsoft-com:vml" /&gt;'</span>);
                        <span class="hljs-keyword">if</span> (markup.indexOf(<span class="hljs-string">'style="'</span>) === <span class="hljs-number">-1</span>) {
                            markup = markup.replace(<span class="hljs-string">'/&gt;'</span>, <span class="hljs-string">' style="'</span> + vmlStyle + <span class="hljs-string">'" /&gt;'</span>);
                        } <span class="hljs-keyword">else</span> {
                            markup = markup.replace(<span class="hljs-string">'style="'</span>, <span class="hljs-string">'style="'</span> + vmlStyle);
                        }
                    } <span class="hljs-keyword">else</span> {
                        markup = markup.replace(<span class="hljs-string">'&lt;'</span>, <span class="hljs-string">'&lt;hcv:'</span>);
                    }
                    <span class="hljs-keyword">return</span> markup;
                },
                <span class="hljs-attr">text</span>: SVGRenderer.prototype.html,
                <span class="hljs-attr">path</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path</span>) </span>{
                    <span class="hljs-keyword">var</span> attr = {
                        <span class="hljs-attr">coordsize</span>: <span class="hljs-string">'10 10'</span>
                    };
                    <span class="hljs-keyword">if</span> (isArray(path)) {
                        attr.d = path;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(path)) {
                        extend(attr, path);
                    }
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'shape'</span>).attr(attr);
                },
                <span class="hljs-attr">circle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, r</span>) </span>{
                    <span class="hljs-keyword">var</span> circle = <span class="hljs-keyword">this</span>.symbol(<span class="hljs-string">'circle'</span>);
                    <span class="hljs-keyword">if</span> (isObject(x)) {
                        r = x.r;
                        y = x.y;
                        x = x.x;
                    }
                    circle.isCircle = <span class="hljs-literal">true</span>;
                    circle.r = r;
                    <span class="hljs-keyword">return</span> circle.attr({
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">y</span>: y
                    });
                },
                <span class="hljs-attr">g</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                    <span class="hljs-keyword">var</span> wrapper,
                        attribs;
                    <span class="hljs-keyword">if</span> (name) {
                        attribs = {
                            <span class="hljs-string">'className'</span>: <span class="hljs-string">'highcharts-'</span> + name,
                            <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-'</span> + name
                        };
                    }
                    wrapper = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'div'</span>).attr(attribs);
                    <span class="hljs-keyword">return</span> wrapper;
                },
                <span class="hljs-attr">image</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src, x, y, width, height</span>) </span>{
                    <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">this</span>.createElement(<span class="hljs-string">'img'</span>)
                        .attr({
                            <span class="hljs-attr">src</span>: src
                        });
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">1</span>) {
                        obj.attr({
                            <span class="hljs-attr">x</span>: x,
                            <span class="hljs-attr">y</span>: y,
                            <span class="hljs-attr">width</span>: width,
                            <span class="hljs-attr">height</span>: height
                        });
                    }
                    <span class="hljs-keyword">return</span> obj;
                },
                <span class="hljs-attr">createElement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nodeName</span>) </span>{
                    <span class="hljs-keyword">return</span> nodeName === <span class="hljs-string">'rect'</span> ?
                        <span class="hljs-keyword">this</span>.symbol(nodeName) :
                        SVGRenderer.prototype.createElement.call(<span class="hljs-keyword">this</span>, nodeName);
                },
                <span class="hljs-attr">invertChild</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, parentNode</span>) </span>{
                    <span class="hljs-keyword">var</span> ren = <span class="hljs-keyword">this</span>,
                        parentStyle = parentNode.style,
                        imgStyle = element.tagName === <span class="hljs-string">'IMG'</span> &amp;&amp; element.style;
                    css(element, {
                        <span class="hljs-attr">flip</span>: <span class="hljs-string">'x'</span>,
                        <span class="hljs-attr">left</span>: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : <span class="hljs-number">1</span>),
                        <span class="hljs-attr">top</span>: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : <span class="hljs-number">1</span>),
                        <span class="hljs-attr">rotation</span>: <span class="hljs-number">-90</span>
                    });
                    each(element.childNodes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
                        ren.invertChild(child, element);
                    });
                },
                <span class="hljs-attr">symbols</span>: {
                    <span class="hljs-attr">arc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
                        <span class="hljs-keyword">var</span> start = options.start,
                            end = options.end,
                            radius = options.r || w || h,
                            innerRadius = options.innerR,
                            cosStart = <span class="hljs-built_in">Math</span>.cos(start),
                            sinStart = <span class="hljs-built_in">Math</span>.sin(start),
                            cosEnd = <span class="hljs-built_in">Math</span>.cos(end),
                            sinEnd = <span class="hljs-built_in">Math</span>.sin(end),
                            ret;
                        <span class="hljs-keyword">if</span> (end - start === <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">return</span> [<span class="hljs-string">'x'</span>];
                        }
                        ret = [
                            <span class="hljs-string">'wa'</span>,
                            x - radius,
                            y - radius,
                            x + radius,
                            y + radius,
                            x + radius * cosStart,
                            y + radius * sinStart,
                            x + radius * cosEnd,
                            y + radius * sinEnd
                        ];
                        <span class="hljs-keyword">if</span> (options.open &amp;&amp; !innerRadius) {
                            ret.push(
                                <span class="hljs-string">'e'</span>,
                                <span class="hljs-string">'M'</span>,
                                x,
                                y
                            );
                        }
                        ret.push(
                            <span class="hljs-string">'at'</span>,
                            x - innerRadius,
                            y - innerRadius,
                            x + innerRadius,
                            y + innerRadius,
                            x + innerRadius * cosEnd,
                            y + innerRadius * sinEnd,
                            x + innerRadius * cosStart,
                            y + innerRadius * sinStart,
                            <span class="hljs-string">'x'</span>,
                            <span class="hljs-string">'e'</span>
                        );
                        ret.isArc = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">return</span> ret;
                    },
                    <span class="hljs-attr">circle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, wrapper</span>) </span>{
                        <span class="hljs-keyword">if</span> (wrapper &amp;&amp; defined(wrapper.r)) {
                            w = h = <span class="hljs-number">2</span> * wrapper.r;
                        }
                        <span class="hljs-keyword">if</span> (wrapper &amp;&amp; wrapper.isCircle) {
                            x -= w / <span class="hljs-number">2</span>;
                            y -= h / <span class="hljs-number">2</span>;
                        }
                        <span class="hljs-keyword">return</span> [
                            <span class="hljs-string">'wa'</span>,
                            x,
                            y,
                            x + w,
                            y + h,
                            x + w,
                            y + h / <span class="hljs-number">2</span>,
                            x + w,
                            y + h / <span class="hljs-number">2</span>,
                            <span class="hljs-string">'e'</span>
                        ];
                    },
                    <span class="hljs-attr">rect</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
                        <span class="hljs-keyword">return</span> SVGRenderer.prototype.symbols[!defined(options) || !options.r ? <span class="hljs-string">'square'</span> : <span class="hljs-string">'callout'</span>].call(<span class="hljs-number">0</span>, x, y, w, h, options);
                    }
                }
            };
            H.VMLRenderer = VMLRenderer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
            };
            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);
            H.Renderer = VMLRenderer;
        }
        SVGRenderer.prototype.measureSpanWidth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text, styles</span>) </span>{
            <span class="hljs-keyword">var</span> measuringSpan = doc.createElement(<span class="hljs-string">'span'</span>),
                offsetWidth,
                textNode = doc.createTextNode(text);
            measuringSpan.appendChild(textNode);
            css(measuringSpan, styles);
            <span class="hljs-keyword">this</span>.box.appendChild(measuringSpan);
            offsetWidth = measuringSpan.offsetWidth;
            discardElement(measuringSpan);
            <span class="hljs-keyword">return</span> offsetWidth;
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> color = H.color,
            each = H.each,
            getTZOffset = H.getTZOffset,
            isTouchDevice = H.isTouchDevice,
            merge = H.merge,
            pick = H.pick,
            svg = H.svg,
            win = H.win;
        H.defaultOptions = {
            <span class="hljs-attr">colors</span>: <span class="hljs-string">'#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'</span>.split(<span class="hljs-string">' '</span>),
            <span class="hljs-attr">symbols</span>: [<span class="hljs-string">'circle'</span>, <span class="hljs-string">'diamond'</span>, <span class="hljs-string">'square'</span>, <span class="hljs-string">'triangle'</span>, <span class="hljs-string">'triangle-down'</span>],
            <span class="hljs-attr">lang</span>: {
                <span class="hljs-attr">loading</span>: <span class="hljs-string">'Loading...'</span>,
                <span class="hljs-attr">months</span>: [
                    <span class="hljs-string">'January'</span>, <span class="hljs-string">'February'</span>, <span class="hljs-string">'March'</span>, <span class="hljs-string">'April'</span>, <span class="hljs-string">'May'</span>, <span class="hljs-string">'June'</span>, <span class="hljs-string">'July'</span>,
                    <span class="hljs-string">'August'</span>, <span class="hljs-string">'September'</span>, <span class="hljs-string">'October'</span>, <span class="hljs-string">'November'</span>, <span class="hljs-string">'December'</span>
                ],
                <span class="hljs-attr">shortMonths</span>: [
                    <span class="hljs-string">'Jan'</span>, <span class="hljs-string">'Feb'</span>, <span class="hljs-string">'Mar'</span>, <span class="hljs-string">'Apr'</span>, <span class="hljs-string">'May'</span>, <span class="hljs-string">'Jun'</span>, <span class="hljs-string">'Jul'</span>,
                    <span class="hljs-string">'Aug'</span>, <span class="hljs-string">'Sep'</span>, <span class="hljs-string">'Oct'</span>, <span class="hljs-string">'Nov'</span>, <span class="hljs-string">'Dec'</span>
                ],
                <span class="hljs-attr">weekdays</span>: [
                    <span class="hljs-string">'Sunday'</span>, <span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>,
                    <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>, <span class="hljs-string">'Saturday'</span>
                ],
                <span class="hljs-attr">decimalPoint</span>: <span class="hljs-string">'.'</span>,
                <span class="hljs-attr">numericSymbols</span>: [<span class="hljs-string">'k'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'E'</span>],
                <span class="hljs-attr">resetZoom</span>: <span class="hljs-string">'Reset zoom'</span>,
                <span class="hljs-attr">resetZoomTitle</span>: <span class="hljs-string">'Reset zoom level 1:1'</span>,
                <span class="hljs-attr">thousandsSep</span>: <span class="hljs-string">' '</span>
            },
            <span class="hljs-attr">global</span>: {
                <span class="hljs-attr">useUTC</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">VMLRadialGradientURL</span>: <span class="hljs-string">'http://code.highcharts.com/5.0.7/gfx/vml-radial-gradient.png'</span>
            },
            <span class="hljs-attr">chart</span>: {
                <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">defaultSeriesType</span>: <span class="hljs-string">'line'</span>,
                <span class="hljs-attr">ignoreHiddenSeries</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">spacing</span>: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>],
                <span class="hljs-attr">resetZoomButton</span>: {
                    <span class="hljs-attr">theme</span>: {
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">20</span>
                    },
                    <span class="hljs-attr">position</span>: {
                        <span class="hljs-attr">align</span>: <span class="hljs-string">'right'</span>,
                        <span class="hljs-attr">x</span>: <span class="hljs-number">-10</span>,
                        <span class="hljs-attr">y</span>: <span class="hljs-number">10</span>
                    }
                },
                <span class="hljs-attr">width</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">height</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#335cad'</span>,
                <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#ffffff'</span>,
                <span class="hljs-attr">plotBorderColor</span>: <span class="hljs-string">'#cccccc'</span>
            },
            <span class="hljs-attr">title</span>: {
                <span class="hljs-attr">text</span>: <span class="hljs-string">'Chart title'</span>,
                <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
                <span class="hljs-attr">margin</span>: <span class="hljs-number">15</span>,
                <span class="hljs-attr">widthAdjust</span>: <span class="hljs-number">-44</span>
            },
            <span class="hljs-attr">subtitle</span>: {
                <span class="hljs-attr">text</span>: <span class="hljs-string">''</span>,
                <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
                <span class="hljs-attr">widthAdjust</span>: <span class="hljs-number">-44</span>
            },
            <span class="hljs-attr">plotOptions</span>: {},
            <span class="hljs-attr">labels</span>: {
                <span class="hljs-attr">style</span>: {
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>
                }
            },
            <span class="hljs-attr">legend</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
                <span class="hljs-attr">layout</span>: <span class="hljs-string">'horizontal'</span>,
                <span class="hljs-attr">labelFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
                },
                <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#999999'</span>,
                <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">navigation</span>: {
                    <span class="hljs-attr">activeColor</span>: <span class="hljs-string">'#003399'</span>,
                    <span class="hljs-attr">inactiveColor</span>: <span class="hljs-string">'#cccccc'</span>
                },
                <span class="hljs-attr">itemStyle</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>,
                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'12px'</span>,
                    <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>
                },
                <span class="hljs-attr">itemHoverStyle</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>
                },
                <span class="hljs-attr">itemHiddenStyle</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#cccccc'</span>
                },
                <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">itemCheckboxStyle</span>: {
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                    <span class="hljs-attr">width</span>: <span class="hljs-string">'13px'</span>,
                    <span class="hljs-attr">height</span>: <span class="hljs-string">'13px'</span>
                },
                <span class="hljs-attr">squareSymbol</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">symbolPadding</span>: <span class="hljs-number">5</span>,
                <span class="hljs-attr">verticalAlign</span>: <span class="hljs-string">'bottom'</span>,
                <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>
                    }
                }
            },
            <span class="hljs-attr">loading</span>: {
                <span class="hljs-attr">labelStyle</span>: {
                    <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>,
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'relative'</span>,
                    <span class="hljs-attr">top</span>: <span class="hljs-string">'45%'</span>
                },
                <span class="hljs-attr">style</span>: {
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#ffffff'</span>,
                    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,
                    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>
                }
            },
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">animation</span>: svg,
                <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">3</span>,
                <span class="hljs-attr">dateTimeLabelFormats</span>: {
                    <span class="hljs-attr">millisecond</span>: <span class="hljs-string">'%A, %b %e, %H:%M:%S.%L'</span>,
                    <span class="hljs-attr">second</span>: <span class="hljs-string">'%A, %b %e, %H:%M:%S'</span>,
                    <span class="hljs-attr">minute</span>: <span class="hljs-string">'%A, %b %e, %H:%M'</span>,
                    <span class="hljs-attr">hour</span>: <span class="hljs-string">'%A, %b %e, %H:%M'</span>,
                    <span class="hljs-attr">day</span>: <span class="hljs-string">'%A, %b %e, %Y'</span>,
                    <span class="hljs-attr">week</span>: <span class="hljs-string">'Week from %A, %b %e, %Y'</span>,
                    <span class="hljs-attr">month</span>: <span class="hljs-string">'%B %Y'</span>,
                    <span class="hljs-attr">year</span>: <span class="hljs-string">'%Y'</span>
                },
                <span class="hljs-attr">footerFormat</span>: <span class="hljs-string">''</span>,
                <span class="hljs-attr">padding</span>: <span class="hljs-number">8</span>,
                <span class="hljs-attr">snap</span>: isTouchDevice ? <span class="hljs-number">25</span> : <span class="hljs-number">10</span>,
                <span class="hljs-attr">backgroundColor</span>: color(<span class="hljs-string">'#f7f7f7'</span>).setOpacity(<span class="hljs-number">0.85</span>).get(),
                <span class="hljs-attr">borderWidth</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">headerFormat</span>: <span class="hljs-string">'&lt;span style="font-size: 10px"&gt;{point.key}&lt;/span&gt;&lt;br/&gt;'</span>,
                <span class="hljs-attr">pointFormat</span>: <span class="hljs-string">'&lt;span style="color:{point.color}"&gt;\u25CF&lt;/span&gt; {series.name}: &lt;b&gt;{point.y}&lt;/b&gt;&lt;br/&gt;'</span>,
                <span class="hljs-attr">shadow</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">style</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>,
                    <span class="hljs-attr">cursor</span>: <span class="hljs-string">'default'</span>,
                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'12px'</span>,
                    <span class="hljs-attr">pointerEvents</span>: <span class="hljs-string">'none'</span>,
                    <span class="hljs-attr">whiteSpace</span>: <span class="hljs-string">'nowrap'</span>
                }
            },
            <span class="hljs-attr">credits</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">href</span>: <span class="hljs-string">'http://www.highcharts.com'</span>,
                <span class="hljs-attr">position</span>: {
                    <span class="hljs-attr">align</span>: <span class="hljs-string">'right'</span>,
                    <span class="hljs-attr">x</span>: <span class="hljs-number">-10</span>,
                    <span class="hljs-attr">verticalAlign</span>: <span class="hljs-string">'bottom'</span>,
                    <span class="hljs-attr">y</span>: <span class="hljs-number">-5</span>
                },
                <span class="hljs-attr">style</span>: {
                    <span class="hljs-attr">cursor</span>: <span class="hljs-string">'pointer'</span>,
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#999999'</span>,
                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'9px'</span>
                },
                <span class="hljs-attr">text</span>: <span class="hljs-string">'Highcharts.com'</span>
            }
        };

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTimezoneOffsetOption</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> globalOptions = H.defaultOptions.global,
                moment = win.moment;
            <span class="hljs-keyword">if</span> (globalOptions.timezone) {
                <span class="hljs-keyword">if</span> (!moment) {
                    H.error(<span class="hljs-number">25</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">timestamp</span>) </span>{
                        <span class="hljs-keyword">return</span> -moment.tz(
                            timestamp,
                            globalOptions.timezone
                        ).utcOffset();
                    };
                }
            }
            <span class="hljs-keyword">return</span> globalOptions.useUTC &amp;&amp; globalOptions.getTimezoneOffset;
        }

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setTimeMethods</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> globalOptions = H.defaultOptions.global,
                <span class="hljs-built_in">Date</span>,
                useUTC = globalOptions.useUTC,
                GET = useUTC ? <span class="hljs-string">'getUTC'</span> : <span class="hljs-string">'get'</span>,
                SET = useUTC ? <span class="hljs-string">'setUTC'</span> : <span class="hljs-string">'set'</span>;
            H.Date = <span class="hljs-built_in">Date</span> = globalOptions.Date || win.Date;
            <span class="hljs-built_in">Date</span>.hcTimezoneOffset = useUTC &amp;&amp; globalOptions.timezoneOffset;
            <span class="hljs-built_in">Date</span>.hcGetTimezoneOffset = getTimezoneOffsetOption();
            <span class="hljs-built_in">Date</span>.hcMakeTime = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">year, month, date, hours, minutes, seconds</span>) </span>{
                <span class="hljs-keyword">var</span> d;
                <span class="hljs-keyword">if</span> (useUTC) {
                    d = <span class="hljs-built_in">Date</span>.UTC.apply(<span class="hljs-number">0</span>, <span class="hljs-built_in">arguments</span>);
                    d += getTZOffset(d);
                } <span class="hljs-keyword">else</span> {
                    d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(
                        year,
                        month,
                        pick(date, <span class="hljs-number">1</span>),
                        pick(hours, <span class="hljs-number">0</span>),
                        pick(minutes, <span class="hljs-number">0</span>),
                        pick(seconds, <span class="hljs-number">0</span>)
                    ).getTime();
                }
                <span class="hljs-keyword">return</span> d;
            };
            each([<span class="hljs-string">'Minutes'</span>, <span class="hljs-string">'Hours'</span>, <span class="hljs-string">'Day'</span>, <span class="hljs-string">'Date'</span>, <span class="hljs-string">'Month'</span>, <span class="hljs-string">'FullYear'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                <span class="hljs-built_in">Date</span>[<span class="hljs-string">'hcGet'</span> + s] = GET + s;
            });
            each([<span class="hljs-string">'Milliseconds'</span>, <span class="hljs-string">'Seconds'</span>, <span class="hljs-string">'Minutes'</span>, <span class="hljs-string">'Hours'</span>, <span class="hljs-string">'Date'</span>, <span class="hljs-string">'Month'</span>, <span class="hljs-string">'FullYear'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                <span class="hljs-built_in">Date</span>[<span class="hljs-string">'hcSet'</span> + s] = SET + s;
            });
        }
        H.setOptions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
            H.defaultOptions = merge(<span class="hljs-literal">true</span>, H.defaultOptions, options);
            setTimeMethods();
            <span class="hljs-keyword">return</span> H.defaultOptions;
        };
        H.getOptions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> H.defaultOptions;
        };
        H.defaultPlotOptions = H.defaultOptions.plotOptions;
        setTimeMethods();
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> arrayMax = H.arrayMax,
            arrayMin = H.arrayMin,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            each = H.each,
            erase = H.erase,
            merge = H.merge,
            pick = H.pick;
        H.PlotLineOrBand = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, options</span>) </span>{
            <span class="hljs-keyword">this</span>.axis = axis;
            <span class="hljs-keyword">if</span> (options) {
                <span class="hljs-keyword">this</span>.options = options;
                <span class="hljs-keyword">this</span>.id = options.id;
            }
        };
        H.PlotLineOrBand.prototype = {
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> plotLine = <span class="hljs-keyword">this</span>,
                    axis = plotLine.axis,
                    horiz = axis.horiz,
                    options = plotLine.options,
                    optionsLabel = options.label,
                    label = plotLine.label,
                    to = options.to,
                    <span class="hljs-keyword">from</span> = options.from,
                    value = options.value,
                    isBand = defined(<span class="hljs-keyword">from</span>) &amp;&amp; defined(to),
                    isLine = defined(value),
                    svgElem = plotLine.svgElem,
                    isNew = !svgElem,
                    path = [],
                    addEvent,
                    eventType,
                    color = options.color,
                    zIndex = pick(options.zIndex, <span class="hljs-number">0</span>),
                    events = options.events,
                    attribs = {
                        <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-plot-'</span> + (isBand ? <span class="hljs-string">'band '</span> : <span class="hljs-string">'line '</span>) + (options.className || <span class="hljs-string">''</span>)
                    },
                    groupAttribs = {},
                    renderer = axis.chart.renderer,
                    groupName = isBand ? <span class="hljs-string">'bands'</span> : <span class="hljs-string">'lines'</span>,
                    group,
                    log2lin = axis.log2lin;
                <span class="hljs-keyword">if</span> (axis.isLog) {
                    <span class="hljs-keyword">from</span> = log2lin(<span class="hljs-keyword">from</span>);
                    to = log2lin(to);
                    value = log2lin(value);
                }
                <span class="hljs-keyword">if</span> (isLine) {
                    attribs = {
                        <span class="hljs-attr">stroke</span>: color,
                        <span class="hljs-string">'stroke-width'</span>: options.width
                    };
                    <span class="hljs-keyword">if</span> (options.dashStyle) {
                        attribs.dashstyle = options.dashStyle;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBand) {
                    <span class="hljs-keyword">if</span> (color) {
                        attribs.fill = color;
                    }
                    <span class="hljs-keyword">if</span> (options.borderWidth) {
                        attribs.stroke = options.borderColor;
                        attribs[<span class="hljs-string">'stroke-width'</span>] = options.borderWidth;
                    }
                }
                groupAttribs.zIndex = zIndex;
                groupName += <span class="hljs-string">'-'</span> + zIndex;
                group = axis[groupName];
                <span class="hljs-keyword">if</span> (!group) {
                    axis[groupName] = group = renderer.g(<span class="hljs-string">'plot-'</span> + groupName)
                        .attr(groupAttribs).add();
                }
                <span class="hljs-keyword">if</span> (isNew) {
                    plotLine.svgElem = svgElem =
                        renderer
                        .path()
                        .attr(attribs).add(group);
                }
                <span class="hljs-keyword">if</span> (isLine) {
                    path = axis.getPlotLinePath(value, svgElem.strokeWidth());
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isBand) {
                    path = axis.getPlotBandPath(<span class="hljs-keyword">from</span>, to, options);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (isNew &amp;&amp; path &amp;&amp; path.length) {
                    svgElem.attr({
                        <span class="hljs-attr">d</span>: path
                    });
                    <span class="hljs-keyword">if</span> (events) {
                        addEvent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventType</span>) </span>{
                            svgElem.on(eventType, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                                events[eventType].apply(plotLine, [e]);
                            });
                        };
                        <span class="hljs-keyword">for</span> (eventType <span class="hljs-keyword">in</span> events) {
                            addEvent(eventType);
                        }
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (svgElem) {
                    <span class="hljs-keyword">if</span> (path) {
                        svgElem.show();
                        svgElem.animate({
                            <span class="hljs-attr">d</span>: path
                        });
                    } <span class="hljs-keyword">else</span> {
                        svgElem.hide();
                        <span class="hljs-keyword">if</span> (label) {
                            plotLine.label = label = label.destroy();
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (optionsLabel &amp;&amp; defined(optionsLabel.text) &amp;&amp; path &amp;&amp; path.length &amp;&amp;
                    axis.width &gt; <span class="hljs-number">0</span> &amp;&amp; axis.height &gt; <span class="hljs-number">0</span> &amp;&amp; !path.flat) {
                    optionsLabel = merge({
                        <span class="hljs-attr">align</span>: horiz &amp;&amp; isBand &amp;&amp; <span class="hljs-string">'center'</span>,
                        <span class="hljs-attr">x</span>: horiz ? !isBand &amp;&amp; <span class="hljs-number">4</span> : <span class="hljs-number">10</span>,
                        <span class="hljs-attr">verticalAlign</span>: !horiz &amp;&amp; isBand &amp;&amp; <span class="hljs-string">'middle'</span>,
                        <span class="hljs-attr">y</span>: horiz ? isBand ? <span class="hljs-number">16</span> : <span class="hljs-number">10</span> : isBand ? <span class="hljs-number">6</span> : <span class="hljs-number">-4</span>,
                        <span class="hljs-attr">rotation</span>: horiz &amp;&amp; !isBand &amp;&amp; <span class="hljs-number">90</span>
                    }, optionsLabel);
                    <span class="hljs-keyword">this</span>.renderLabel(optionsLabel, path, isBand, zIndex);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label) {
                    label.hide();
                }
                <span class="hljs-keyword">return</span> plotLine;
            },
            <span class="hljs-attr">renderLabel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">optionsLabel, path, isBand, zIndex</span>) </span>{
                <span class="hljs-keyword">var</span> plotLine = <span class="hljs-keyword">this</span>,
                    label = plotLine.label,
                    renderer = plotLine.axis.chart.renderer,
                    attribs,
                    xs,
                    ys,
                    x,
                    y;
                <span class="hljs-keyword">if</span> (!label) {
                    attribs = {
                        <span class="hljs-attr">align</span>: optionsLabel.textAlign || optionsLabel.align,
                        <span class="hljs-attr">rotation</span>: optionsLabel.rotation,
                        <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-plot-'</span> + (isBand ? <span class="hljs-string">'band'</span> : <span class="hljs-string">'line'</span>) + <span class="hljs-string">'-label '</span> + (optionsLabel.className || <span class="hljs-string">''</span>)
                    };
                    attribs.zIndex = zIndex;
                    plotLine.label = label = renderer.text(
                            optionsLabel.text,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            optionsLabel.useHTML
                        )
                        .attr(attribs)
                        .add();
                    label.css(optionsLabel.style);
                }
                xs = [path[<span class="hljs-number">1</span>], path[<span class="hljs-number">4</span>], (isBand ? path[<span class="hljs-number">6</span>] : path[<span class="hljs-number">1</span>])];
                ys = [path[<span class="hljs-number">2</span>], path[<span class="hljs-number">5</span>], (isBand ? path[<span class="hljs-number">7</span>] : path[<span class="hljs-number">2</span>])];
                x = arrayMin(xs);
                y = arrayMin(ys);
                label.align(optionsLabel, <span class="hljs-literal">false</span>, {
                    <span class="hljs-attr">x</span>: x,
                    <span class="hljs-attr">y</span>: y,
                    <span class="hljs-attr">width</span>: arrayMax(xs) - x,
                    <span class="hljs-attr">height</span>: arrayMax(ys) - y
                });
                label.show();
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                erase(<span class="hljs-keyword">this</span>.axis.plotLinesAndBands, <span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.axis;
                destroyObjectProperties(<span class="hljs-keyword">this</span>);
            }
        };
        H.AxisPlotLineOrBandExtension = {
            <span class="hljs-attr">getPlotBandPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to</span>) </span>{
                <span class="hljs-keyword">var</span> toPath = <span class="hljs-keyword">this</span>.getPlotLinePath(to, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>),
                    path = <span class="hljs-keyword">this</span>.getPlotLinePath(<span class="hljs-keyword">from</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (path &amp;&amp; toPath) {
                    path.flat = path.toString() === toPath.toString();
                    path.push(
                        toPath[<span class="hljs-number">4</span>],
                        toPath[<span class="hljs-number">5</span>],
                        toPath[<span class="hljs-number">1</span>],
                        toPath[<span class="hljs-number">2</span>],
                        <span class="hljs-string">'z'</span>
                    );
                } <span class="hljs-keyword">else</span> {
                    path = <span class="hljs-literal">null</span>;
                }
                <span class="hljs-keyword">return</span> path;
            },
            <span class="hljs-attr">addPlotBand</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addPlotBandOrLine(options, <span class="hljs-string">'plotBands'</span>);
            },
            <span class="hljs-attr">addPlotLine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addPlotBandOrLine(options, <span class="hljs-string">'plotLines'</span>);
            },
            <span class="hljs-attr">addPlotBandOrLine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, coll</span>) </span>{
                <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> H.PlotLineOrBand(<span class="hljs-keyword">this</span>, options).render(),
                    userOptions = <span class="hljs-keyword">this</span>.userOptions;
                <span class="hljs-keyword">if</span> (obj) {
                    <span class="hljs-keyword">if</span> (coll) {
                        userOptions[coll] = userOptions[coll] || [];
                        userOptions[coll].push(options);
                    }
                    <span class="hljs-keyword">this</span>.plotLinesAndBands.push(obj);
                }
                <span class="hljs-keyword">return</span> obj;
            },
            <span class="hljs-attr">removePlotBandOrLine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
                <span class="hljs-keyword">var</span> plotLinesAndBands = <span class="hljs-keyword">this</span>.plotLinesAndBands,
                    options = <span class="hljs-keyword">this</span>.options,
                    userOptions = <span class="hljs-keyword">this</span>.userOptions,
                    i = plotLinesAndBands.length;
                <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">if</span> (plotLinesAndBands[i].id === id) {
                        plotLinesAndBands[i].destroy();
                    }
                }
                each([options.plotLines || [], userOptions.plotLines || [], options.plotBands || [], userOptions.plotBands || []], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    i = arr.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (arr[i].id === id) {
                            erase(arr, arr[i]);
                        }
                    }
                });
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> correctFloat = H.correctFloat,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            isNumber = H.isNumber,
            merge = H.merge,
            pick = H.pick,
            deg2rad = H.deg2rad;
        H.Tick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, pos, type, noLabel</span>) </span>{
            <span class="hljs-keyword">this</span>.axis = axis;
            <span class="hljs-keyword">this</span>.pos = pos;
            <span class="hljs-keyword">this</span>.type = type || <span class="hljs-string">''</span>;
            <span class="hljs-keyword">this</span>.isNew = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (!type &amp;&amp; !noLabel) {
                <span class="hljs-keyword">this</span>.addLabel();
            }
        };
        H.Tick.prototype = {
            <span class="hljs-attr">addLabel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> tick = <span class="hljs-keyword">this</span>,
                    axis = tick.axis,
                    options = axis.options,
                    chart = axis.chart,
                    categories = axis.categories,
                    names = axis.names,
                    pos = tick.pos,
                    labelOptions = options.labels,
                    str,
                    tickPositions = axis.tickPositions,
                    isFirst = pos === tickPositions[<span class="hljs-number">0</span>],
                    isLast = pos === tickPositions[tickPositions.length - <span class="hljs-number">1</span>],
                    value = categories ?
                    pick(categories[pos], names[pos], pos) :
                    pos,
                    label = tick.label,
                    tickPositionInfo = tickPositions.info,
                    dateTimeLabelFormat;
                <span class="hljs-keyword">if</span> (axis.isDatetimeAxis &amp;&amp; tickPositionInfo) {
                    dateTimeLabelFormat =
                        options.dateTimeLabelFormats[
                            tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName
                        ];
                }
                tick.isFirst = isFirst;
                tick.isLast = isLast;
                str = axis.labelFormatter.call({
                    <span class="hljs-attr">axis</span>: axis,
                    <span class="hljs-attr">chart</span>: chart,
                    <span class="hljs-attr">isFirst</span>: isFirst,
                    <span class="hljs-attr">isLast</span>: isLast,
                    <span class="hljs-attr">dateTimeLabelFormat</span>: dateTimeLabelFormat,
                    <span class="hljs-attr">value</span>: axis.isLog ? correctFloat(axis.lin2log(value)) : value
                });
                <span class="hljs-keyword">if</span> (!defined(label)) {
                    tick.label = label =
                        defined(str) &amp;&amp; labelOptions.enabled ?
                        chart.renderer.text(
                            str,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            labelOptions.useHTML
                        )
                        .css(merge(labelOptions.style))
                        .add(axis.labelGroup) :
                        <span class="hljs-literal">null</span>;
                    tick.labelLength = label &amp;&amp; label.getBBox().width;
                    tick.rotation = <span class="hljs-number">0</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (label) {
                    label.attr({
                        <span class="hljs-attr">text</span>: str
                    });
                }
            },
            <span class="hljs-attr">getLabelSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label ?
                    <span class="hljs-keyword">this</span>.label.getBBox()[<span class="hljs-keyword">this</span>.axis.horiz ? <span class="hljs-string">'height'</span> : <span class="hljs-string">'width'</span>] :
                    <span class="hljs-number">0</span>;
            },
            <span class="hljs-attr">handleOverflow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xy</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>.axis,
                    pxPos = xy.x,
                    chartWidth = axis.chart.chartWidth,
                    spacing = axis.chart.spacing,
                    leftBound = pick(axis.labelLeft, <span class="hljs-built_in">Math</span>.min(axis.pos, spacing[<span class="hljs-number">3</span>])),
                    rightBound = pick(axis.labelRight, <span class="hljs-built_in">Math</span>.max(axis.pos + axis.len, chartWidth - spacing[<span class="hljs-number">1</span>])),
                    label = <span class="hljs-keyword">this</span>.label,
                    rotation = <span class="hljs-keyword">this</span>.rotation,
                    factor = {
                        <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">center</span>: <span class="hljs-number">0.5</span>,
                        <span class="hljs-attr">right</span>: <span class="hljs-number">1</span>
                    }[axis.labelAlign],
                    labelWidth = label.getBBox().width,
                    slotWidth = axis.getSlotWidth(),
                    modifiedSlotWidth = slotWidth,
                    xCorrection = factor,
                    goRight = <span class="hljs-number">1</span>,
                    leftPos,
                    rightPos,
                    textWidth,
                    css = {};
                <span class="hljs-keyword">if</span> (!rotation) {
                    leftPos = pxPos - factor * labelWidth;
                    rightPos = pxPos + (<span class="hljs-number">1</span> - factor) * labelWidth;
                    <span class="hljs-keyword">if</span> (leftPos &lt; leftBound) {
                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (<span class="hljs-number">1</span> - factor) - leftBound;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightPos &gt; rightBound) {
                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
                        goRight = <span class="hljs-number">-1</span>;
                    }
                    modifiedSlotWidth = <span class="hljs-built_in">Math</span>.min(slotWidth, modifiedSlotWidth);
                    <span class="hljs-keyword">if</span> (modifiedSlotWidth &lt; slotWidth &amp;&amp; axis.labelAlign === <span class="hljs-string">'center'</span>) {
                        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *
                            (slotWidth - <span class="hljs-built_in">Math</span>.min(labelWidth, modifiedSlotWidth)));
                    }
                    <span class="hljs-keyword">if</span> (labelWidth &gt; modifiedSlotWidth || (axis.autoRotation &amp;&amp; (label.styles || {}).width)) {
                        textWidth = modifiedSlotWidth;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotation &lt; <span class="hljs-number">0</span> &amp;&amp; pxPos - factor * labelWidth &lt; leftBound) {
                    textWidth = <span class="hljs-built_in">Math</span>.round(pxPos / <span class="hljs-built_in">Math</span>.cos(rotation * deg2rad) - leftBound);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rotation &gt; <span class="hljs-number">0</span> &amp;&amp; pxPos + factor * labelWidth &gt; rightBound) {
                    textWidth = <span class="hljs-built_in">Math</span>.round((chartWidth - pxPos) / <span class="hljs-built_in">Math</span>.cos(rotation * deg2rad));
                }
                <span class="hljs-keyword">if</span> (textWidth) {
                    css.width = textWidth;
                    <span class="hljs-keyword">if</span> (!(axis.options.labels.style || {}).textOverflow) {
                        css.textOverflow = <span class="hljs-string">'ellipsis'</span>;
                    }
                    label.css(css);
                }
            },
            <span class="hljs-attr">getPosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">horiz, pos, tickmarkOffset, old</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>.axis,
                    chart = axis.chart,
                    cHeight = (old &amp;&amp; chart.oldChartHeight) || chart.chartHeight;
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: horiz ?
                        axis.translate(pos + tickmarkOffset, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, old) + axis.transB : axis.left + axis.offset +
                        (axis.opposite ?
                            ((old &amp;&amp; chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :
                            <span class="hljs-number">0</span>
                        ),
                    <span class="hljs-attr">y</span>: horiz ?
                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : <span class="hljs-number">0</span>) : cHeight - axis.translate(pos + tickmarkOffset, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, old) - axis.transB
                };
            },
            <span class="hljs-attr">getLabelPosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, label, horiz, labelOptions, tickmarkOffset, index, step</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>.axis,
                    transA = axis.transA,
                    reversed = axis.reversed,
                    staggerLines = axis.staggerLines,
                    rotCorr = axis.tickRotCorr || {
                        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
                    },
                    yOffset = labelOptions.y,
                    line;
                <span class="hljs-keyword">if</span> (!defined(yOffset)) {
                    <span class="hljs-keyword">if</span> (axis.side === <span class="hljs-number">0</span>) {
                        yOffset = label.rotation ? <span class="hljs-number">-8</span> : -label.getBBox().height;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.side === <span class="hljs-number">2</span>) {
                        yOffset = rotCorr.y + <span class="hljs-number">8</span>;
                    } <span class="hljs-keyword">else</span> {
                        yOffset = <span class="hljs-built_in">Math</span>.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>).height / <span class="hljs-number">2</span>);
                    }
                }
                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset &amp;&amp; horiz ?
                    tickmarkOffset * transA * (reversed ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>);
                y = y + yOffset - (tickmarkOffset &amp;&amp; !horiz ?
                    tickmarkOffset * transA * (reversed ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) : <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (staggerLines) {
                    line = (index / (step || <span class="hljs-number">1</span>) % staggerLines);
                    <span class="hljs-keyword">if</span> (axis.opposite) {
                        line = staggerLines - line - <span class="hljs-number">1</span>;
                    }
                    y += line * (axis.labelOffset / staggerLines);
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: x,
                    <span class="hljs-attr">y</span>: <span class="hljs-built_in">Math</span>.round(y)
                };
            },
            <span class="hljs-attr">getMarkPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, tickLength, tickWidth, horiz, renderer</span>) </span>{
                <span class="hljs-keyword">return</span> renderer.crispLine([
                    <span class="hljs-string">'M'</span>,
                    x,
                    y,
                    <span class="hljs-string">'L'</span>,
                    x + (horiz ? <span class="hljs-number">0</span> : -tickLength),
                    y + (horiz ? tickLength : <span class="hljs-number">0</span>)
                ], tickWidth);
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index, old, opacity</span>) </span>{
                <span class="hljs-keyword">var</span> tick = <span class="hljs-keyword">this</span>,
                    axis = tick.axis,
                    options = axis.options,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    horiz = axis.horiz,
                    type = tick.type,
                    label = tick.label,
                    pos = tick.pos,
                    labelOptions = options.labels,
                    gridLine = tick.gridLine,
                    tickPrefix = type ? type + <span class="hljs-string">'Tick'</span> : <span class="hljs-string">'tick'</span>,
                    tickSize = axis.tickSize(tickPrefix),
                    gridLinePath,
                    mark = tick.mark,
                    isNewMark = !mark,
                    step = labelOptions.step,
                    attribs = {},
                    show = <span class="hljs-literal">true</span>,
                    tickmarkOffset = axis.tickmarkOffset,
                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),
                    x = xy.x,
                    y = xy.y,
                    reverseCrisp = ((horiz &amp;&amp; x === axis.pos + axis.len) ||
                        (!horiz &amp;&amp; y === axis.pos)) ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;
                <span class="hljs-keyword">var</span> gridPrefix = type ? type + <span class="hljs-string">'Grid'</span> : <span class="hljs-string">'grid'</span>,
                    gridLineWidth = options[gridPrefix + <span class="hljs-string">'LineWidth'</span>],
                    gridLineColor = options[gridPrefix + <span class="hljs-string">'LineColor'</span>],
                    dashStyle = options[gridPrefix + <span class="hljs-string">'LineDashStyle'</span>],
                    tickWidth = pick(options[tickPrefix + <span class="hljs-string">'Width'</span>], !type &amp;&amp; axis.isXAxis ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>),
                    tickColor = options[tickPrefix + <span class="hljs-string">'Color'</span>];
                opacity = pick(opacity, <span class="hljs-number">1</span>);
                <span class="hljs-keyword">this</span>.isActive = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (!gridLine) {
                    attribs.stroke = gridLineColor;
                    attribs[<span class="hljs-string">'stroke-width'</span>] = gridLineWidth;
                    <span class="hljs-keyword">if</span> (dashStyle) {
                        attribs.dashstyle = dashStyle;
                    }
                    <span class="hljs-keyword">if</span> (!type) {
                        attribs.zIndex = <span class="hljs-number">1</span>;
                    }
                    <span class="hljs-keyword">if</span> (old) {
                        attribs.opacity = <span class="hljs-number">0</span>;
                    }
                    tick.gridLine = gridLine = renderer.path()
                        .attr(attribs)
                        .addClass(<span class="hljs-string">'highcharts-'</span> + (type ? type + <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'grid-line'</span>)
                        .add(axis.gridGroup);
                }
                <span class="hljs-keyword">if</span> (!old &amp;&amp; gridLine) {
                    gridLinePath = axis.getPlotLinePath(pos + tickmarkOffset, gridLine.strokeWidth() * reverseCrisp, old, <span class="hljs-literal">true</span>);
                    <span class="hljs-keyword">if</span> (gridLinePath) {
                        gridLine[tick.isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>]({
                            <span class="hljs-attr">d</span>: gridLinePath,
                            <span class="hljs-attr">opacity</span>: opacity
                        });
                    }
                }
                <span class="hljs-keyword">if</span> (tickSize) {
                    <span class="hljs-keyword">if</span> (axis.opposite) {
                        tickSize[<span class="hljs-number">0</span>] = -tickSize[<span class="hljs-number">0</span>];
                    }
                    <span class="hljs-keyword">if</span> (isNewMark) {
                        tick.mark = mark = renderer.path()
                            .addClass(<span class="hljs-string">'highcharts-'</span> + (type ? type + <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">'tick'</span>)
                            .add(axis.axisGroup);
                        mark.attr({
                            <span class="hljs-attr">stroke</span>: tickColor,
                            <span class="hljs-string">'stroke-width'</span>: tickWidth
                        });
                    }
                    mark[isNewMark ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>]({
                        <span class="hljs-attr">d</span>: tick.getMarkPath(x, y, tickSize[<span class="hljs-number">0</span>], mark.strokeWidth() * reverseCrisp, horiz, renderer),
                        <span class="hljs-attr">opacity</span>: opacity
                    });
                }
                <span class="hljs-keyword">if</span> (label &amp;&amp; isNumber(x)) {
                    label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                    <span class="hljs-keyword">if</span> ((tick.isFirst &amp;&amp; !tick.isLast &amp;&amp; !pick(options.showFirstLabel, <span class="hljs-number">1</span>)) ||
                        (tick.isLast &amp;&amp; !tick.isFirst &amp;&amp; !pick(options.showLastLabel, <span class="hljs-number">1</span>))) {
                        show = <span class="hljs-literal">false</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (horiz &amp;&amp; !axis.isRadial &amp;&amp; !labelOptions.step &amp;&amp;
                        !labelOptions.rotation &amp;&amp; !old &amp;&amp; opacity !== <span class="hljs-number">0</span>) {
                        tick.handleOverflow(xy);
                    }
                    <span class="hljs-keyword">if</span> (step &amp;&amp; index % step) {
                        show = <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">if</span> (show &amp;&amp; isNumber(xy.y)) {
                        xy.opacity = opacity;
                        label[tick.isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>](xy);
                    } <span class="hljs-keyword">else</span> {
                        label.attr(<span class="hljs-string">'y'</span>, <span class="hljs-number">-9999</span>);
                    }
                    tick.isNew = <span class="hljs-literal">false</span>;
                }
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                destroyObjectProperties(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.axis);
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            animObject = H.animObject,
            arrayMax = H.arrayMax,
            arrayMin = H.arrayMin,
            AxisPlotLineOrBandExtension = H.AxisPlotLineOrBandExtension,
            color = H.color,
            correctFloat = H.correctFloat,
            defaultOptions = H.defaultOptions,
            defined = H.defined,
            deg2rad = H.deg2rad,
            destroyObjectProperties = H.destroyObjectProperties,
            each = H.each,
            extend = H.extend,
            fireEvent = H.fireEvent,
            format = H.format,
            getMagnitude = H.getMagnitude,
            grep = H.grep,
            inArray = H.inArray,
            isArray = H.isArray,
            isNumber = H.isNumber,
            isString = H.isString,
            merge = H.merge,
            normalizeTickInterval = H.normalizeTickInterval,
            pick = H.pick,
            PlotLineOrBand = H.PlotLineOrBand,
            removeEvent = H.removeEvent,
            splat = H.splat,
            syncTimeout = H.syncTimeout,
            Tick = H.Tick;
        H.Axis = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
        H.Axis.prototype = {
            <span class="hljs-attr">defaultOptions</span>: {
                <span class="hljs-attr">dateTimeLabelFormats</span>: {
                    <span class="hljs-attr">millisecond</span>: <span class="hljs-string">'%H:%M:%S.%L'</span>,
                    <span class="hljs-attr">second</span>: <span class="hljs-string">'%H:%M:%S'</span>,
                    <span class="hljs-attr">minute</span>: <span class="hljs-string">'%H:%M'</span>,
                    <span class="hljs-attr">hour</span>: <span class="hljs-string">'%H:%M'</span>,
                    <span class="hljs-attr">day</span>: <span class="hljs-string">'%e. %b'</span>,
                    <span class="hljs-attr">week</span>: <span class="hljs-string">'%e. %b'</span>,
                    <span class="hljs-attr">month</span>: <span class="hljs-string">'%b \'%y'</span>,
                    <span class="hljs-attr">year</span>: <span class="hljs-string">'%Y'</span>
                },
                <span class="hljs-attr">endOnTick</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#666666'</span>,
                        <span class="hljs-attr">cursor</span>: <span class="hljs-string">'default'</span>,
                        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'11px'</span>
                    },
                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>
                },
                <span class="hljs-attr">minPadding</span>: <span class="hljs-number">0.01</span>,
                <span class="hljs-attr">maxPadding</span>: <span class="hljs-number">0.01</span>,
                <span class="hljs-attr">minorTickLength</span>: <span class="hljs-number">2</span>,
                <span class="hljs-attr">minorTickPosition</span>: <span class="hljs-string">'outside'</span>,
                <span class="hljs-attr">startOfWeek</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">startOnTick</span>: <span class="hljs-literal">false</span>,
                <span class="hljs-attr">tickLength</span>: <span class="hljs-number">10</span>,
                <span class="hljs-attr">tickmarkPlacement</span>: <span class="hljs-string">'between'</span>,
                <span class="hljs-attr">tickPixelInterval</span>: <span class="hljs-number">100</span>,
                <span class="hljs-attr">tickPosition</span>: <span class="hljs-string">'outside'</span>,
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">align</span>: <span class="hljs-string">'middle'</span>,
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#666666'</span>
                    }
                },
                <span class="hljs-attr">type</span>: <span class="hljs-string">'linear'</span>,
                <span class="hljs-attr">minorGridLineColor</span>: <span class="hljs-string">'#f2f2f2'</span>,
                <span class="hljs-attr">minorGridLineWidth</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">minorTickColor</span>: <span class="hljs-string">'#999999'</span>,
                <span class="hljs-attr">lineColor</span>: <span class="hljs-string">'#ccd6eb'</span>,
                <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">gridLineColor</span>: <span class="hljs-string">'#e6e6e6'</span>,
                <span class="hljs-attr">tickColor</span>: <span class="hljs-string">'#ccd6eb'</span>
            },
            <span class="hljs-attr">defaultYAxisOptions</span>: {
                <span class="hljs-attr">endOnTick</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">tickPixelInterval</span>: <span class="hljs-number">72</span>,
                <span class="hljs-attr">showLastLabel</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">x</span>: <span class="hljs-number">-8</span>
                },
                <span class="hljs-attr">maxPadding</span>: <span class="hljs-number">0.05</span>,
                <span class="hljs-attr">minPadding</span>: <span class="hljs-number">0.05</span>,
                <span class="hljs-attr">startOnTick</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">rotation</span>: <span class="hljs-number">270</span>,
                    <span class="hljs-attr">text</span>: <span class="hljs-string">'Values'</span>
                },
                <span class="hljs-attr">stackLabels</span>: {
                    <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">formatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">return</span> H.numberFormat(<span class="hljs-keyword">this</span>.total, <span class="hljs-number">-1</span>);
                    },
                    <span class="hljs-attr">style</span>: {
                        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'11px'</span>,
                        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>,
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#000000'</span>,
                        <span class="hljs-attr">textOutline</span>: <span class="hljs-string">'1px contrast'</span>
                    }
                },
                <span class="hljs-attr">gridLineWidth</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">0</span>
            },
            <span class="hljs-attr">defaultLeftAxisOptions</span>: {
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">x</span>: <span class="hljs-number">-15</span>
                },
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">rotation</span>: <span class="hljs-number">270</span>
                }
            },
            <span class="hljs-attr">defaultRightAxisOptions</span>: {
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">x</span>: <span class="hljs-number">15</span>
                },
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">rotation</span>: <span class="hljs-number">90</span>
                }
            },
            <span class="hljs-attr">defaultBottomAxisOptions</span>: {
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">autoRotation</span>: [<span class="hljs-number">-45</span>],
                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>
                },
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">rotation</span>: <span class="hljs-number">0</span>
                }
            },
            <span class="hljs-attr">defaultTopAxisOptions</span>: {
                <span class="hljs-attr">labels</span>: {
                    <span class="hljs-attr">autoRotation</span>: [<span class="hljs-number">-45</span>],
                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>
                },
                <span class="hljs-attr">title</span>: {
                    <span class="hljs-attr">rotation</span>: <span class="hljs-number">0</span>
                }
            },
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, userOptions</span>) </span>{
                <span class="hljs-keyword">var</span> isXAxis = userOptions.isX,
                    axis = <span class="hljs-keyword">this</span>;
                axis.chart = chart;
                axis.horiz = chart.inverted ? !isXAxis : isXAxis;
                axis.isXAxis = isXAxis;
                axis.coll = axis.coll || (isXAxis ? <span class="hljs-string">'xAxis'</span> : <span class="hljs-string">'yAxis'</span>);
                axis.opposite = userOptions.opposite;
                axis.side = userOptions.side || (axis.horiz ?
                    (axis.opposite ? <span class="hljs-number">0</span> : <span class="hljs-number">2</span>) :
                    (axis.opposite ? <span class="hljs-number">1</span> : <span class="hljs-number">3</span>));
                axis.setOptions(userOptions);
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    type = options.type,
                    isDatetimeAxis = type === <span class="hljs-string">'datetime'</span>;
                axis.labelFormatter = options.labels.formatter || axis.defaultLabelFormatter;
                axis.userOptions = userOptions;
                axis.minPixelPadding = <span class="hljs-number">0</span>;
                axis.reversed = options.reversed;
                axis.visible = options.visible !== <span class="hljs-literal">false</span>;
                axis.zoomEnabled = options.zoomEnabled !== <span class="hljs-literal">false</span>;
                axis.hasNames = type === <span class="hljs-string">'category'</span> || options.categories === <span class="hljs-literal">true</span>;
                axis.categories = options.categories || axis.hasNames;
                axis.names = axis.names || [];
                axis.isLog = type === <span class="hljs-string">'logarithmic'</span>;
                axis.isDatetimeAxis = isDatetimeAxis;
                axis.isLinked = defined(options.linkedTo);
                axis.ticks = {};
                axis.labelEdge = [];
                axis.minorTicks = {};
                axis.plotLinesAndBands = [];
                axis.alternateBands = {};
                axis.len = <span class="hljs-number">0</span>;
                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
                axis.range = options.range;
                axis.offset = options.offset || <span class="hljs-number">0</span>;
                axis.stacks = {};
                axis.oldStacks = {};
                axis.stacksTouched = <span class="hljs-number">0</span>;
                axis.max = <span class="hljs-literal">null</span>;
                axis.min = <span class="hljs-literal">null</span>;
                axis.crosshair = pick(options.crosshair, splat(chart.options.tooltip.crosshairs)[isXAxis ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>], <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">var</span> eventType,
                    events = axis.options.events;
                <span class="hljs-keyword">if</span> (inArray(axis, chart.axes) === <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">if</span> (isXAxis) {
                        chart.axes.splice(chart.xAxis.length, <span class="hljs-number">0</span>, axis);
                    } <span class="hljs-keyword">else</span> {
                        chart.axes.push(axis);
                    }
                    chart[axis.coll].push(axis);
                }
                axis.series = axis.series || [];
                <span class="hljs-keyword">if</span> (chart.inverted &amp;&amp; isXAxis &amp;&amp; axis.reversed === <span class="hljs-literal">undefined</span>) {
                    axis.reversed = <span class="hljs-literal">true</span>;
                }
                axis.removePlotBand = axis.removePlotBandOrLine;
                axis.removePlotLine = axis.removePlotBandOrLine;
                <span class="hljs-keyword">for</span> (eventType <span class="hljs-keyword">in</span> events) {
                    addEvent(axis, eventType, events[eventType]);
                }
                <span class="hljs-keyword">if</span> (axis.isLog) {
                    axis.val2lin = axis.log2lin;
                    axis.lin2val = axis.lin2log;
                }
            },
            <span class="hljs-attr">setOptions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userOptions</span>) </span>{
                <span class="hljs-keyword">this</span>.options = merge(
                    <span class="hljs-keyword">this</span>.defaultOptions,
                    <span class="hljs-keyword">this</span>.coll === <span class="hljs-string">'yAxis'</span> &amp;&amp; <span class="hljs-keyword">this</span>.defaultYAxisOptions, [<span class="hljs-keyword">this</span>.defaultTopAxisOptions, <span class="hljs-keyword">this</span>.defaultRightAxisOptions,
                        <span class="hljs-keyword">this</span>.defaultBottomAxisOptions, <span class="hljs-keyword">this</span>.defaultLeftAxisOptions
                    ][<span class="hljs-keyword">this</span>.side],
                    merge(
                        defaultOptions[<span class="hljs-keyword">this</span>.coll],
                        userOptions
                    )
                );
            },
            <span class="hljs-attr">defaultLabelFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>.axis,
                    value = <span class="hljs-keyword">this</span>.value,
                    categories = axis.categories,
                    dateTimeLabelFormat = <span class="hljs-keyword">this</span>.dateTimeLabelFormat,
                    lang = defaultOptions.lang,
                    numericSymbols = lang.numericSymbols,
                    numSymMagnitude = lang.numericSymbolMagnitude || <span class="hljs-number">1000</span>,
                    i = numericSymbols &amp;&amp; numericSymbols.length,
                    multi,
                    ret,
                    formatOption = axis.options.labels.format,
                    numericSymbolDetector = axis.isLog ? value : axis.tickInterval;
                <span class="hljs-keyword">if</span> (formatOption) {
                    ret = format(formatOption, <span class="hljs-keyword">this</span>);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (categories) {
                    ret = value;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dateTimeLabelFormat) {
                    ret = H.dateFormat(dateTimeLabelFormat, value);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &amp;&amp; numericSymbolDetector &gt;= <span class="hljs-number">1000</span>) {
                    <span class="hljs-keyword">while</span> (i-- &amp;&amp; ret === <span class="hljs-literal">undefined</span>) {
                        multi = <span class="hljs-built_in">Math</span>.pow(numSymMagnitude, i + <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (numericSymbolDetector &gt;= multi &amp;&amp; (value * <span class="hljs-number">10</span>) % multi === <span class="hljs-number">0</span> &amp;&amp; numericSymbols[i] !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-number">0</span>) {
                            ret = H.numberFormat(value / multi, <span class="hljs-number">-1</span>) + numericSymbols[i];
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (ret === <span class="hljs-literal">undefined</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(value) &gt;= <span class="hljs-number">10000</span>) {
                        ret = H.numberFormat(value, <span class="hljs-number">-1</span>);
                    } <span class="hljs-keyword">else</span> {
                        ret = H.numberFormat(value, <span class="hljs-number">-1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-string">''</span>);
                    }
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">getSeriesExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart;
                axis.hasVisibleSeries = <span class="hljs-literal">false</span>;
                axis.dataMin = axis.dataMax = axis.threshold = <span class="hljs-literal">null</span>;
                axis.softThreshold = !axis.isXAxis;
                <span class="hljs-keyword">if</span> (axis.buildStacks) {
                    axis.buildStacks();
                }
                each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">if</span> (series.visible || !chart.options.chart.ignoreHiddenSeries) {
                        <span class="hljs-keyword">var</span> seriesOptions = series.options,
                            xData,
                            threshold = seriesOptions.threshold,
                            seriesDataMin,
                            seriesDataMax;
                        axis.hasVisibleSeries = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (axis.isLog &amp;&amp; threshold &lt;= <span class="hljs-number">0</span>) {
                            threshold = <span class="hljs-literal">null</span>;
                        }
                        <span class="hljs-keyword">if</span> (axis.isXAxis) {
                            xData = series.xData;
                            <span class="hljs-keyword">if</span> (xData.length) {
                                seriesDataMin = arrayMin(xData);
                                <span class="hljs-keyword">if</span> (!isNumber(seriesDataMin) &amp;&amp; !(seriesDataMin <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>)) {
                                    xData = grep(xData, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>{
                                        <span class="hljs-keyword">return</span> isNumber(x);
                                    });
                                    seriesDataMin = arrayMin(xData);
                                }
                                axis.dataMin = <span class="hljs-built_in">Math</span>.min(pick(axis.dataMin, xData[<span class="hljs-number">0</span>]), seriesDataMin);
                                axis.dataMax = <span class="hljs-built_in">Math</span>.max(pick(axis.dataMax, xData[<span class="hljs-number">0</span>]), arrayMax(xData));
                            }
                        } <span class="hljs-keyword">else</span> {
                            series.getExtremes();
                            seriesDataMax = series.dataMax;
                            seriesDataMin = series.dataMin;
                            <span class="hljs-keyword">if</span> (defined(seriesDataMin) &amp;&amp; defined(seriesDataMax)) {
                                axis.dataMin = <span class="hljs-built_in">Math</span>.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                                axis.dataMax = <span class="hljs-built_in">Math</span>.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                            }
                            <span class="hljs-keyword">if</span> (defined(threshold)) {
                                axis.threshold = threshold;
                            }
                            <span class="hljs-keyword">if</span> (!seriesOptions.softThreshold || axis.isLog) {
                                axis.softThreshold = <span class="hljs-literal">false</span>;
                            }
                        }
                    }
                });
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, backwards, cvsCoord, old, handleLog, pointPlacement</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>.linkedParent || <span class="hljs-keyword">this</span>,
                    sign = <span class="hljs-number">1</span>,
                    cvsOffset = <span class="hljs-number">0</span>,
                    localA = old ? axis.oldTransA : axis.transA,
                    localMin = old ? axis.oldMin : axis.min,
                    returnValue,
                    minPixelPadding = axis.minPixelPadding,
                    doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog &amp;&amp; handleLog)) &amp;&amp; axis.lin2val;
                <span class="hljs-keyword">if</span> (!localA) {
                    localA = axis.transA;
                }
                <span class="hljs-keyword">if</span> (cvsCoord) {
                    sign *= <span class="hljs-number">-1</span>;
                    cvsOffset = axis.len;
                }
                <span class="hljs-keyword">if</span> (axis.reversed) {
                    sign *= <span class="hljs-number">-1</span>;
                    cvsOffset -= sign * (axis.sector || axis.len);
                }
                <span class="hljs-keyword">if</span> (backwards) {
                    val = val * sign + cvsOffset;
                    val -= minPixelPadding;
                    returnValue = val / localA + localMin;
                    <span class="hljs-keyword">if</span> (doPostTranslate) {
                        returnValue = axis.lin2val(returnValue);
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (doPostTranslate) {
                        val = axis.val2lin(val);
                    }
                    returnValue = sign * (val - localMin) * localA + cvsOffset +
                        (sign * minPixelPadding) +
                        (isNumber(pointPlacement) ? localA * pointPlacement : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">return</span> returnValue;
            },
            <span class="hljs-attr">toPixels</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, paneCoordinates</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.translate(value, <span class="hljs-literal">false</span>, !<span class="hljs-keyword">this</span>.horiz, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>) + (paneCoordinates ? <span class="hljs-number">0</span> : <span class="hljs-keyword">this</span>.pos);
            },
            <span class="hljs-attr">toValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pixel, paneCoordinates</span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.translate(pixel - (paneCoordinates ? <span class="hljs-number">0</span> : <span class="hljs-keyword">this</span>.pos), <span class="hljs-literal">true</span>, !<span class="hljs-keyword">this</span>.horiz, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">getPlotLinePath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, lineWidth, old, force, translatedValue</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart,
                    axisLeft = axis.left,
                    axisTop = axis.top,
                    x1,
                    y1,
                    x2,
                    y2,
                    cHeight = (old &amp;&amp; chart.oldChartHeight) || chart.chartHeight,
                    cWidth = (old &amp;&amp; chart.oldChartWidth) || chart.chartWidth,
                    skip,
                    transB = axis.transB,
                    between = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, a, b</span>) </span>{
                        <span class="hljs-keyword">if</span> (x &lt; a || x &gt; b) {
                            <span class="hljs-keyword">if</span> (force) {
                                x = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(a, x), b);
                            } <span class="hljs-keyword">else</span> {
                                skip = <span class="hljs-literal">true</span>;
                            }
                        }
                        <span class="hljs-keyword">return</span> x;
                    };
                translatedValue = pick(translatedValue, axis.translate(value, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, old));
                x1 = x2 = <span class="hljs-built_in">Math</span>.round(translatedValue + transB);
                y1 = y2 = <span class="hljs-built_in">Math</span>.round(cHeight - translatedValue - transB);
                <span class="hljs-keyword">if</span> (!isNumber(translatedValue)) {
                    skip = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.horiz) {
                    y1 = axisTop;
                    y2 = cHeight - axis.bottom;
                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
                } <span class="hljs-keyword">else</span> {
                    x1 = axisLeft;
                    x2 = cWidth - axis.right;
                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
                }
                <span class="hljs-keyword">return</span> skip &amp;&amp; !force ?
                    <span class="hljs-literal">null</span> :
                    chart.renderer.crispLine([<span class="hljs-string">'M'</span>, x1, y1, <span class="hljs-string">'L'</span>, x2, y2], lineWidth || <span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">getLinearTickPositions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tickInterval, min, max</span>) </span>{
                <span class="hljs-keyword">var</span> pos,
                    lastPos,
                    roundedMin = correctFloat(<span class="hljs-built_in">Math</span>.floor(min / tickInterval) * tickInterval),
                    roundedMax = correctFloat(<span class="hljs-built_in">Math</span>.ceil(max / tickInterval) * tickInterval),
                    tickPositions = [];
                <span class="hljs-keyword">if</span> (min === max &amp;&amp; isNumber(min)) {
                    <span class="hljs-keyword">return</span> [min];
                }
                pos = roundedMin;
                <span class="hljs-keyword">while</span> (pos &lt;= roundedMax) {
                    tickPositions.push(pos);
                    pos = correctFloat(pos + tickInterval);
                    <span class="hljs-keyword">if</span> (pos === lastPos) {
                        <span class="hljs-keyword">break</span>;
                    }
                    lastPos = pos;
                }
                <span class="hljs-keyword">return</span> tickPositions;
            },
            <span class="hljs-attr">getMinorTickPositions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    options = axis.options,
                    tickPositions = axis.tickPositions,
                    minorTickInterval = axis.minorTickInterval,
                    minorTickPositions = [],
                    pos,
                    i,
                    pointRangePadding = axis.pointRangePadding || <span class="hljs-number">0</span>,
                    min = axis.min - pointRangePadding,
                    max = axis.max + pointRangePadding,
                    range = max - min,
                    len;
                <span class="hljs-keyword">if</span> (range &amp;&amp; range / minorTickInterval &lt; axis.len / <span class="hljs-number">3</span>) {
                    <span class="hljs-keyword">if</span> (axis.isLog) {
                        len = tickPositions.length;
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; len; i++) {
                            minorTickPositions = minorTickPositions.concat(
                                axis.getLogTickPositions(minorTickInterval, tickPositions[i - <span class="hljs-number">1</span>], tickPositions[i], <span class="hljs-literal">true</span>)
                            );
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.isDatetimeAxis &amp;&amp; options.minorTickInterval === <span class="hljs-string">'auto'</span>) {
                        minorTickPositions = minorTickPositions.concat(
                            axis.getTimeTicks(
                                axis.normalizeTimeTickInterval(minorTickInterval),
                                min,
                                max,
                                options.startOfWeek
                            )
                        );
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">for</span> (
                            pos = min + (tickPositions[<span class="hljs-number">0</span>] - min) % minorTickInterval; pos &lt;= max; pos += minorTickInterval
                        ) {
                            <span class="hljs-keyword">if</span> (pos === minorTickPositions[<span class="hljs-number">0</span>]) {
                                <span class="hljs-keyword">break</span>;
                            }
                            minorTickPositions.push(pos);
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (minorTickPositions.length !== <span class="hljs-number">0</span>) {
                    axis.trimTicks(minorTickPositions, options.startOnTick, options.endOnTick);
                }
                <span class="hljs-keyword">return</span> minorTickPositions;
            },
            <span class="hljs-attr">adjustForMinRange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    options = axis.options,
                    min = axis.min,
                    max = axis.max,
                    zoomOffset,
                    spaceAvailable = axis.dataMax - axis.dataMin &gt;= axis.minRange,
                    closestDataRange,
                    i,
                    distance,
                    xData,
                    loopLength,
                    minArgs,
                    maxArgs,
                    minRange;
                <span class="hljs-keyword">if</span> (axis.isXAxis &amp;&amp; axis.minRange === <span class="hljs-literal">undefined</span> &amp;&amp; !axis.isLog) {
                    <span class="hljs-keyword">if</span> (defined(options.min) || defined(options.max)) {
                        axis.minRange = <span class="hljs-literal">null</span>;
                    } <span class="hljs-keyword">else</span> {
                        each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                            xData = series.xData;
                            loopLength = series.xIncrement ? <span class="hljs-number">1</span> : xData.length - <span class="hljs-number">1</span>;
                            <span class="hljs-keyword">for</span> (i = loopLength; i &gt; <span class="hljs-number">0</span>; i--) {
                                distance = xData[i] - xData[i - <span class="hljs-number">1</span>];
                                <span class="hljs-keyword">if</span> (closestDataRange === <span class="hljs-literal">undefined</span> || distance &lt; closestDataRange) {
                                    closestDataRange = distance;
                                }
                            }
                        });
                        axis.minRange = <span class="hljs-built_in">Math</span>.min(closestDataRange * <span class="hljs-number">5</span>, axis.dataMax - axis.dataMin);
                    }
                }
                <span class="hljs-keyword">if</span> (max - min &lt; axis.minRange) {
                    minRange = axis.minRange;
                    zoomOffset = (minRange - max + min) / <span class="hljs-number">2</span>;
                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];
                    <span class="hljs-keyword">if</span> (spaceAvailable) {
                        minArgs[<span class="hljs-number">2</span>] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;
                    }
                    min = arrayMax(minArgs);
                    maxArgs = [min + minRange, pick(options.max, min + minRange)];
                    <span class="hljs-keyword">if</span> (spaceAvailable) {
                        maxArgs[<span class="hljs-number">2</span>] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;
                    }
                    max = arrayMin(maxArgs);
                    <span class="hljs-keyword">if</span> (max - min &lt; minRange) {
                        minArgs[<span class="hljs-number">0</span>] = max - minRange;
                        minArgs[<span class="hljs-number">1</span>] = pick(options.min, max - minRange);
                        min = arrayMax(minArgs);
                    }
                }
                axis.min = min;
                axis.max = max;
            },
            <span class="hljs-attr">getClosest</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> ret;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.categories) {
                    ret = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        <span class="hljs-keyword">var</span> seriesClosest = series.closestPointRange,
                            visible = series.visible ||
                            !series.chart.options.chart.ignoreHiddenSeries;
                        <span class="hljs-keyword">if</span> (!series.noSharedTooltip &amp;&amp;
                            defined(seriesClosest) &amp;&amp;
                            visible
                        ) {
                            ret = defined(ret) ?
                                <span class="hljs-built_in">Math</span>.min(ret, seriesClosest) :
                                seriesClosest;
                        }
                    });
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">nameToX</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                <span class="hljs-keyword">var</span> explicitCategories = isArray(<span class="hljs-keyword">this</span>.categories),
                    names = explicitCategories ? <span class="hljs-keyword">this</span>.categories : <span class="hljs-keyword">this</span>.names,
                    nameX = point.options.x,
                    x;
                point.series.requireSorting = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (!defined(nameX)) {
                    nameX = <span class="hljs-keyword">this</span>.options.uniqueNames === <span class="hljs-literal">false</span> ?
                        point.series.autoIncrement() :
                        inArray(point.name, names);
                }
                <span class="hljs-keyword">if</span> (nameX === <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">if</span> (!explicitCategories) {
                        x = names.length;
                    }
                } <span class="hljs-keyword">else</span> {
                    x = nameX;
                }
                <span class="hljs-keyword">this</span>.names[x] = point.name;
                <span class="hljs-keyword">return</span> x;
            },
            <span class="hljs-attr">updateNames</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.names.length &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">this</span>.names.length = <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">this</span>.minRange = <span class="hljs-literal">undefined</span>;
                    each(<span class="hljs-keyword">this</span>.series || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        series.xIncrement = <span class="hljs-literal">null</span>;
                        <span class="hljs-keyword">if</span> (!series.points || series.isDirtyData) {
                            series.processData();
                            series.generatePoints();
                        }
                        each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                            <span class="hljs-keyword">var</span> x;
                            <span class="hljs-keyword">if</span> (point.options) {
                                x = axis.nameToX(point);
                                <span class="hljs-keyword">if</span> (x !== point.x) {
                                    point.x = x;
                                    series.xData[i] = x;
                                }
                            }
                        });
                    });
                }
            },
            <span class="hljs-attr">setAxisTranslation</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">saveOld</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    range = axis.max - axis.min,
                    pointRange = axis.axisPointRange || <span class="hljs-number">0</span>,
                    closestPointRange,
                    minPointOffset = <span class="hljs-number">0</span>,
                    pointRangePadding = <span class="hljs-number">0</span>,
                    linkedParent = axis.linkedParent,
                    ordinalCorrection,
                    hasCategories = !!axis.categories,
                    transA = axis.transA,
                    isXAxis = axis.isXAxis;
                <span class="hljs-keyword">if</span> (isXAxis || hasCategories || pointRange) {
                    closestPointRange = axis.getClosest();
                    <span class="hljs-keyword">if</span> (linkedParent) {
                        minPointOffset = linkedParent.minPointOffset;
                        pointRangePadding = linkedParent.pointRangePadding;
                    } <span class="hljs-keyword">else</span> {
                        each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                            <span class="hljs-keyword">var</span> seriesPointRange = hasCategories ?
                                <span class="hljs-number">1</span> :
                                (isXAxis ?
                                    pick(series.options.pointRange, closestPointRange, <span class="hljs-number">0</span>) :
                                    (axis.axisPointRange || <span class="hljs-number">0</span>)),
                                pointPlacement = series.options.pointPlacement;
                            pointRange = <span class="hljs-built_in">Math</span>.max(pointRange, seriesPointRange);
                            <span class="hljs-keyword">if</span> (!axis.single) {
                                minPointOffset = <span class="hljs-built_in">Math</span>.max(
                                    minPointOffset,
                                    isString(pointPlacement) ? <span class="hljs-number">0</span> : seriesPointRange / <span class="hljs-number">2</span>
                                );
                                pointRangePadding = <span class="hljs-built_in">Math</span>.max(
                                    pointRangePadding,
                                    pointPlacement === <span class="hljs-string">'on'</span> ? <span class="hljs-number">0</span> : seriesPointRange
                                );
                            }
                        });
                    }
                    ordinalCorrection = axis.ordinalSlope &amp;&amp; closestPointRange ? axis.ordinalSlope / closestPointRange : <span class="hljs-number">1</span>;
                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
                    axis.pointRange = <span class="hljs-built_in">Math</span>.min(pointRange, range);
                    <span class="hljs-keyword">if</span> (isXAxis) {
                        axis.closestPointRange = closestPointRange;
                    }
                }
                <span class="hljs-keyword">if</span> (saveOld) {
                    axis.oldTransA = transA;
                }
                axis.translationSlope = axis.transA = transA = axis.len / ((range + pointRangePadding) || <span class="hljs-number">1</span>);
                axis.transB = axis.horiz ? axis.left : axis.bottom;
                axis.minPixelPadding = transA * minPointOffset;
            },
            <span class="hljs-attr">minFromRange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.max - <span class="hljs-keyword">this</span>.range;
            },
            <span class="hljs-attr">setTickInterval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">secondPass</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart,
                    options = axis.options,
                    isLog = axis.isLog,
                    log2lin = axis.log2lin,
                    isDatetimeAxis = axis.isDatetimeAxis,
                    isXAxis = axis.isXAxis,
                    isLinked = axis.isLinked,
                    maxPadding = options.maxPadding,
                    minPadding = options.minPadding,
                    length,
                    linkedParentExtremes,
                    tickIntervalOption = options.tickInterval,
                    minTickInterval,
                    tickPixelIntervalOption = options.tickPixelInterval,
                    categories = axis.categories,
                    threshold = axis.threshold,
                    softThreshold = axis.softThreshold,
                    thresholdMin,
                    thresholdMax,
                    hardMin,
                    hardMax;
                <span class="hljs-keyword">if</span> (!isDatetimeAxis &amp;&amp; !categories &amp;&amp; !isLinked) {
                    <span class="hljs-keyword">this</span>.getTickAmount();
                }
                hardMin = pick(axis.userMin, options.min);
                hardMax = pick(axis.userMax, options.max);
                <span class="hljs-keyword">if</span> (isLinked) {
                    axis.linkedParent = chart[axis.coll][options.linkedTo];
                    linkedParentExtremes = axis.linkedParent.getExtremes();
                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                    <span class="hljs-keyword">if</span> (options.type !== axis.linkedParent.options.type) {
                        H.error(<span class="hljs-number">11</span>, <span class="hljs-number">1</span>);
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (!softThreshold &amp;&amp; defined(threshold)) {
                        <span class="hljs-keyword">if</span> (axis.dataMin &gt;= threshold) {
                            thresholdMin = threshold;
                            minPadding = <span class="hljs-number">0</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.dataMax &lt;= threshold) {
                            thresholdMax = threshold;
                            maxPadding = <span class="hljs-number">0</span>;
                        }
                    }
                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);
                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);
                }
                <span class="hljs-keyword">if</span> (isLog) {
                    <span class="hljs-keyword">if</span> (!secondPass &amp;&amp; <span class="hljs-built_in">Math</span>.min(axis.min, pick(axis.dataMin, axis.min)) &lt;= <span class="hljs-number">0</span>) {
                        H.error(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);
                    }
                    axis.min = correctFloat(log2lin(axis.min), <span class="hljs-number">15</span>);
                    axis.max = correctFloat(log2lin(axis.max), <span class="hljs-number">15</span>);
                }
                <span class="hljs-keyword">if</span> (axis.range &amp;&amp; defined(axis.max)) {
                    axis.userMin = axis.min = hardMin = <span class="hljs-built_in">Math</span>.max(axis.min, axis.minFromRange());
                    axis.userMax = hardMax = axis.max;
                    axis.range = <span class="hljs-literal">null</span>;
                }
                fireEvent(axis, <span class="hljs-string">'foundExtremes'</span>);
                <span class="hljs-keyword">if</span> (axis.beforePadding) {
                    axis.beforePadding();
                }
                axis.adjustForMinRange();
                <span class="hljs-keyword">if</span> (!categories &amp;&amp; !axis.axisPointRange &amp;&amp; !axis.usePercentage &amp;&amp; !isLinked &amp;&amp; defined(axis.min) &amp;&amp; defined(axis.max)) {
                    length = axis.max - axis.min;
                    <span class="hljs-keyword">if</span> (length) {
                        <span class="hljs-keyword">if</span> (!defined(hardMin) &amp;&amp; minPadding) {
                            axis.min -= length * minPadding;
                        }
                        <span class="hljs-keyword">if</span> (!defined(hardMax) &amp;&amp; maxPadding) {
                            axis.max += length * maxPadding;
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (isNumber(options.floor)) {
                    axis.min = <span class="hljs-built_in">Math</span>.max(axis.min, options.floor);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNumber(options.softMin)) {
                    axis.min = <span class="hljs-built_in">Math</span>.min(axis.min, options.softMin);
                }
                <span class="hljs-keyword">if</span> (isNumber(options.ceiling)) {
                    axis.max = <span class="hljs-built_in">Math</span>.min(axis.max, options.ceiling);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isNumber(options.softMax)) {
                    axis.max = <span class="hljs-built_in">Math</span>.max(axis.max, options.softMax);
                }
                <span class="hljs-keyword">if</span> (softThreshold &amp;&amp; defined(axis.dataMin)) {
                    threshold = threshold || <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">if</span> (!defined(hardMin) &amp;&amp; axis.min &lt; threshold &amp;&amp; axis.dataMin &gt;= threshold) {
                        axis.min = threshold;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!defined(hardMax) &amp;&amp; axis.max &gt; threshold &amp;&amp; axis.dataMax &lt;= threshold) {
                        axis.max = threshold;
                    }
                }
                <span class="hljs-keyword">if</span> (axis.min === axis.max || axis.min === <span class="hljs-literal">undefined</span> || axis.max === <span class="hljs-literal">undefined</span>) {
                    axis.tickInterval = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isLinked &amp;&amp; !tickIntervalOption &amp;&amp;
                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
                } <span class="hljs-keyword">else</span> {
                    axis.tickInterval = pick(
                        tickIntervalOption,
                        <span class="hljs-keyword">this</span>.tickAmount ? ((axis.max - axis.min) / <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.tickAmount - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) : <span class="hljs-literal">undefined</span>,
                        categories ?
                        <span class="hljs-number">1</span> :
                        (axis.max - axis.min) * tickPixelIntervalOption / <span class="hljs-built_in">Math</span>.max(axis.len, tickPixelIntervalOption)
                    );
                }
                <span class="hljs-keyword">if</span> (isXAxis &amp;&amp; !secondPass) {
                    each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);
                    });
                }
                axis.setAxisTranslation(<span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (axis.beforeSetTickPositions) {
                    axis.beforeSetTickPositions();
                }
                <span class="hljs-keyword">if</span> (axis.postProcessTickInterval) {
                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);
                }
                <span class="hljs-keyword">if</span> (axis.pointRange &amp;&amp; !tickIntervalOption) {
                    axis.tickInterval = <span class="hljs-built_in">Math</span>.max(axis.pointRange, axis.tickInterval);
                }
                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis &amp;&amp; axis.closestPointRange);
                <span class="hljs-keyword">if</span> (!tickIntervalOption &amp;&amp; axis.tickInterval &lt; minTickInterval) {
                    axis.tickInterval = minTickInterval;
                }
                <span class="hljs-keyword">if</span> (!isDatetimeAxis &amp;&amp; !isLog &amp;&amp; !tickIntervalOption) {
                    axis.tickInterval = normalizeTickInterval(
                        axis.tickInterval,
                        <span class="hljs-literal">null</span>,
                        getMagnitude(axis.tickInterval),
                        pick(options.allowDecimals, !(axis.tickInterval &gt; <span class="hljs-number">0.5</span> &amp;&amp; axis.tickInterval &lt; <span class="hljs-number">5</span> &amp;&amp; axis.max &gt; <span class="hljs-number">1000</span> &amp;&amp; axis.max &lt; <span class="hljs-number">9999</span>)), !!<span class="hljs-keyword">this</span>.tickAmount
                    );
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.tickAmount) {
                    axis.tickInterval = axis.unsquish();
                }
                <span class="hljs-keyword">this</span>.setTickPositions();
            },
            <span class="hljs-attr">setTickPositions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    tickPositions,
                    tickPositionsOption = options.tickPositions,
                    tickPositioner = options.tickPositioner,
                    startOnTick = options.startOnTick,
                    endOnTick = options.endOnTick,
                    single;
                <span class="hljs-keyword">this</span>.tickmarkOffset = (<span class="hljs-keyword">this</span>.categories &amp;&amp; options.tickmarkPlacement === <span class="hljs-string">'between'</span> &amp;&amp;
                    <span class="hljs-keyword">this</span>.tickInterval === <span class="hljs-number">1</span>) ? <span class="hljs-number">0.5</span> : <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.minorTickInterval = options.minorTickInterval === <span class="hljs-string">'auto'</span> &amp;&amp; <span class="hljs-keyword">this</span>.tickInterval ?
                    <span class="hljs-keyword">this</span>.tickInterval / <span class="hljs-number">5</span> : options.minorTickInterval;
                <span class="hljs-keyword">this</span>.tickPositions = tickPositions = tickPositionsOption &amp;&amp; tickPositionsOption.slice();
                <span class="hljs-keyword">if</span> (!tickPositions) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDatetimeAxis) {
                        tickPositions = <span class="hljs-keyword">this</span>.getTimeTicks(
                            <span class="hljs-keyword">this</span>.normalizeTimeTickInterval(<span class="hljs-keyword">this</span>.tickInterval, options.units),
                            <span class="hljs-keyword">this</span>.min,
                            <span class="hljs-keyword">this</span>.max,
                            options.startOfWeek,
                            <span class="hljs-keyword">this</span>.ordinalPositions,
                            <span class="hljs-keyword">this</span>.closestPointRange,
                            <span class="hljs-literal">true</span>
                        );
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isLog) {
                        tickPositions = <span class="hljs-keyword">this</span>.getLogTickPositions(<span class="hljs-keyword">this</span>.tickInterval, <span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.max);
                    } <span class="hljs-keyword">else</span> {
                        tickPositions = <span class="hljs-keyword">this</span>.getLinearTickPositions(<span class="hljs-keyword">this</span>.tickInterval, <span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.max);
                    }
                    <span class="hljs-keyword">if</span> (tickPositions.length &gt; <span class="hljs-keyword">this</span>.len) {
                        tickPositions = [tickPositions[<span class="hljs-number">0</span>], tickPositions.pop()];
                    }
                    <span class="hljs-keyword">this</span>.tickPositions = tickPositions;
                    <span class="hljs-keyword">if</span> (tickPositioner) {
                        tickPositioner = tickPositioner.apply(<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.max]);
                        <span class="hljs-keyword">if</span> (tickPositioner) {
                            <span class="hljs-keyword">this</span>.tickPositions = tickPositions = tickPositioner;
                        }
                    }
                }
                <span class="hljs-keyword">this</span>.trimTicks(tickPositions, startOnTick, endOnTick);
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isLinked) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.min === <span class="hljs-keyword">this</span>.max &amp;&amp; defined(<span class="hljs-keyword">this</span>.min) &amp;&amp; !<span class="hljs-keyword">this</span>.tickAmount) {
                        single = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">this</span>.min -= <span class="hljs-number">0.5</span>;
                        <span class="hljs-keyword">this</span>.max += <span class="hljs-number">0.5</span>;
                    }
                    <span class="hljs-keyword">this</span>.single = single;
                    <span class="hljs-keyword">if</span> (!tickPositionsOption &amp;&amp; !tickPositioner) {
                        <span class="hljs-keyword">this</span>.adjustTickAmount();
                    }
                }
            },
            <span class="hljs-attr">trimTicks</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tickPositions, startOnTick, endOnTick</span>) </span>{
                <span class="hljs-keyword">var</span> roundedMin = tickPositions[<span class="hljs-number">0</span>],
                    roundedMax = tickPositions[tickPositions.length - <span class="hljs-number">1</span>],
                    minPointOffset = <span class="hljs-keyword">this</span>.minPointOffset || <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isLinked) {
                    <span class="hljs-keyword">if</span> (startOnTick) {
                        <span class="hljs-keyword">this</span>.min = roundedMin;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.min - minPointOffset &gt; tickPositions[<span class="hljs-number">0</span>]) {
                            tickPositions.shift();
                        }
                    }
                    <span class="hljs-keyword">if</span> (endOnTick) {
                        <span class="hljs-keyword">this</span>.max = roundedMax;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.max + minPointOffset &lt; tickPositions[tickPositions.length - <span class="hljs-number">1</span>]) {
                            tickPositions.pop();
                        }
                    }
                    <span class="hljs-keyword">if</span> (tickPositions.length === <span class="hljs-number">0</span> &amp;&amp; defined(roundedMin)) {
                        tickPositions.push((roundedMax + roundedMin) / <span class="hljs-number">2</span>);
                    }
                }
            },
            <span class="hljs-attr">alignToOthers</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> others = {},
                    hasOther,
                    options = <span class="hljs-keyword">this</span>.options;
                <span class="hljs-keyword">if</span> (
                    <span class="hljs-keyword">this</span>.chart.options.chart.alignTicks !== <span class="hljs-literal">false</span> &amp;&amp;
                    options.alignTicks !== <span class="hljs-literal">false</span> &amp;&amp;
                    !<span class="hljs-keyword">this</span>.isLog
                ) {
                    each(<span class="hljs-keyword">this</span>.chart[<span class="hljs-keyword">this</span>.coll], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">var</span> otherOptions = axis.options,
                            horiz = axis.horiz,
                            key = [
                                horiz ? otherOptions.left : otherOptions.top,
                                otherOptions.width,
                                otherOptions.height,
                                otherOptions.pane
                            ].join(<span class="hljs-string">','</span>);
                        <span class="hljs-keyword">if</span> (axis.series.length) {
                            <span class="hljs-keyword">if</span> (others[key]) {
                                hasOther = <span class="hljs-literal">true</span>;
                            } <span class="hljs-keyword">else</span> {
                                others[key] = <span class="hljs-number">1</span>;
                            }
                        }
                    });
                }
                <span class="hljs-keyword">return</span> hasOther;
            },
            <span class="hljs-attr">getTickAmount</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    tickAmount = options.tickAmount,
                    tickPixelInterval = options.tickPixelInterval;
                <span class="hljs-keyword">if</span> (!defined(options.tickInterval) &amp;&amp; <span class="hljs-keyword">this</span>.len &lt; tickPixelInterval &amp;&amp; !<span class="hljs-keyword">this</span>.isRadial &amp;&amp;
                    !<span class="hljs-keyword">this</span>.isLog &amp;&amp; options.startOnTick &amp;&amp; options.endOnTick) {
                    tickAmount = <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (!tickAmount &amp;&amp; <span class="hljs-keyword">this</span>.alignToOthers()) {
                    tickAmount = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-keyword">this</span>.len / tickPixelInterval) + <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">if</span> (tickAmount &lt; <span class="hljs-number">4</span>) {
                    <span class="hljs-keyword">this</span>.finalTickAmt = tickAmount;
                    tickAmount = <span class="hljs-number">5</span>;
                }
                <span class="hljs-keyword">this</span>.tickAmount = tickAmount;
            },
            <span class="hljs-attr">adjustTickAmount</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> tickInterval = <span class="hljs-keyword">this</span>.tickInterval,
                    tickPositions = <span class="hljs-keyword">this</span>.tickPositions,
                    tickAmount = <span class="hljs-keyword">this</span>.tickAmount,
                    finalTickAmt = <span class="hljs-keyword">this</span>.finalTickAmt,
                    currentTickAmount = tickPositions &amp;&amp; tickPositions.length,
                    i,
                    len;
                <span class="hljs-keyword">if</span> (currentTickAmount &lt; tickAmount) {
                    <span class="hljs-keyword">while</span> (tickPositions.length &lt; tickAmount) {
                        tickPositions.push(correctFloat(
                            tickPositions[tickPositions.length - <span class="hljs-number">1</span>] + tickInterval
                        ));
                    }
                    <span class="hljs-keyword">this</span>.transA *= (currentTickAmount - <span class="hljs-number">1</span>) / (tickAmount - <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">this</span>.max = tickPositions[tickPositions.length - <span class="hljs-number">1</span>];
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentTickAmount &gt; tickAmount) {
                    <span class="hljs-keyword">this</span>.tickInterval *= <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">this</span>.setTickPositions();
                }
                <span class="hljs-keyword">if</span> (defined(finalTickAmt)) {
                    i = len = tickPositions.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (
                            (finalTickAmt === <span class="hljs-number">3</span> &amp;&amp; i % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) ||
                            (finalTickAmt &lt;= <span class="hljs-number">2</span> &amp;&amp; i &gt; <span class="hljs-number">0</span> &amp;&amp; i &lt; len - <span class="hljs-number">1</span>)
                        ) {
                            tickPositions.splice(i, <span class="hljs-number">1</span>);
                        }
                    }
                    <span class="hljs-keyword">this</span>.finalTickAmt = <span class="hljs-literal">undefined</span>;
                }
            },
            <span class="hljs-attr">setScale</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    isDirtyData,
                    isDirtyAxisLength;
                axis.oldMin = axis.min;
                axis.oldMax = axis.max;
                axis.oldAxisLength = axis.len;
                axis.setAxisSize();
                isDirtyAxisLength = axis.len !== axis.oldAxisLength;
                each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">if</span> (series.isDirtyData || series.isDirty ||
                        series.xAxis.isDirty) {
                        isDirtyData = <span class="hljs-literal">true</span>;
                    }
                });
                <span class="hljs-keyword">if</span> (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||
                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {
                    <span class="hljs-keyword">if</span> (axis.resetStacks) {
                        axis.resetStacks();
                    }
                    axis.forceRedraw = <span class="hljs-literal">false</span>;
                    axis.getSeriesExtremes();
                    axis.setTickInterval();
                    axis.oldUserMin = axis.userMin;
                    axis.oldUserMax = axis.userMax;
                    <span class="hljs-keyword">if</span> (!axis.isDirty) {
                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.cleanStacks) {
                    axis.cleanStacks();
                }
            },
            <span class="hljs-attr">setExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newMin, newMax, redraw, animation, eventArguments</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart;
                redraw = pick(redraw, <span class="hljs-literal">true</span>);
                each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    <span class="hljs-keyword">delete</span> serie.kdTree;
                });
                eventArguments = extend(eventArguments, {
                    <span class="hljs-attr">min</span>: newMin,
                    <span class="hljs-attr">max</span>: newMax
                });
                fireEvent(axis, <span class="hljs-string">'setExtremes'</span>, eventArguments, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    axis.userMin = newMin;
                    axis.userMax = newMax;
                    axis.eventArgs = eventArguments;
                    <span class="hljs-keyword">if</span> (redraw) {
                        chart.redraw(animation);
                    }
                });
            },
            <span class="hljs-attr">zoom</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newMin, newMax</span>) </span>{
                <span class="hljs-keyword">var</span> dataMin = <span class="hljs-keyword">this</span>.dataMin,
                    dataMax = <span class="hljs-keyword">this</span>.dataMax,
                    options = <span class="hljs-keyword">this</span>.options,
                    min = <span class="hljs-built_in">Math</span>.min(dataMin, pick(options.min, dataMin)),
                    max = <span class="hljs-built_in">Math</span>.max(dataMax, pick(options.max, dataMax));
                <span class="hljs-keyword">if</span> (newMin !== <span class="hljs-keyword">this</span>.min || newMax !== <span class="hljs-keyword">this</span>.max) {
                    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowZoomOutside) {
                        <span class="hljs-keyword">if</span> (defined(dataMin)) {
                            <span class="hljs-keyword">if</span> (newMin &lt; min) {
                                newMin = min;
                            }
                            <span class="hljs-keyword">if</span> (newMin &gt; max) {
                                newMin = max;
                            }
                        }
                        <span class="hljs-keyword">if</span> (defined(dataMax)) {
                            <span class="hljs-keyword">if</span> (newMax &lt; min) {
                                newMax = min;
                            }
                            <span class="hljs-keyword">if</span> (newMax &gt; max) {
                                newMax = max;
                            }
                        }
                    }
                    <span class="hljs-keyword">this</span>.displayBtn = newMin !== <span class="hljs-literal">undefined</span> || newMax !== <span class="hljs-literal">undefined</span>;
                    <span class="hljs-keyword">this</span>.setExtremes(
                        newMin,
                        newMax,
                        <span class="hljs-literal">false</span>,
                        <span class="hljs-literal">undefined</span>, {
                            <span class="hljs-attr">trigger</span>: <span class="hljs-string">'zoom'</span>
                        }
                    );
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">setAxisSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    options = <span class="hljs-keyword">this</span>.options,
                    offsets = options.offsets || [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                    horiz = <span class="hljs-keyword">this</span>.horiz,
                    width = pick(options.width, chart.plotWidth - offsets[<span class="hljs-number">3</span>] + offsets[<span class="hljs-number">1</span>]),
                    height = pick(options.height, chart.plotHeight - offsets[<span class="hljs-number">0</span>] + offsets[<span class="hljs-number">2</span>]),
                    top = pick(options.top, chart.plotTop + offsets[<span class="hljs-number">0</span>]),
                    left = pick(options.left, chart.plotLeft + offsets[<span class="hljs-number">3</span>]),
                    percentRegex = <span class="hljs-regexp">/%$/</span>;
                <span class="hljs-keyword">if</span> (percentRegex.test(height)) {
                    height = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">parseFloat</span>(height) / <span class="hljs-number">100</span> * chart.plotHeight);
                }
                <span class="hljs-keyword">if</span> (percentRegex.test(top)) {
                    top = <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">parseFloat</span>(top) / <span class="hljs-number">100</span> * chart.plotHeight + chart.plotTop);
                }
                <span class="hljs-keyword">this</span>.left = left;
                <span class="hljs-keyword">this</span>.top = top;
                <span class="hljs-keyword">this</span>.width = width;
                <span class="hljs-keyword">this</span>.height = height;
                <span class="hljs-keyword">this</span>.bottom = chart.chartHeight - height - top;
                <span class="hljs-keyword">this</span>.right = chart.chartWidth - width - left;
                <span class="hljs-keyword">this</span>.len = <span class="hljs-built_in">Math</span>.max(horiz ? width : height, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">this</span>.pos = horiz ? left : top;
            },
            <span class="hljs-attr">getExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    isLog = axis.isLog,
                    lin2log = axis.lin2log;
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">min</span>: isLog ? correctFloat(lin2log(axis.min)) : axis.min,
                    <span class="hljs-attr">max</span>: isLog ? correctFloat(lin2log(axis.max)) : axis.max,
                    <span class="hljs-attr">dataMin</span>: axis.dataMin,
                    <span class="hljs-attr">dataMax</span>: axis.dataMax,
                    <span class="hljs-attr">userMin</span>: axis.userMin,
                    <span class="hljs-attr">userMax</span>: axis.userMax
                };
            },
            <span class="hljs-attr">getThreshold</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">threshold</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    isLog = axis.isLog,
                    lin2log = axis.lin2log,
                    realMin = isLog ? lin2log(axis.min) : axis.min,
                    realMax = isLog ? lin2log(axis.max) : axis.max;
                <span class="hljs-keyword">if</span> (threshold === <span class="hljs-literal">null</span>) {
                    threshold = realMin;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (realMin &gt; threshold) {
                    threshold = realMin;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (realMax &lt; threshold) {
                    threshold = realMax;
                }
                <span class="hljs-keyword">return</span> axis.translate(threshold, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">autoLabelAlign</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rotation</span>) </span>{
                <span class="hljs-keyword">var</span> ret,
                    angle = (pick(rotation, <span class="hljs-number">0</span>) - (<span class="hljs-keyword">this</span>.side * <span class="hljs-number">90</span>) + <span class="hljs-number">720</span>) % <span class="hljs-number">360</span>;
                <span class="hljs-keyword">if</span> (angle &gt; <span class="hljs-number">15</span> &amp;&amp; angle &lt; <span class="hljs-number">165</span>) {
                    ret = <span class="hljs-string">'right'</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (angle &gt; <span class="hljs-number">195</span> &amp;&amp; angle &lt; <span class="hljs-number">345</span>) {
                    ret = <span class="hljs-string">'left'</span>;
                } <span class="hljs-keyword">else</span> {
                    ret = <span class="hljs-string">'center'</span>;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">tickSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prefix</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    tickLength = options[prefix + <span class="hljs-string">'Length'</span>],
                    tickWidth = pick(options[prefix + <span class="hljs-string">'Width'</span>], prefix === <span class="hljs-string">'tick'</span> &amp;&amp; <span class="hljs-keyword">this</span>.isXAxis ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (tickWidth &amp;&amp; tickLength) {
                    <span class="hljs-keyword">if</span> (options[prefix + <span class="hljs-string">'Position'</span>] === <span class="hljs-string">'inside'</span>) {
                        tickLength = -tickLength;
                    }
                    <span class="hljs-keyword">return</span> [tickLength, tickWidth];
                }
            },
            <span class="hljs-attr">labelMetrics</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.chart.renderer.fontMetrics(
                    <span class="hljs-keyword">this</span>.options.labels.style &amp;&amp; <span class="hljs-keyword">this</span>.options.labels.style.fontSize,
                    <span class="hljs-keyword">this</span>.ticks[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">this</span>.ticks[<span class="hljs-number">0</span>].label
                );
            },
            <span class="hljs-attr">unsquish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> labelOptions = <span class="hljs-keyword">this</span>.options.labels,
                    horiz = <span class="hljs-keyword">this</span>.horiz,
                    tickInterval = <span class="hljs-keyword">this</span>.tickInterval,
                    newTickInterval = tickInterval,
                    slotSize = <span class="hljs-keyword">this</span>.len / (((<span class="hljs-keyword">this</span>.categories ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) + <span class="hljs-keyword">this</span>.max - <span class="hljs-keyword">this</span>.min) / tickInterval),
                    rotation,
                    rotationOption = labelOptions.rotation,
                    labelMetrics = <span class="hljs-keyword">this</span>.labelMetrics(),
                    step,
                    bestScore = <span class="hljs-built_in">Number</span>.MAX_VALUE,
                    autoRotation,
                    getStep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">spaceNeeded</span>) </span>{
                        <span class="hljs-keyword">var</span> step = spaceNeeded / (slotSize || <span class="hljs-number">1</span>);
                        step = step &gt; <span class="hljs-number">1</span> ? <span class="hljs-built_in">Math</span>.ceil(step) : <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">return</span> step * tickInterval;
                    };
                <span class="hljs-keyword">if</span> (horiz) {
                    autoRotation = !labelOptions.staggerLines &amp;&amp; !labelOptions.step &amp;&amp; (
                        defined(rotationOption) ? [rotationOption] :
                        slotSize &lt; pick(labelOptions.autoRotationLimit, <span class="hljs-number">80</span>) &amp;&amp; labelOptions.autoRotation
                    );
                    <span class="hljs-keyword">if</span> (autoRotation) {
                        each(autoRotation, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rot</span>) </span>{
                            <span class="hljs-keyword">var</span> score;
                            <span class="hljs-keyword">if</span> (rot === rotationOption || (rot &amp;&amp; rot &gt;= <span class="hljs-number">-90</span> &amp;&amp; rot &lt;= <span class="hljs-number">90</span>)) {
                                step = getStep(<span class="hljs-built_in">Math</span>.abs(labelMetrics.h / <span class="hljs-built_in">Math</span>.sin(deg2rad * rot)));
                                score = step + <span class="hljs-built_in">Math</span>.abs(rot / <span class="hljs-number">360</span>);
                                <span class="hljs-keyword">if</span> (score &lt; bestScore) {
                                    bestScore = score;
                                    rotation = rot;
                                    newTickInterval = step;
                                }
                            }
                        });
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!labelOptions.step) {
                    newTickInterval = getStep(labelMetrics.h);
                }
                <span class="hljs-keyword">this</span>.autoRotation = autoRotation;
                <span class="hljs-keyword">this</span>.labelRotation = pick(rotation, rotationOption);
                <span class="hljs-keyword">return</span> newTickInterval;
            },
            <span class="hljs-attr">getSlotWidth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    horiz = <span class="hljs-keyword">this</span>.horiz,
                    labelOptions = <span class="hljs-keyword">this</span>.options.labels,
                    slotCount = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.tickPositions.length - (<span class="hljs-keyword">this</span>.categories ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>), <span class="hljs-number">1</span>),
                    marginLeft = chart.margin[<span class="hljs-number">3</span>];
                <span class="hljs-keyword">return</span> (
                    horiz &amp;&amp;
                    (labelOptions.step || <span class="hljs-number">0</span>) &lt; <span class="hljs-number">2</span> &amp;&amp;
                    !labelOptions.rotation &amp;&amp;
                    ((<span class="hljs-keyword">this</span>.staggerLines || <span class="hljs-number">1</span>) * <span class="hljs-keyword">this</span>.len) / slotCount
                ) || (!horiz &amp;&amp; (
                    (marginLeft &amp;&amp; (marginLeft - chart.spacing[<span class="hljs-number">3</span>])) ||
                    chart.chartWidth * <span class="hljs-number">0.33</span>
                ));
            },
            <span class="hljs-attr">renderUnsquish</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    renderer = chart.renderer,
                    tickPositions = <span class="hljs-keyword">this</span>.tickPositions,
                    ticks = <span class="hljs-keyword">this</span>.ticks,
                    labelOptions = <span class="hljs-keyword">this</span>.options.labels,
                    horiz = <span class="hljs-keyword">this</span>.horiz,
                    slotWidth = <span class="hljs-keyword">this</span>.getSlotWidth(),
                    innerWidth = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">1</span>, <span class="hljs-built_in">Math</span>.round(slotWidth - <span class="hljs-number">2</span> * (labelOptions.padding || <span class="hljs-number">5</span>))),
                    attr = {},
                    labelMetrics = <span class="hljs-keyword">this</span>.labelMetrics(),
                    textOverflowOption = labelOptions.style &amp;&amp; labelOptions.style.textOverflow,
                    css,
                    maxLabelLength = <span class="hljs-number">0</span>,
                    label,
                    i,
                    pos;
                <span class="hljs-keyword">if</span> (!isString(labelOptions.rotation)) {
                    attr.rotation = labelOptions.rotation || <span class="hljs-number">0</span>;
                }
                each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tick</span>) </span>{
                    tick = ticks[tick];
                    <span class="hljs-keyword">if</span> (tick &amp;&amp; tick.labelLength &gt; maxLabelLength) {
                        maxLabelLength = tick.labelLength;
                    }
                });
                <span class="hljs-keyword">this</span>.maxLabelLength = maxLabelLength;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoRotation) {
                    <span class="hljs-keyword">if</span> (maxLabelLength &gt; innerWidth &amp;&amp; maxLabelLength &gt; labelMetrics.h) {
                        attr.rotation = <span class="hljs-keyword">this</span>.labelRotation;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.labelRotation = <span class="hljs-number">0</span>;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slotWidth) {
                    css = {
                        <span class="hljs-attr">width</span>: innerWidth + <span class="hljs-string">'px'</span>
                    };
                    <span class="hljs-keyword">if</span> (!textOverflowOption) {
                        css.textOverflow = <span class="hljs-string">'clip'</span>;
                        i = tickPositions.length;
                        <span class="hljs-keyword">while</span> (!horiz &amp;&amp; i--) {
                            pos = tickPositions[i];
                            label = ticks[pos].label;
                            <span class="hljs-keyword">if</span> (label) {
                                <span class="hljs-keyword">if</span> (label.styles &amp;&amp; label.styles.textOverflow === <span class="hljs-string">'ellipsis'</span>) {
                                    label.css({
                                        <span class="hljs-attr">textOverflow</span>: <span class="hljs-string">'clip'</span>
                                    });
                                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ticks[pos].labelLength &gt; slotWidth) {
                                    label.css({
                                        <span class="hljs-attr">width</span>: slotWidth + <span class="hljs-string">'px'</span>
                                    });
                                }
                                <span class="hljs-keyword">if</span> (label.getBBox().height &gt; <span class="hljs-keyword">this</span>.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                                    label.specCss = {
                                        <span class="hljs-attr">textOverflow</span>: <span class="hljs-string">'ellipsis'</span>
                                    };
                                }
                            }
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (attr.rotation) {
                    css = {
                        <span class="hljs-attr">width</span>: (maxLabelLength &gt; chart.chartHeight * <span class="hljs-number">0.5</span> ? chart.chartHeight * <span class="hljs-number">0.33</span> : chart.chartHeight) + <span class="hljs-string">'px'</span>
                    };
                    <span class="hljs-keyword">if</span> (!textOverflowOption) {
                        css.textOverflow = <span class="hljs-string">'ellipsis'</span>;
                    }
                }
                <span class="hljs-keyword">this</span>.labelAlign = labelOptions.align || <span class="hljs-keyword">this</span>.autoLabelAlign(<span class="hljs-keyword">this</span>.labelRotation);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.labelAlign) {
                    attr.align = <span class="hljs-keyword">this</span>.labelAlign;
                }
                each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
                    <span class="hljs-keyword">var</span> tick = ticks[pos],
                        label = tick &amp;&amp; tick.label;
                    <span class="hljs-keyword">if</span> (label) {
                        label.attr(attr);
                        <span class="hljs-keyword">if</span> (css) {
                            label.css(merge(css, label.specCss));
                        }
                        <span class="hljs-keyword">delete</span> label.specCss;
                        tick.rotation = attr.rotation;
                    }
                });
                <span class="hljs-keyword">this</span>.tickRotCorr = renderer.rotCorr(labelMetrics.b, <span class="hljs-keyword">this</span>.labelRotation || <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.side !== <span class="hljs-number">0</span>);
            },
            <span class="hljs-attr">hasData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hasVisibleSeries || (defined(<span class="hljs-keyword">this</span>.min) &amp;&amp; defined(<span class="hljs-keyword">this</span>.max) &amp;&amp; !!<span class="hljs-keyword">this</span>.tickPositions);
            },
            <span class="hljs-attr">addTitle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">display</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    renderer = axis.chart.renderer,
                    horiz = axis.horiz,
                    opposite = axis.opposite,
                    options = axis.options,
                    axisTitleOptions = options.title,
                    textAlign;
                <span class="hljs-keyword">if</span> (!axis.axisTitle) {
                    textAlign = axisTitleOptions.textAlign;
                    <span class="hljs-keyword">if</span> (!textAlign) {
                        textAlign = (horiz ? {
                            <span class="hljs-attr">low</span>: <span class="hljs-string">'left'</span>,
                            <span class="hljs-attr">middle</span>: <span class="hljs-string">'center'</span>,
                            <span class="hljs-attr">high</span>: <span class="hljs-string">'right'</span>
                        } : {
                            <span class="hljs-attr">low</span>: opposite ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>,
                            <span class="hljs-attr">middle</span>: <span class="hljs-string">'center'</span>,
                            <span class="hljs-attr">high</span>: opposite ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'right'</span>
                        })[axisTitleOptions.align];
                    }
                    axis.axisTitle = renderer.text(
                            axisTitleOptions.text,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            axisTitleOptions.useHTML
                        )
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">7</span>,
                            <span class="hljs-attr">rotation</span>: axisTitleOptions.rotation || <span class="hljs-number">0</span>,
                            <span class="hljs-attr">align</span>: textAlign
                        })
                        .addClass(<span class="hljs-string">'highcharts-axis-title'</span>)
                        .css(axisTitleOptions.style)
                        .add(axis.axisGroup);
                    axis.axisTitle.isNew = <span class="hljs-literal">true</span>;
                }
                axis.axisTitle[display ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>](<span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">generateTick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
                <span class="hljs-keyword">var</span> ticks = <span class="hljs-keyword">this</span>.ticks;
                <span class="hljs-keyword">if</span> (!ticks[pos]) {
                    ticks[pos] = <span class="hljs-keyword">new</span> Tick(<span class="hljs-keyword">this</span>, pos);
                } <span class="hljs-keyword">else</span> {
                    ticks[pos].addLabel();
                }
            },
            <span class="hljs-attr">getOffset</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    options = axis.options,
                    tickPositions = axis.tickPositions,
                    ticks = axis.ticks,
                    horiz = axis.horiz,
                    side = axis.side,
                    invertedSide = chart.inverted ? [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>][side] : side,
                    hasData,
                    showAxis,
                    titleOffset = <span class="hljs-number">0</span>,
                    titleOffsetOption,
                    titleMargin = <span class="hljs-number">0</span>,
                    axisTitleOptions = options.title,
                    labelOptions = options.labels,
                    labelOffset = <span class="hljs-number">0</span>,
                    labelOffsetPadded,
                    axisOffset = chart.axisOffset,
                    clipOffset = chart.clipOffset,
                    clip,
                    directionFactor = [<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>][side],
                    n,
                    className = options.className,
                    axisParent = axis.axisParent,
                    lineHeightCorrection,
                    tickSize = <span class="hljs-keyword">this</span>.tickSize(<span class="hljs-string">'tick'</span>);
                hasData = axis.hasData();
                axis.showAxis = showAxis = hasData || pick(options.showEmpty, <span class="hljs-literal">true</span>);
                axis.staggerLines = axis.horiz &amp;&amp; labelOptions.staggerLines;
                <span class="hljs-keyword">if</span> (!axis.axisGroup) {
                    axis.gridGroup = renderer.g(<span class="hljs-string">'grid'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: options.gridZIndex || <span class="hljs-number">1</span>
                        })
                        .addClass(<span class="hljs-string">'highcharts-'</span> + <span class="hljs-keyword">this</span>.coll.toLowerCase() + <span class="hljs-string">'-grid '</span> + (className || <span class="hljs-string">''</span>))
                        .add(axisParent);
                    axis.axisGroup = renderer.g(<span class="hljs-string">'axis'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: options.zIndex || <span class="hljs-number">2</span>
                        })
                        .addClass(<span class="hljs-string">'highcharts-'</span> + <span class="hljs-keyword">this</span>.coll.toLowerCase() + <span class="hljs-string">' '</span> + (className || <span class="hljs-string">''</span>))
                        .add(axisParent);
                    axis.labelGroup = renderer.g(<span class="hljs-string">'axis-labels'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: labelOptions.zIndex || <span class="hljs-number">7</span>
                        })
                        .addClass(<span class="hljs-string">'highcharts-'</span> + axis.coll.toLowerCase() + <span class="hljs-string">'-labels '</span> + (className || <span class="hljs-string">''</span>))
                        .add(axisParent);
                }
                <span class="hljs-keyword">if</span> (hasData || axis.isLinked) {
                    each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, i</span>) </span>{
                        axis.generateTick(pos, i);
                    });
                    axis.renderUnsquish();
                    <span class="hljs-keyword">if</span> (labelOptions.reserveSpace !== <span class="hljs-literal">false</span> &amp;&amp; (side === <span class="hljs-number">0</span> || side === <span class="hljs-number">2</span> || {
                            <span class="hljs-number">1</span>: <span class="hljs-string">'left'</span>,
                            <span class="hljs-number">3</span>: <span class="hljs-string">'right'</span>
                        }[side] === axis.labelAlign || axis.labelAlign === <span class="hljs-string">'center'</span>)) {
                        each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
                            labelOffset = <span class="hljs-built_in">Math</span>.max(
                                ticks[pos].getLabelSize(),
                                labelOffset
                            );
                        });
                    }
                    <span class="hljs-keyword">if</span> (axis.staggerLines) {
                        labelOffset *= axis.staggerLines;
                        axis.labelOffset = labelOffset * (axis.opposite ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> ticks) {
                        ticks[n].destroy();
                        <span class="hljs-keyword">delete</span> ticks[n];
                    }
                }
                <span class="hljs-keyword">if</span> (axisTitleOptions &amp;&amp; axisTitleOptions.text &amp;&amp; axisTitleOptions.enabled !== <span class="hljs-literal">false</span>) {
                    axis.addTitle(showAxis);
                    <span class="hljs-keyword">if</span> (showAxis) {
                        titleOffset = axis.axisTitle.getBBox()[horiz ? <span class="hljs-string">'height'</span> : <span class="hljs-string">'width'</span>];
                        titleOffsetOption = axisTitleOptions.offset;
                        titleMargin = defined(titleOffsetOption) ? <span class="hljs-number">0</span> : pick(axisTitleOptions.margin, horiz ? <span class="hljs-number">5</span> : <span class="hljs-number">10</span>);
                    }
                }
                axis.renderLine();
                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);
                axis.tickRotCorr = axis.tickRotCorr || {
                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
                };
                <span class="hljs-keyword">if</span> (side === <span class="hljs-number">0</span>) {
                    lineHeightCorrection = -axis.labelMetrics().h;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (side === <span class="hljs-number">2</span>) {
                    lineHeightCorrection = axis.tickRotCorr.y;
                } <span class="hljs-keyword">else</span> {
                    lineHeightCorrection = <span class="hljs-number">0</span>;
                }
                labelOffsetPadded = <span class="hljs-built_in">Math</span>.abs(labelOffset) + titleMargin;
                <span class="hljs-keyword">if</span> (labelOffset) {
                    labelOffsetPadded -= lineHeightCorrection;
                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * <span class="hljs-number">8</span>) : labelOptions.x);
                }
                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);
                axisOffset[side] = <span class="hljs-built_in">Math</span>.max(
                    axisOffset[side],
                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,
                    labelOffsetPadded,
                    hasData &amp;&amp; tickPositions.length &amp;&amp; tickSize ? tickSize[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>
                );
                clip = options.offset ? <span class="hljs-number">0</span> : <span class="hljs-built_in">Math</span>.floor(axis.axisLine.strokeWidth() / <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;
                clipOffset[invertedSide] = <span class="hljs-built_in">Math</span>.max(clipOffset[invertedSide], clip);
            },
            <span class="hljs-attr">getLinePath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">lineWidth</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    opposite = <span class="hljs-keyword">this</span>.opposite,
                    offset = <span class="hljs-keyword">this</span>.offset,
                    horiz = <span class="hljs-keyword">this</span>.horiz,
                    lineLeft = <span class="hljs-keyword">this</span>.left + (opposite ? <span class="hljs-keyword">this</span>.width : <span class="hljs-number">0</span>) + offset,
                    lineTop = chart.chartHeight - <span class="hljs-keyword">this</span>.bottom - (opposite ? <span class="hljs-keyword">this</span>.height : <span class="hljs-number">0</span>) + offset;
                <span class="hljs-keyword">if</span> (opposite) {
                    lineWidth *= <span class="hljs-number">-1</span>;
                }
                <span class="hljs-keyword">return</span> chart.renderer
                    .crispLine([
                        <span class="hljs-string">'M'</span>,
                        horiz ?
                        <span class="hljs-keyword">this</span>.left :
                        lineLeft,
                        horiz ?
                        lineTop :
                        <span class="hljs-keyword">this</span>.top,
                        <span class="hljs-string">'L'</span>,
                        horiz ?
                        chart.chartWidth - <span class="hljs-keyword">this</span>.right :
                        lineLeft,
                        horiz ?
                        lineTop :
                        chart.chartHeight - <span class="hljs-keyword">this</span>.bottom
                    ], lineWidth);
            },
            <span class="hljs-attr">renderLine</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.axisLine) {
                    <span class="hljs-keyword">this</span>.axisLine = <span class="hljs-keyword">this</span>.chart.renderer.path()
                        .addClass(<span class="hljs-string">'highcharts-axis-line'</span>)
                        .add(<span class="hljs-keyword">this</span>.axisGroup);
                    <span class="hljs-keyword">this</span>.axisLine.attr({
                        <span class="hljs-attr">stroke</span>: <span class="hljs-keyword">this</span>.options.lineColor,
                        <span class="hljs-string">'stroke-width'</span>: <span class="hljs-keyword">this</span>.options.lineWidth,
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">7</span>
                    });
                }
            },
            <span class="hljs-attr">getTitlePosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> horiz = <span class="hljs-keyword">this</span>.horiz,
                    axisLeft = <span class="hljs-keyword">this</span>.left,
                    axisTop = <span class="hljs-keyword">this</span>.top,
                    axisLength = <span class="hljs-keyword">this</span>.len,
                    axisTitleOptions = <span class="hljs-keyword">this</span>.options.title,
                    margin = horiz ? axisLeft : axisTop,
                    opposite = <span class="hljs-keyword">this</span>.opposite,
                    offset = <span class="hljs-keyword">this</span>.offset,
                    xOption = axisTitleOptions.x || <span class="hljs-number">0</span>,
                    yOption = axisTitleOptions.y || <span class="hljs-number">0</span>,
                    fontSize = <span class="hljs-keyword">this</span>.chart.renderer.fontMetrics(axisTitleOptions.style &amp;&amp; axisTitleOptions.style.fontSize, <span class="hljs-keyword">this</span>.axisTitle).f,
                    alongAxis = {
                        <span class="hljs-attr">low</span>: margin + (horiz ? <span class="hljs-number">0</span> : axisLength),
                        <span class="hljs-attr">middle</span>: margin + axisLength / <span class="hljs-number">2</span>,
                        <span class="hljs-attr">high</span>: margin + (horiz ? axisLength : <span class="hljs-number">0</span>)
                    }[axisTitleOptions.align],
                    offAxis = (horiz ? axisTop + <span class="hljs-keyword">this</span>.height : axisLeft) +
                    (horiz ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) *
                    (opposite ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) *
                    <span class="hljs-keyword">this</span>.axisTitleMargin +
                    (<span class="hljs-keyword">this</span>.side === <span class="hljs-number">2</span> ? fontSize : <span class="hljs-number">0</span>);
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: horiz ?
                        alongAxis + xOption : offAxis + (opposite ? <span class="hljs-keyword">this</span>.width : <span class="hljs-number">0</span>) + offset + xOption,
                    <span class="hljs-attr">y</span>: horiz ?
                        offAxis + yOption - (opposite ? <span class="hljs-keyword">this</span>.height : <span class="hljs-number">0</span>) + offset : alongAxis + yOption
                };
            },
            <span class="hljs-attr">renderMinorTick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
                <span class="hljs-keyword">var</span> slideInTicks = <span class="hljs-keyword">this</span>.chart.hasRendered &amp;&amp; isNumber(<span class="hljs-keyword">this</span>.oldMin),
                    minorTicks = <span class="hljs-keyword">this</span>.minorTicks;
                <span class="hljs-keyword">if</span> (!minorTicks[pos]) {
                    minorTicks[pos] = <span class="hljs-keyword">new</span> Tick(<span class="hljs-keyword">this</span>, pos, <span class="hljs-string">'minor'</span>);
                }
                <span class="hljs-keyword">if</span> (slideInTicks &amp;&amp; minorTicks[pos].isNew) {
                    minorTicks[pos].render(<span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
                }
                minorTicks[pos].render(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">renderTick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, i</span>) </span>{
                <span class="hljs-keyword">var</span> isLinked = <span class="hljs-keyword">this</span>.isLinked,
                    ticks = <span class="hljs-keyword">this</span>.ticks,
                    slideInTicks = <span class="hljs-keyword">this</span>.chart.hasRendered &amp;&amp; isNumber(<span class="hljs-keyword">this</span>.oldMin);
                <span class="hljs-keyword">if</span> (!isLinked || (pos &gt;= <span class="hljs-keyword">this</span>.min &amp;&amp; pos &lt;= <span class="hljs-keyword">this</span>.max)) {
                    <span class="hljs-keyword">if</span> (!ticks[pos]) {
                        ticks[pos] = <span class="hljs-keyword">new</span> Tick(<span class="hljs-keyword">this</span>, pos);
                    }
                    <span class="hljs-keyword">if</span> (slideInTicks &amp;&amp; ticks[pos].isNew) {
                        ticks[pos].render(i, <span class="hljs-literal">true</span>, <span class="hljs-number">0.1</span>);
                    }
                    ticks[pos].render(i);
                }
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart,
                    renderer = chart.renderer,
                    options = axis.options,
                    isLog = axis.isLog,
                    lin2log = axis.lin2log,
                    isLinked = axis.isLinked,
                    tickPositions = axis.tickPositions,
                    axisTitle = axis.axisTitle,
                    ticks = axis.ticks,
                    minorTicks = axis.minorTicks,
                    alternateBands = axis.alternateBands,
                    stackLabelOptions = options.stackLabels,
                    alternateGridColor = options.alternateGridColor,
                    tickmarkOffset = axis.tickmarkOffset,
                    axisLine = axis.axisLine,
                    showAxis = axis.showAxis,
                    animation = animObject(renderer.globalAnimation),
                    <span class="hljs-keyword">from</span>,
                    to;
                axis.labelEdge.length = <span class="hljs-number">0</span>;
                axis.overlap = <span class="hljs-literal">false</span>;
                each([ticks, minorTicks, alternateBands], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                    <span class="hljs-keyword">var</span> pos;
                    <span class="hljs-keyword">for</span> (pos <span class="hljs-keyword">in</span> coll) {
                        coll[pos].isActive = <span class="hljs-literal">false</span>;
                    }
                });
                <span class="hljs-keyword">if</span> (axis.hasData() || isLinked) {
                    <span class="hljs-keyword">if</span> (axis.minorTickInterval &amp;&amp; !axis.categories) {
                        each(axis.getMinorTickPositions(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos</span>) </span>{
                            axis.renderMinorTick(pos);
                        });
                    }
                    <span class="hljs-keyword">if</span> (tickPositions.length) {
                        each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, i</span>) </span>{
                            axis.renderTick(pos, i);
                        });
                        <span class="hljs-keyword">if</span> (tickmarkOffset &amp;&amp; (axis.min === <span class="hljs-number">0</span> || axis.single)) {
                            <span class="hljs-keyword">if</span> (!ticks[<span class="hljs-number">-1</span>]) {
                                ticks[<span class="hljs-number">-1</span>] = <span class="hljs-keyword">new</span> Tick(axis, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);
                            }
                            ticks[<span class="hljs-number">-1</span>].render(<span class="hljs-number">-1</span>);
                        }
                    }
                    <span class="hljs-keyword">if</span> (alternateGridColor) {
                        each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pos, i</span>) </span>{
                            to = tickPositions[i + <span class="hljs-number">1</span>] !== <span class="hljs-literal">undefined</span> ? tickPositions[i + <span class="hljs-number">1</span>] + tickmarkOffset : axis.max - tickmarkOffset;
                            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> &amp;&amp; pos &lt; axis.max &amp;&amp; to &lt;= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                                <span class="hljs-keyword">if</span> (!alternateBands[pos]) {
                                    alternateBands[pos] = <span class="hljs-keyword">new</span> PlotLineOrBand(axis);
                                }
                                <span class="hljs-keyword">from</span> = pos + tickmarkOffset;
                                alternateBands[pos].options = {
                                    <span class="hljs-attr">from</span>: isLog ? lin2log(<span class="hljs-keyword">from</span>) : <span class="hljs-keyword">from</span>,
                                    <span class="hljs-attr">to</span>: isLog ? lin2log(to) : to,
                                    <span class="hljs-attr">color</span>: alternateGridColor
                                };
                                alternateBands[pos].render();
                                alternateBands[pos].isActive = <span class="hljs-literal">true</span>;
                            }
                        });
                    }
                    <span class="hljs-keyword">if</span> (!axis._addedPlotLB) {
                        each((options.plotLines || []).concat(options.plotBands || []), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">plotLineOptions</span>) </span>{
                            axis.addPlotBandOrLine(plotLineOptions);
                        });
                        axis._addedPlotLB = <span class="hljs-literal">true</span>;
                    }
                }
                each([ticks, minorTicks, alternateBands], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                    <span class="hljs-keyword">var</span> pos,
                        i,
                        forDestruction = [],
                        delay = animation.duration,
                        destroyInactiveItems = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            i = forDestruction.length;
                            <span class="hljs-keyword">while</span> (i--) {
                                <span class="hljs-keyword">if</span> (coll[forDestruction[i]] &amp;&amp; !coll[forDestruction[i]].isActive) {
                                    coll[forDestruction[i]].destroy();
                                    <span class="hljs-keyword">delete</span> coll[forDestruction[i]];
                                }
                            }
                        };
                    <span class="hljs-keyword">for</span> (pos <span class="hljs-keyword">in</span> coll) {
                        <span class="hljs-keyword">if</span> (!coll[pos].isActive) {
                            coll[pos].render(pos, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);
                            coll[pos].isActive = <span class="hljs-literal">false</span>;
                            forDestruction.push(pos);
                        }
                    }
                    syncTimeout(
                        destroyInactiveItems,
                        coll === alternateBands || !chart.hasRendered || !delay ? <span class="hljs-number">0</span> : delay
                    );
                });
                <span class="hljs-keyword">if</span> (axisLine) {
                    axisLine[axisLine.isPlaced ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>]({
                        <span class="hljs-attr">d</span>: <span class="hljs-keyword">this</span>.getLinePath(axisLine.strokeWidth())
                    });
                    axisLine.isPlaced = <span class="hljs-literal">true</span>;
                    axisLine[showAxis ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>](<span class="hljs-literal">true</span>);
                }
                <span class="hljs-keyword">if</span> (axisTitle &amp;&amp; showAxis) {
                    axisTitle[axisTitle.isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>](
                        axis.getTitlePosition()
                    );
                    axisTitle.isNew = <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (stackLabelOptions &amp;&amp; stackLabelOptions.enabled) {
                    axis.renderStackTotals();
                }
                axis.isDirty = <span class="hljs-literal">false</span>;
            },
            <span class="hljs-attr">redraw</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.visible) {
                    <span class="hljs-keyword">this</span>.render();
                    each(<span class="hljs-keyword">this</span>.plotLinesAndBands, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">plotLine</span>) </span>{
                        plotLine.render();
                    });
                }
                each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    series.isDirty = <span class="hljs-literal">true</span>;
                });
            },
            <span class="hljs-attr">keepProps</span>: [<span class="hljs-string">'extKey'</span>, <span class="hljs-string">'hcEvents'</span>, <span class="hljs-string">'names'</span>, <span class="hljs-string">'series'</span>, <span class="hljs-string">'userMax'</span>, <span class="hljs-string">'userMin'</span>],
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">keepEvents</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    stacks = axis.stacks,
                    stackKey,
                    plotLinesAndBands = axis.plotLinesAndBands,
                    i,
                    n;
                <span class="hljs-keyword">if</span> (!keepEvents) {
                    removeEvent(axis);
                }
                <span class="hljs-keyword">for</span> (stackKey <span class="hljs-keyword">in</span> stacks) {
                    destroyObjectProperties(stacks[stackKey]);
                    stacks[stackKey] = <span class="hljs-literal">null</span>;
                }
                each([axis.ticks, axis.minorTicks, axis.alternateBands], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                    destroyObjectProperties(coll);
                });
                <span class="hljs-keyword">if</span> (plotLinesAndBands) {
                    i = plotLinesAndBands.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        plotLinesAndBands[i].destroy();
                    }
                }
                each([<span class="hljs-string">'stackTotalGroup'</span>, <span class="hljs-string">'axisLine'</span>, <span class="hljs-string">'axisTitle'</span>, <span class="hljs-string">'axisGroup'</span>, <span class="hljs-string">'gridGroup'</span>, <span class="hljs-string">'labelGroup'</span>, <span class="hljs-string">'cross'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    <span class="hljs-keyword">if</span> (axis[prop]) {
                        axis[prop] = axis[prop].destroy();
                    }
                });
                <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> axis) {
                    <span class="hljs-keyword">if</span> (axis.hasOwnProperty(n) &amp;&amp; inArray(n, axis.keepProps) === <span class="hljs-number">-1</span>) {
                        <span class="hljs-keyword">delete</span> axis[n];
                    }
                }
            },
            <span class="hljs-attr">drawCrosshair</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, point</span>) </span>{
                <span class="hljs-keyword">var</span> path,
                    options = <span class="hljs-keyword">this</span>.crosshair,
                    snap = pick(options.snap, <span class="hljs-literal">true</span>),
                    pos,
                    categorized,
                    graphic = <span class="hljs-keyword">this</span>.cross;
                <span class="hljs-keyword">if</span> (!e) {
                    e = <span class="hljs-keyword">this</span>.cross &amp;&amp; <span class="hljs-keyword">this</span>.cross.e;
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.crosshair ||
                    ((defined(point) || !snap) === <span class="hljs-literal">false</span>)
                ) {
                    <span class="hljs-keyword">this</span>.hideCrosshair();
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (!snap) {
                        pos = e &amp;&amp; (<span class="hljs-keyword">this</span>.horiz ? e.chartX - <span class="hljs-keyword">this</span>.pos : <span class="hljs-keyword">this</span>.len - e.chartY + <span class="hljs-keyword">this</span>.pos);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defined(point)) {
                        pos = <span class="hljs-keyword">this</span>.isXAxis ? point.plotX : <span class="hljs-keyword">this</span>.len - point.plotY;
                    }
                    <span class="hljs-keyword">if</span> (defined(pos)) {
                        path = <span class="hljs-keyword">this</span>.getPlotLinePath(
                            point &amp;&amp; (<span class="hljs-keyword">this</span>.isXAxis ? point.x : pick(point.stackY, point.y)),
                            <span class="hljs-literal">null</span>,
                            <span class="hljs-literal">null</span>,
                            <span class="hljs-literal">null</span>,
                            pos
                        ) || <span class="hljs-literal">null</span>;
                    }
                    <span class="hljs-keyword">if</span> (!defined(path)) {
                        <span class="hljs-keyword">this</span>.hideCrosshair();
                        <span class="hljs-keyword">return</span>;
                    }
                    categorized = <span class="hljs-keyword">this</span>.categories &amp;&amp; !<span class="hljs-keyword">this</span>.isRadial;
                    <span class="hljs-keyword">if</span> (!graphic) {
                        <span class="hljs-keyword">this</span>.cross = graphic = <span class="hljs-keyword">this</span>.chart.renderer
                            .path()
                            .addClass(<span class="hljs-string">'highcharts-crosshair highcharts-crosshair-'</span> +
                                (categorized ? <span class="hljs-string">'category '</span> : <span class="hljs-string">'thin '</span>) + options.className)
                            .attr({
                                <span class="hljs-attr">zIndex</span>: pick(options.zIndex, <span class="hljs-number">2</span>)
                            })
                            .add();
                        graphic.attr({
                            <span class="hljs-string">'stroke'</span>: options.color || (categorized ? color(<span class="hljs-string">'#ccd6eb'</span>).setOpacity(<span class="hljs-number">0.25</span>).get() : <span class="hljs-string">'#cccccc'</span>),
                            <span class="hljs-string">'stroke-width'</span>: pick(options.width, <span class="hljs-number">1</span>)
                        });
                        <span class="hljs-keyword">if</span> (options.dashStyle) {
                            graphic.attr({
                                <span class="hljs-attr">dashstyle</span>: options.dashStyle
                            });
                        }
                    }
                    graphic.show().attr({
                        <span class="hljs-attr">d</span>: path
                    });
                    <span class="hljs-keyword">if</span> (categorized &amp;&amp; !options.width) {
                        graphic.attr({
                            <span class="hljs-string">'stroke-width'</span>: <span class="hljs-keyword">this</span>.transA
                        });
                    }
                    <span class="hljs-keyword">this</span>.cross.e = e;
                }
            },
            <span class="hljs-attr">hideCrosshair</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cross) {
                    <span class="hljs-keyword">this</span>.cross.hide();
                }
            }
        };
        extend(H.Axis.prototype, AxisPlotLineOrBandExtension);
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Axis = H.Axis,
            <span class="hljs-built_in">Date</span> = H.Date,
            dateFormat = H.dateFormat,
            defaultOptions = H.defaultOptions,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            getMagnitude = H.getMagnitude,
            getTZOffset = H.getTZOffset,
            normalizeTickInterval = H.normalizeTickInterval,
            pick = H.pick,
            timeUnits = H.timeUnits;
        Axis.prototype.getTimeTicks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">normalizedInterval, min, max, startOfWeek</span>) </span>{
            <span class="hljs-keyword">var</span> tickPositions = [],
                i,
                higherRanks = {},
                useUTC = defaultOptions.global.useUTC,
                minYear,
                minDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(min - getTZOffset(min)),
                makeTime = <span class="hljs-built_in">Date</span>.hcMakeTime,
                interval = normalizedInterval.unitRange,
                count = normalizedInterval.count,
                variableDayLength;
            <span class="hljs-keyword">if</span> (defined(min)) {
                minDate[<span class="hljs-built_in">Date</span>.hcSetMilliseconds](interval &gt;= timeUnits.second ? <span class="hljs-number">0</span> :
                    count * <span class="hljs-built_in">Math</span>.floor(minDate.getMilliseconds() / count));
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.second) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetSeconds](interval &gt;= timeUnits.minute ? <span class="hljs-number">0</span> :
                        count * <span class="hljs-built_in">Math</span>.floor(minDate.getSeconds() / count));
                }
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.minute) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetMinutes](interval &gt;= timeUnits.hour ? <span class="hljs-number">0</span> :
                        count * <span class="hljs-built_in">Math</span>.floor(minDate[<span class="hljs-built_in">Date</span>.hcGetMinutes]() / count));
                }
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.hour) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetHours](interval &gt;= timeUnits.day ? <span class="hljs-number">0</span> :
                        count * <span class="hljs-built_in">Math</span>.floor(minDate[<span class="hljs-built_in">Date</span>.hcGetHours]() / count));
                }
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.day) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetDate](interval &gt;= timeUnits.month ? <span class="hljs-number">1</span> :
                        count * <span class="hljs-built_in">Math</span>.floor(minDate[<span class="hljs-built_in">Date</span>.hcGetDate]() / count));
                }
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.month) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetMonth](interval &gt;= timeUnits.year ? <span class="hljs-number">0</span> :
                        count * <span class="hljs-built_in">Math</span>.floor(minDate[<span class="hljs-built_in">Date</span>.hcGetMonth]() / count));
                    minYear = minDate[<span class="hljs-built_in">Date</span>.hcGetFullYear]();
                }
                <span class="hljs-keyword">if</span> (interval &gt;= timeUnits.year) {
                    minYear -= minYear % count;
                    minDate[<span class="hljs-built_in">Date</span>.hcSetFullYear](minYear);
                }
                <span class="hljs-keyword">if</span> (interval === timeUnits.week) {
                    minDate[<span class="hljs-built_in">Date</span>.hcSetDate](minDate[<span class="hljs-built_in">Date</span>.hcGetDate]() - minDate[<span class="hljs-built_in">Date</span>.hcGetDay]() +
                        pick(startOfWeek, <span class="hljs-number">1</span>));
                }
                minYear = minDate[<span class="hljs-built_in">Date</span>.hcGetFullYear]();
                <span class="hljs-keyword">var</span> minMonth = minDate[<span class="hljs-built_in">Date</span>.hcGetMonth](),
                    minDateDate = minDate[<span class="hljs-built_in">Date</span>.hcGetDate](),
                    minHours = minDate[<span class="hljs-built_in">Date</span>.hcGetHours]();
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Date</span>.hcTimezoneOffset || <span class="hljs-built_in">Date</span>.hcGetTimezoneOffset) {
                    variableDayLength =
                        (!useUTC || !!<span class="hljs-built_in">Date</span>.hcGetTimezoneOffset) &amp;&amp;
                        (
                            max - min &gt; <span class="hljs-number">4</span> * timeUnits.month ||
                            getTZOffset(min) !== getTZOffset(max)
                        );
                    minDate = minDate.getTime();
                    minDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(minDate + getTZOffset(minDate));
                }
                <span class="hljs-keyword">var</span> time = minDate.getTime();
                i = <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (time &lt; max) {
                    tickPositions.push(time);
                    <span class="hljs-keyword">if</span> (interval === timeUnits.year) {
                        time = makeTime(minYear + i * count, <span class="hljs-number">0</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval === timeUnits.month) {
                        time = makeTime(minYear, minMonth + i * count);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (variableDayLength &amp;&amp; (interval === timeUnits.day || interval === timeUnits.week)) {
                        time = makeTime(minYear, minMonth, minDateDate +
                            i * count * (interval === timeUnits.day ? <span class="hljs-number">1</span> : <span class="hljs-number">7</span>));
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (variableDayLength &amp;&amp; interval === timeUnits.hour) {
                        time = makeTime(minYear, minMonth, minDateDate, minHours + i * count);
                    } <span class="hljs-keyword">else</span> {
                        time += interval * count;
                    }
                    i++;
                }
                tickPositions.push(time);
                <span class="hljs-keyword">if</span> (interval &lt;= timeUnits.hour &amp;&amp; tickPositions.length &lt; <span class="hljs-number">10000</span>) {
                    each(tickPositions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">time</span>) </span>{
                        <span class="hljs-keyword">if</span> (
                            time % <span class="hljs-number">1800000</span> === <span class="hljs-number">0</span> &amp;&amp;
                            dateFormat(<span class="hljs-string">'%H%M%S%L'</span>, time) === <span class="hljs-string">'000000000'</span>
                        ) {
                            higherRanks[time] = <span class="hljs-string">'day'</span>;
                        }
                    });
                }
            }
            tickPositions.info = extend(normalizedInterval, {
                <span class="hljs-attr">higherRanks</span>: higherRanks,
                <span class="hljs-attr">totalRange</span>: interval * count
            });
            <span class="hljs-keyword">return</span> tickPositions;
        };
        Axis.prototype.normalizeTimeTickInterval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tickInterval, unitsOption</span>) </span>{
            <span class="hljs-keyword">var</span> units = unitsOption || [
                    [
                        <span class="hljs-string">'millisecond'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">500</span>]
                    ],
                    [
                        <span class="hljs-string">'second'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>]
                    ],
                    [
                        <span class="hljs-string">'minute'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>]
                    ],
                    [
                        <span class="hljs-string">'hour'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]
                    ],
                    [
                        <span class="hljs-string">'day'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
                    ],
                    [
                        <span class="hljs-string">'week'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]
                    ],
                    [
                        <span class="hljs-string">'month'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]
                    ],
                    [
                        <span class="hljs-string">'year'</span>,
                        <span class="hljs-literal">null</span>
                    ]
                ],
                unit = units[units.length - <span class="hljs-number">1</span>],
                interval = timeUnits[unit[<span class="hljs-number">0</span>]],
                multiples = unit[<span class="hljs-number">1</span>],
                count,
                i;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; units.length; i++) {
                unit = units[i];
                interval = timeUnits[unit[<span class="hljs-number">0</span>]];
                multiples = unit[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (units[i + <span class="hljs-number">1</span>]) {
                    <span class="hljs-keyword">var</span> lessThan = (interval * multiples[multiples.length - <span class="hljs-number">1</span>] +
                        timeUnits[units[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]]) / <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">if</span> (tickInterval &lt;= lessThan) {
                        <span class="hljs-keyword">break</span>;
                    }
                }
            }
            <span class="hljs-keyword">if</span> (interval === timeUnits.year &amp;&amp; tickInterval &lt; <span class="hljs-number">5</span> * interval) {
                multiples = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>];
            }
            count = normalizeTickInterval(
                tickInterval / interval,
                multiples,
                unit[<span class="hljs-number">0</span>] === <span class="hljs-string">'year'</span> ? <span class="hljs-built_in">Math</span>.max(getMagnitude(tickInterval / interval), <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>
            );
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">unitRange</span>: interval,
                <span class="hljs-attr">count</span>: count,
                <span class="hljs-attr">unitName</span>: unit[<span class="hljs-number">0</span>]
            };
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Axis = H.Axis,
            getMagnitude = H.getMagnitude,
            map = H.map,
            normalizeTickInterval = H.normalizeTickInterval,
            pick = H.pick;
        Axis.prototype.getLogTickPositions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">interval, min, max, minor</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                options = axis.options,
                axisLength = axis.len,
                lin2log = axis.lin2log,
                log2lin = axis.log2lin,
                positions = [];
            <span class="hljs-keyword">if</span> (!minor) {
                axis._minorAutoInterval = <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">if</span> (interval &gt;= <span class="hljs-number">0.5</span>) {
                interval = <span class="hljs-built_in">Math</span>.round(interval);
                positions = axis.getLinearTickPositions(interval, min, max);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval &gt;= <span class="hljs-number">0.08</span>) {
                <span class="hljs-keyword">var</span> roundedMin = <span class="hljs-built_in">Math</span>.floor(min),
                    intermediate,
                    i,
                    j,
                    len,
                    pos,
                    lastPos,
                    break2;
                <span class="hljs-keyword">if</span> (interval &gt; <span class="hljs-number">0.3</span>) {
                    intermediate = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>];
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interval &gt; <span class="hljs-number">0.15</span>) {
                    intermediate = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>];
                } <span class="hljs-keyword">else</span> {
                    intermediate = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>];
                }
                <span class="hljs-keyword">for</span> (i = roundedMin; i &lt; max + <span class="hljs-number">1</span> &amp;&amp; !break2; i++) {
                    len = intermediate.length;
                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len &amp;&amp; !break2; j++) {
                        pos = log2lin(lin2log(i) * intermediate[j]);
                        <span class="hljs-keyword">if</span> (pos &gt; min &amp;&amp; (!minor || lastPos &lt;= max) &amp;&amp; lastPos !== <span class="hljs-literal">undefined</span>) {
                            positions.push(lastPos);
                        }
                        <span class="hljs-keyword">if</span> (lastPos &gt; max) {
                            break2 = <span class="hljs-literal">true</span>;
                        }
                        lastPos = pos;
                    }
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> realMin = lin2log(min),
                    realMax = lin2log(max),
                    tickIntervalOption = options[minor ? <span class="hljs-string">'minorTickInterval'</span> : <span class="hljs-string">'tickInterval'</span>],
                    filteredTickIntervalOption = tickIntervalOption === <span class="hljs-string">'auto'</span> ? <span class="hljs-literal">null</span> : tickIntervalOption,
                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? <span class="hljs-number">5</span> : <span class="hljs-number">1</span>),
                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
                interval = pick(
                    filteredTickIntervalOption,
                    axis._minorAutoInterval,
                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || <span class="hljs-number">1</span>)
                );
                interval = normalizeTickInterval(
                    interval,
                    <span class="hljs-literal">null</span>,
                    getMagnitude(interval)
                );
                positions = map(axis.getLinearTickPositions(
                    interval,
                    realMin,
                    realMax
                ), log2lin);
                <span class="hljs-keyword">if</span> (!minor) {
                    axis._minorAutoInterval = interval / <span class="hljs-number">5</span>;
                }
            }
            <span class="hljs-keyword">if</span> (!minor) {
                axis.tickInterval = interval;
            }
            <span class="hljs-keyword">return</span> positions;
        };
        Axis.prototype.log2lin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.log(num) / <span class="hljs-built_in">Math</span>.LN10;
        };
        Axis.prototype.lin2log = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, num);
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> dateFormat = H.dateFormat,
            each = H.each,
            extend = H.extend,
            format = H.format,
            isNumber = H.isNumber,
            map = H.map,
            merge = H.merge,
            pick = H.pick,
            splat = H.splat,
            syncTimeout = H.syncTimeout,
            timeUnits = H.timeUnits;
        H.Tooltip = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
        H.Tooltip.prototype = {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
                <span class="hljs-keyword">this</span>.chart = chart;
                <span class="hljs-keyword">this</span>.options = options;
                <span class="hljs-keyword">this</span>.crosshairs = [];
                <span class="hljs-keyword">this</span>.now = {
                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>
                };
                <span class="hljs-keyword">this</span>.isHidden = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">this</span>.split = options.split &amp;&amp; !chart.inverted;
                <span class="hljs-keyword">this</span>.shared = options.shared || <span class="hljs-keyword">this</span>.split;
            },
            <span class="hljs-attr">cleanSplit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">force</span>) </span>{
                each(<span class="hljs-keyword">this</span>.chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">var</span> tt = series &amp;&amp; series.tt;
                    <span class="hljs-keyword">if</span> (tt) {
                        <span class="hljs-keyword">if</span> (!tt.isActive || force) {
                            series.tt = tt.destroy();
                        } <span class="hljs-keyword">else</span> {
                            tt.isActive = <span class="hljs-literal">false</span>;
                        }
                    }
                });
            },
            <span class="hljs-attr">getLabel</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> renderer = <span class="hljs-keyword">this</span>.chart.renderer,
                    options = <span class="hljs-keyword">this</span>.options;
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.label) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.split) {
                        <span class="hljs-keyword">this</span>.label = renderer.g(<span class="hljs-string">'tooltip'</span>);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">this</span>.label = renderer.label(
                                <span class="hljs-string">''</span>,
                                <span class="hljs-number">0</span>,
                                <span class="hljs-number">0</span>,
                                options.shape || <span class="hljs-string">'callout'</span>,
                                <span class="hljs-literal">null</span>,
                                <span class="hljs-literal">null</span>,
                                options.useHTML,
                                <span class="hljs-literal">null</span>,
                                <span class="hljs-string">'tooltip'</span>
                            )
                            .attr({
                                <span class="hljs-attr">padding</span>: options.padding,
                                <span class="hljs-attr">r</span>: options.borderRadius
                            });
                        <span class="hljs-keyword">this</span>.label
                            .attr({
                                <span class="hljs-string">'fill'</span>: options.backgroundColor,
                                <span class="hljs-string">'stroke-width'</span>: options.borderWidth
                            })
                            .css(options.style)
                            .shadow(options.shadow);
                    }
                    <span class="hljs-keyword">this</span>.label
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">8</span>
                        })
                        .add();
                }
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.label;
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">this</span>.destroy();
                <span class="hljs-keyword">this</span>.init(<span class="hljs-keyword">this</span>.chart, merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options, options));
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.label) {
                    <span class="hljs-keyword">this</span>.label = <span class="hljs-keyword">this</span>.label.destroy();
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.split &amp;&amp; <span class="hljs-keyword">this</span>.tt) {
                    <span class="hljs-keyword">this</span>.cleanSplit(<span class="hljs-keyword">this</span>.chart, <span class="hljs-literal">true</span>);
                    <span class="hljs-keyword">this</span>.tt = <span class="hljs-keyword">this</span>.tt.destroy();
                }
                clearTimeout(<span class="hljs-keyword">this</span>.hideTimer);
                clearTimeout(<span class="hljs-keyword">this</span>.tooltipTimeout);
            },
            <span class="hljs-attr">move</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, anchorX, anchorY</span>) </span>{
                <span class="hljs-keyword">var</span> tooltip = <span class="hljs-keyword">this</span>,
                    now = tooltip.now,
                    animate = tooltip.options.animation !== <span class="hljs-literal">false</span> &amp;&amp; !tooltip.isHidden &amp;&amp;
                    (<span class="hljs-built_in">Math</span>.abs(x - now.x) &gt; <span class="hljs-number">1</span> || <span class="hljs-built_in">Math</span>.abs(y - now.y) &gt; <span class="hljs-number">1</span>),
                    skipAnchor = tooltip.followPointer || tooltip.len &gt; <span class="hljs-number">1</span>;
                extend(now, {
                    <span class="hljs-attr">x</span>: animate ? (<span class="hljs-number">2</span> * now.x + x) / <span class="hljs-number">3</span> : x,
                    <span class="hljs-attr">y</span>: animate ? (now.y + y) / <span class="hljs-number">2</span> : y,
                    <span class="hljs-attr">anchorX</span>: skipAnchor ? <span class="hljs-literal">undefined</span> : animate ? (<span class="hljs-number">2</span> * now.anchorX + anchorX) / <span class="hljs-number">3</span> : anchorX,
                    <span class="hljs-attr">anchorY</span>: skipAnchor ? <span class="hljs-literal">undefined</span> : animate ? (now.anchorY + anchorY) / <span class="hljs-number">2</span> : anchorY
                });
                tooltip.getLabel().attr(now);
                <span class="hljs-keyword">if</span> (animate) {
                    clearTimeout(<span class="hljs-keyword">this</span>.tooltipTimeout);
                    <span class="hljs-keyword">this</span>.tooltipTimeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (tooltip) {
                            tooltip.move(x, y, anchorX, anchorY);
                        }
                    }, <span class="hljs-number">32</span>);
                }
            },
            <span class="hljs-attr">hide</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">delay</span>) </span>{
                <span class="hljs-keyword">var</span> tooltip = <span class="hljs-keyword">this</span>;
                clearTimeout(<span class="hljs-keyword">this</span>.hideTimer);
                delay = pick(delay, <span class="hljs-keyword">this</span>.options.hideDelay, <span class="hljs-number">500</span>);
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isHidden) {
                    <span class="hljs-keyword">this</span>.hideTimer = syncTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        tooltip.getLabel()[delay ? <span class="hljs-string">'fadeOut'</span> : <span class="hljs-string">'hide'</span>]();
                        tooltip.isHidden = <span class="hljs-literal">true</span>;
                    }, delay);
                }
            },
            <span class="hljs-attr">getAnchor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, mouseEvent</span>) </span>{
                <span class="hljs-keyword">var</span> ret,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    inverted = chart.inverted,
                    plotTop = chart.plotTop,
                    plotLeft = chart.plotLeft,
                    plotX = <span class="hljs-number">0</span>,
                    plotY = <span class="hljs-number">0</span>,
                    yAxis,
                    xAxis;
                points = splat(points);
                ret = points[<span class="hljs-number">0</span>].tooltipPos;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.followPointer &amp;&amp; mouseEvent) {
                    <span class="hljs-keyword">if</span> (mouseEvent.chartX === <span class="hljs-literal">undefined</span>) {
                        mouseEvent = chart.pointer.normalize(mouseEvent);
                    }
                    ret = [
                        mouseEvent.chartX - chart.plotLeft,
                        mouseEvent.chartY - plotTop
                    ];
                }
                <span class="hljs-keyword">if</span> (!ret) {
                    each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                        yAxis = point.series.yAxis;
                        xAxis = point.series.xAxis;
                        plotX += point.plotX + (!inverted &amp;&amp; xAxis ? xAxis.left - plotLeft : <span class="hljs-number">0</span>);
                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / <span class="hljs-number">2</span> : point.plotY) +
                            (!inverted &amp;&amp; yAxis ? yAxis.top - plotTop : <span class="hljs-number">0</span>);
                    });
                    plotX /= points.length;
                    plotY /= points.length;
                    ret = [
                        inverted ? chart.plotWidth - plotY : plotX,
                        <span class="hljs-keyword">this</span>.shared &amp;&amp; !inverted &amp;&amp; points.length &gt; <span class="hljs-number">1</span> &amp;&amp; mouseEvent ?
                        mouseEvent.chartY - plotTop :
                        inverted ? chart.plotHeight - plotX : plotY
                    ];
                }
                <span class="hljs-keyword">return</span> map(ret, <span class="hljs-built_in">Math</span>.round);
            },
            <span class="hljs-attr">getPosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">boxWidth, boxHeight, point</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    distance = <span class="hljs-keyword">this</span>.distance,
                    ret = {},
                    h = point.h || <span class="hljs-number">0</span>,
                    swapped,
                    first = [<span class="hljs-string">'y'</span>, chart.chartHeight, boxHeight,
                        point.plotY + chart.plotTop, chart.plotTop,
                        chart.plotTop + chart.plotHeight
                    ],
                    second = [<span class="hljs-string">'x'</span>, chart.chartWidth, boxWidth,
                        point.plotX + chart.plotLeft, chart.plotLeft,
                        chart.plotLeft + chart.plotWidth
                    ],
                    preferFarSide = !<span class="hljs-keyword">this</span>.followPointer &amp;&amp; pick(point.ttBelow, !chart.inverted === !!point.negative),
                    firstDimension = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dim, outerSize, innerSize, point, min, max</span>) </span>{
                        <span class="hljs-keyword">var</span> roomLeft = innerSize &lt; point - distance,
                            roomRight = point + distance + innerSize &lt; outerSize,
                            alignedLeft = point - distance - innerSize,
                            alignedRight = point + distance;
                        <span class="hljs-keyword">if</span> (preferFarSide &amp;&amp; roomRight) {
                            ret[dim] = alignedRight;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!preferFarSide &amp;&amp; roomLeft) {
                            ret[dim] = alignedLeft;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (roomLeft) {
                            ret[dim] = <span class="hljs-built_in">Math</span>.min(max - innerSize, alignedLeft - h &lt; <span class="hljs-number">0</span> ? alignedLeft : alignedLeft - h);
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (roomRight) {
                            ret[dim] = <span class="hljs-built_in">Math</span>.max(
                                min,
                                alignedRight + h + innerSize &gt; outerSize ?
                                alignedRight :
                                alignedRight + h
                            );
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                        }
                    },
                    secondDimension = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dim, outerSize, innerSize, point</span>) </span>{
                        <span class="hljs-keyword">var</span> retVal;
                        <span class="hljs-keyword">if</span> (point &lt; distance || point &gt; outerSize - distance) {
                            retVal = <span class="hljs-literal">false</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (point &lt; innerSize / <span class="hljs-number">2</span>) {
                            ret[dim] = <span class="hljs-number">1</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (point &gt; outerSize - innerSize / <span class="hljs-number">2</span>) {
                            ret[dim] = outerSize - innerSize - <span class="hljs-number">2</span>;
                        } <span class="hljs-keyword">else</span> {
                            ret[dim] = point - innerSize / <span class="hljs-number">2</span>;
                        }
                        <span class="hljs-keyword">return</span> retVal;
                    },
                    swap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">count</span>) </span>{
                        <span class="hljs-keyword">var</span> temp = first;
                        first = second;
                        second = temp;
                        swapped = count;
                    },
                    run = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (firstDimension.apply(<span class="hljs-number">0</span>, first) !== <span class="hljs-literal">false</span>) {
                            <span class="hljs-keyword">if</span> (secondDimension.apply(<span class="hljs-number">0</span>, second) === <span class="hljs-literal">false</span> &amp;&amp; !swapped) {
                                swap(<span class="hljs-literal">true</span>);
                                run();
                            }
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!swapped) {
                            swap(<span class="hljs-literal">true</span>);
                            run();
                        } <span class="hljs-keyword">else</span> {
                            ret.x = ret.y = <span class="hljs-number">0</span>;
                        }
                    };
                <span class="hljs-keyword">if</span> (chart.inverted || <span class="hljs-keyword">this</span>.len &gt; <span class="hljs-number">1</span>) {
                    swap();
                }
                run();
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">defaultFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tooltip</span>) </span>{
                <span class="hljs-keyword">var</span> items = <span class="hljs-keyword">this</span>.points || splat(<span class="hljs-keyword">this</span>),
                    s;
                s = [tooltip.tooltipFooterHeaderFormatter(items[<span class="hljs-number">0</span>])];
                s = s.concat(tooltip.bodyFormatter(items));
                s.push(tooltip.tooltipFooterHeaderFormatter(items[<span class="hljs-number">0</span>], <span class="hljs-literal">true</span>));
                <span class="hljs-keyword">return</span> s;
            },
            <span class="hljs-attr">refresh</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, mouseEvent</span>) </span>{
                <span class="hljs-keyword">var</span> tooltip = <span class="hljs-keyword">this</span>,
                    chart = tooltip.chart,
                    label,
                    options = tooltip.options,
                    x,
                    y,
                    anchor,
                    textConfig = {},
                    text,
                    pointConfig = [],
                    formatter = options.formatter || tooltip.defaultFormatter,
                    hoverPoints = chart.hoverPoints,
                    shared = tooltip.shared,
                    currentSeries;
                clearTimeout(<span class="hljs-keyword">this</span>.hideTimer);
                tooltip.followPointer = splat(point)[<span class="hljs-number">0</span>].series.tooltipOptions.followPointer;
                anchor = tooltip.getAnchor(point, mouseEvent);
                x = anchor[<span class="hljs-number">0</span>];
                y = anchor[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span> (shared &amp;&amp; !(point.series &amp;&amp; point.series.noSharedTooltip)) {
                    chart.hoverPoints = point;
                    <span class="hljs-keyword">if</span> (hoverPoints) {
                        each(hoverPoints, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                            point.setState();
                        });
                    }
                    each(point, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                        item.setState(<span class="hljs-string">'hover'</span>);
                        pointConfig.push(item.getLabelConfig());
                    });
                    textConfig = {
                        <span class="hljs-attr">x</span>: point[<span class="hljs-number">0</span>].category,
                        <span class="hljs-attr">y</span>: point[<span class="hljs-number">0</span>].y
                    };
                    textConfig.points = pointConfig;
                    point = point[<span class="hljs-number">0</span>];
                } <span class="hljs-keyword">else</span> {
                    textConfig = point.getLabelConfig();
                }
                <span class="hljs-keyword">this</span>.len = pointConfig.length;
                text = formatter.call(textConfig, tooltip);
                currentSeries = point.series;
                <span class="hljs-keyword">this</span>.distance = pick(currentSeries.tooltipOptions.distance, <span class="hljs-number">16</span>);
                <span class="hljs-keyword">if</span> (text === <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">this</span>.hide();
                } <span class="hljs-keyword">else</span> {
                    label = tooltip.getLabel();
                    <span class="hljs-keyword">if</span> (tooltip.isHidden) {
                        label.attr({
                            <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>
                        }).show();
                    }
                    <span class="hljs-keyword">if</span> (tooltip.split) {
                        <span class="hljs-keyword">this</span>.renderSplit(text, chart.hoverPoints);
                    } <span class="hljs-keyword">else</span> {
                        label.attr({
                            <span class="hljs-attr">text</span>: text &amp;&amp; text.join ? text.join(<span class="hljs-string">''</span>) : text
                        });
                        label.removeClass(<span class="hljs-regexp">/highcharts-color-[\d]+/g</span>)
                            .addClass(<span class="hljs-string">'highcharts-color-'</span> + pick(point.colorIndex, currentSeries.colorIndex));
                        label.attr({
                            <span class="hljs-attr">stroke</span>: options.borderColor || point.color || currentSeries.color || <span class="hljs-string">'#666666'</span>
                        });
                        tooltip.updatePosition({
                            <span class="hljs-attr">plotX</span>: x,
                            <span class="hljs-attr">plotY</span>: y,
                            <span class="hljs-attr">negative</span>: point.negative,
                            <span class="hljs-attr">ttBelow</span>: point.ttBelow,
                            <span class="hljs-attr">h</span>: anchor[<span class="hljs-number">2</span>] || <span class="hljs-number">0</span>
                        });
                    }
                    <span class="hljs-keyword">this</span>.isHidden = <span class="hljs-literal">false</span>;
                }
            },
            <span class="hljs-attr">renderSplit</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">labels, points</span>) </span>{
                <span class="hljs-keyword">var</span> tooltip = <span class="hljs-keyword">this</span>,
                    boxes = [],
                    chart = <span class="hljs-keyword">this</span>.chart,
                    ren = chart.renderer,
                    rightAligned = <span class="hljs-literal">true</span>,
                    options = <span class="hljs-keyword">this</span>.options,
                    headerHeight,
                    tooltipLabel = <span class="hljs-keyword">this</span>.getLabel();
                each(labels.slice(<span class="hljs-number">0</span>, points.length + <span class="hljs-number">1</span>), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str, i</span>) </span>{
                    <span class="hljs-keyword">var</span> point = points[i - <span class="hljs-number">1</span>] || {
                            <span class="hljs-attr">isHeader</span>: <span class="hljs-literal">true</span>,
                            <span class="hljs-attr">plotX</span>: points[<span class="hljs-number">0</span>].plotX
                        },
                        owner = point.series || tooltip,
                        tt = owner.tt,
                        series = point.series || {},
                        colorClass = <span class="hljs-string">'highcharts-color-'</span> + pick(point.colorIndex, series.colorIndex, <span class="hljs-string">'none'</span>),
                        target,
                        x,
                        bBox,
                        boxWidth;
                    <span class="hljs-keyword">if</span> (!tt) {
                        owner.tt = tt = ren.label(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'callout'</span>)
                            .addClass(<span class="hljs-string">'highcharts-tooltip-box '</span> + colorClass)
                            .attr({
                                <span class="hljs-string">'padding'</span>: options.padding,
                                <span class="hljs-string">'r'</span>: options.borderRadius,
                                <span class="hljs-string">'fill'</span>: options.backgroundColor,
                                <span class="hljs-string">'stroke'</span>: point.color || series.color || <span class="hljs-string">'#333333'</span>,
                                <span class="hljs-string">'stroke-width'</span>: options.borderWidth
                            })
                            .add(tooltipLabel);
                    }
                    tt.isActive = <span class="hljs-literal">true</span>;
                    tt.attr({
                        <span class="hljs-attr">text</span>: str
                    });
                    tt.css(options.style);
                    bBox = tt.getBBox();
                    boxWidth = bBox.width + tt.strokeWidth();
                    <span class="hljs-keyword">if</span> (point.isHeader) {
                        headerHeight = bBox.height;
                        x = <span class="hljs-built_in">Math</span>.max(
                            <span class="hljs-number">0</span>,
                            <span class="hljs-built_in">Math</span>.min(
                                point.plotX + chart.plotLeft - boxWidth / <span class="hljs-number">2</span>,
                                chart.chartWidth - boxWidth
                            )
                        );
                    } <span class="hljs-keyword">else</span> {
                        x = point.plotX + chart.plotLeft - pick(options.distance, <span class="hljs-number">16</span>) -
                            boxWidth;
                    }
                    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) {
                        rightAligned = <span class="hljs-literal">false</span>;
                    }
                    target = (point.series &amp;&amp; point.series.yAxis &amp;&amp; point.series.yAxis.pos) + (point.plotY || <span class="hljs-number">0</span>);
                    target -= chart.plotTop;
                    boxes.push({
                        <span class="hljs-attr">target</span>: point.isHeader ? chart.plotHeight + headerHeight : target,
                        <span class="hljs-attr">rank</span>: point.isHeader ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>,
                        <span class="hljs-attr">size</span>: owner.tt.getBBox().height + <span class="hljs-number">1</span>,
                        <span class="hljs-attr">point</span>: point,
                        <span class="hljs-attr">x</span>: x,
                        <span class="hljs-attr">tt</span>: tt
                    });
                });
                <span class="hljs-keyword">this</span>.cleanSplit();
                H.distribute(boxes, chart.plotHeight + headerHeight);
                each(boxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>{
                    <span class="hljs-keyword">var</span> point = box.point,
                        series = point.series;
                    box.tt.attr({
                        <span class="hljs-attr">visibility</span>: box.pos === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'inherit'</span>,
                        <span class="hljs-attr">x</span>: (rightAligned || point.isHeader ?
                            box.x :
                            point.plotX + chart.plotLeft + pick(options.distance, <span class="hljs-number">16</span>)),
                        <span class="hljs-attr">y</span>: box.pos + chart.plotTop,
                        <span class="hljs-attr">anchorX</span>: point.isHeader ?
                            point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,
                        <span class="hljs-attr">anchorY</span>: point.isHeader ?
                            box.pos + chart.plotTop - <span class="hljs-number">15</span> : point.plotY + series.yAxis.pos
                    });
                });
            },
            <span class="hljs-attr">updatePosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    label = <span class="hljs-keyword">this</span>.getLabel(),
                    pos = (<span class="hljs-keyword">this</span>.options.positioner || <span class="hljs-keyword">this</span>.getPosition).call(
                        <span class="hljs-keyword">this</span>,
                        label.width,
                        label.height,
                        point
                    );
                <span class="hljs-keyword">this</span>.move(
                    <span class="hljs-built_in">Math</span>.round(pos.x),
                    <span class="hljs-built_in">Math</span>.round(pos.y || <span class="hljs-number">0</span>),
                    point.plotX + chart.plotLeft,
                    point.plotY + chart.plotTop
                );
            },
            <span class="hljs-attr">getDateFormat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">range, date, startOfWeek, dateTimeLabelFormats</span>) </span>{
                <span class="hljs-keyword">var</span> dateStr = dateFormat(<span class="hljs-string">'%m-%d %H:%M:%S.%L'</span>, date),
                    format,
                    n,
                    blank = <span class="hljs-string">'01-01 00:00:00.000'</span>,
                    strpos = {
                        <span class="hljs-attr">millisecond</span>: <span class="hljs-number">15</span>,
                        <span class="hljs-attr">second</span>: <span class="hljs-number">12</span>,
                        <span class="hljs-attr">minute</span>: <span class="hljs-number">9</span>,
                        <span class="hljs-attr">hour</span>: <span class="hljs-number">6</span>,
                        <span class="hljs-attr">day</span>: <span class="hljs-number">3</span>
                    },
                    lastN = <span class="hljs-string">'millisecond'</span>;
                <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> timeUnits) {
                    <span class="hljs-keyword">if</span> (range === timeUnits.week &amp;&amp; +dateFormat(<span class="hljs-string">'%w'</span>, date) === startOfWeek &amp;&amp;
                        dateStr.substr(<span class="hljs-number">6</span>) === blank.substr(<span class="hljs-number">6</span>)) {
                        n = <span class="hljs-string">'week'</span>;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">if</span> (timeUnits[n] &gt; range) {
                        n = lastN;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">if</span> (strpos[n] &amp;&amp; dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">if</span> (n !== <span class="hljs-string">'week'</span>) {
                        lastN = n;
                    }
                }
                <span class="hljs-keyword">if</span> (n) {
                    format = dateTimeLabelFormats[n];
                }
                <span class="hljs-keyword">return</span> format;
            },
            <span class="hljs-attr">getXDateFormat</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, options, xAxis</span>) </span>{
                <span class="hljs-keyword">var</span> xDateFormat,
                    dateTimeLabelFormats = options.dateTimeLabelFormats,
                    closestPointRange = xAxis &amp;&amp; xAxis.closestPointRange;
                <span class="hljs-keyword">if</span> (closestPointRange) {
                    xDateFormat = <span class="hljs-keyword">this</span>.getDateFormat(
                        closestPointRange,
                        point.x,
                        xAxis.options.startOfWeek,
                        dateTimeLabelFormats
                    );
                } <span class="hljs-keyword">else</span> {
                    xDateFormat = dateTimeLabelFormats.day;
                }
                <span class="hljs-keyword">return</span> xDateFormat || dateTimeLabelFormats.year;
            },
            <span class="hljs-attr">tooltipFooterHeaderFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">labelConfig, isFooter</span>) </span>{
                <span class="hljs-keyword">var</span> footOrHead = isFooter ? <span class="hljs-string">'footer'</span> : <span class="hljs-string">'header'</span>,
                    series = labelConfig.series,
                    tooltipOptions = series.tooltipOptions,
                    xDateFormat = tooltipOptions.xDateFormat,
                    xAxis = series.xAxis,
                    isDateTime = xAxis &amp;&amp; xAxis.options.type === <span class="hljs-string">'datetime'</span> &amp;&amp; isNumber(labelConfig.key),
                    formatString = tooltipOptions[footOrHead + <span class="hljs-string">'Format'</span>];
                <span class="hljs-keyword">if</span> (isDateTime &amp;&amp; !xDateFormat) {
                    xDateFormat = <span class="hljs-keyword">this</span>.getXDateFormat(labelConfig, tooltipOptions, xAxis);
                }
                <span class="hljs-keyword">if</span> (isDateTime &amp;&amp; xDateFormat) {
                    formatString = formatString.replace(<span class="hljs-string">'{point.key}'</span>, <span class="hljs-string">'{point.key:'</span> + xDateFormat + <span class="hljs-string">'}'</span>);
                }
                <span class="hljs-keyword">return</span> format(formatString, {
                    <span class="hljs-attr">point</span>: labelConfig,
                    <span class="hljs-attr">series</span>: series
                });
            },
            <span class="hljs-attr">bodyFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">items</span>) </span>{
                <span class="hljs-keyword">return</span> map(items, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                    <span class="hljs-keyword">var</span> tooltipOptions = item.series.tooltipOptions;
                    <span class="hljs-keyword">return</span> (tooltipOptions.pointFormatter || item.point.tooltipFormatter)
                        .call(item.point, tooltipOptions.pointFormat);
                });
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            attr = H.attr,
            charts = H.charts,
            color = H.color,
            css = H.css,
            defined = H.defined,
            doc = H.doc,
            each = H.each,
            extend = H.extend,
            fireEvent = H.fireEvent,
            offset = H.offset,
            pick = H.pick,
            removeEvent = H.removeEvent,
            splat = H.splat,
            Tooltip = H.Tooltip,
            win = H.win;
        H.Pointer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
            <span class="hljs-keyword">this</span>.init(chart, options);
        };
        H.Pointer.prototype = {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
                <span class="hljs-keyword">this</span>.options = options;
                <span class="hljs-keyword">this</span>.chart = chart;
                <span class="hljs-keyword">this</span>.runChartClick = options.chart.events &amp;&amp; !!options.chart.events.click;
                <span class="hljs-keyword">this</span>.pinchDown = [];
                <span class="hljs-keyword">this</span>.lastValidTouch = {};
                <span class="hljs-keyword">if</span> (Tooltip &amp;&amp; options.tooltip.enabled) {
                    chart.tooltip = <span class="hljs-keyword">new</span> Tooltip(chart, options.tooltip);
                    <span class="hljs-keyword">this</span>.followTouchMove = pick(options.tooltip.followTouchMove, <span class="hljs-literal">true</span>);
                }
                <span class="hljs-keyword">this</span>.setDOMEvents();
            },
            <span class="hljs-attr">zoomOption</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    options = chart.options.chart,
                    zoomType = options.zoomType || <span class="hljs-string">''</span>,
                    inverted = chart.inverted,
                    zoomX,
                    zoomY;
                <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/touch/</span>.test(e.type)) {
                    zoomType = pick(options.pinchType, zoomType);
                }
                <span class="hljs-keyword">this</span>.zoomX = zoomX = <span class="hljs-regexp">/x/</span>.test(zoomType);
                <span class="hljs-keyword">this</span>.zoomY = zoomY = <span class="hljs-regexp">/y/</span>.test(zoomType);
                <span class="hljs-keyword">this</span>.zoomHor = (zoomX &amp;&amp; !inverted) || (zoomY &amp;&amp; inverted);
                <span class="hljs-keyword">this</span>.zoomVert = (zoomY &amp;&amp; !inverted) || (zoomX &amp;&amp; inverted);
                <span class="hljs-keyword">this</span>.hasZoom = zoomX || zoomY;
            },
            <span class="hljs-attr">normalize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, chartPosition</span>) </span>{
                <span class="hljs-keyword">var</span> chartX,
                    chartY,
                    ePos;
                e = e || win.event;
                <span class="hljs-keyword">if</span> (!e.target) {
                    e.target = e.srcElement;
                }
                ePos = e.touches ? (e.touches.length ? e.touches.item(<span class="hljs-number">0</span>) : e.changedTouches[<span class="hljs-number">0</span>]) : e;
                <span class="hljs-keyword">if</span> (!chartPosition) {
                    <span class="hljs-keyword">this</span>.chartPosition = chartPosition = offset(<span class="hljs-keyword">this</span>.chart.container);
                }
                <span class="hljs-keyword">if</span> (ePos.pageX === <span class="hljs-literal">undefined</span>) {
                    chartX = <span class="hljs-built_in">Math</span>.max(e.x, e.clientX - chartPosition.left);
                    chartY = e.y;
                } <span class="hljs-keyword">else</span> {
                    chartX = ePos.pageX - chartPosition.left;
                    chartY = ePos.pageY - chartPosition.top;
                }
                <span class="hljs-keyword">return</span> extend(e, {
                    <span class="hljs-attr">chartX</span>: <span class="hljs-built_in">Math</span>.round(chartX),
                    <span class="hljs-attr">chartY</span>: <span class="hljs-built_in">Math</span>.round(chartY)
                });
            },
            <span class="hljs-attr">getCoordinates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> coordinates = {
                    <span class="hljs-attr">xAxis</span>: [],
                    <span class="hljs-attr">yAxis</span>: []
                };
                each(<span class="hljs-keyword">this</span>.chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                    coordinates[axis.isXAxis ? <span class="hljs-string">'xAxis'</span> : <span class="hljs-string">'yAxis'</span>].push({
                        <span class="hljs-attr">axis</span>: axis,
                        <span class="hljs-attr">value</span>: axis.toValue(e[axis.horiz ? <span class="hljs-string">'chartX'</span> : <span class="hljs-string">'chartY'</span>])
                    });
                });
                <span class="hljs-keyword">return</span> coordinates;
            },
            <span class="hljs-attr">runPointActions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> pointer = <span class="hljs-keyword">this</span>,
                    chart = pointer.chart,
                    series = chart.series,
                    tooltip = chart.tooltip,
                    shared = tooltip ? tooltip.shared : <span class="hljs-literal">false</span>,
                    followPointer,
                    updatePosition = <span class="hljs-literal">true</span>,
                    hoverPoint = chart.hoverPoint,
                    hoverSeries = chart.hoverSeries,
                    i,
                    anchor,
                    noSharedTooltip,
                    stickToHoverSeries,
                    directTouch,
                    kdpoints = [],
                    kdpointT;
                <span class="hljs-keyword">if</span> (!shared &amp;&amp; !hoverSeries) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; series.length; i++) {
                        <span class="hljs-keyword">if</span> (series[i].directTouch || !series[i].options.stickyTracking) {
                            series = [];
                        }
                    }
                }
                stickToHoverSeries = hoverSeries &amp;&amp; (shared ? hoverSeries.noSharedTooltip : hoverSeries.directTouch);
                <span class="hljs-keyword">if</span> (stickToHoverSeries &amp;&amp; hoverPoint) {
                    kdpoints = [hoverPoint];
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (!shared &amp;&amp; hoverSeries &amp;&amp; !hoverSeries.options.stickyTracking) {
                        series = [hoverSeries];
                    }
                    each(series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                        noSharedTooltip = s.noSharedTooltip &amp;&amp; shared;
                        directTouch = !shared &amp;&amp; s.directTouch;
                        <span class="hljs-keyword">if</span> (s.visible &amp;&amp; !noSharedTooltip &amp;&amp; !directTouch &amp;&amp; pick(s.options.enableMouseTracking, <span class="hljs-literal">true</span>)) {
                            kdpointT = s.searchPoint(e, !noSharedTooltip &amp;&amp; s.kdDimensions === <span class="hljs-number">1</span>);
                            <span class="hljs-keyword">if</span> (kdpointT &amp;&amp; kdpointT.series) {
                                kdpoints.push(kdpointT);
                            }
                        }
                    });
                    kdpoints.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p1, p2</span>) </span>{
                        <span class="hljs-keyword">var</span> isCloserX = p1.distX - p2.distX,
                            isCloser = p1.dist - p2.dist,
                            isAbove = (p2.series.group &amp;&amp; p2.series.group.zIndex) -
                            (p1.series.group &amp;&amp; p1.series.group.zIndex);
                        <span class="hljs-keyword">if</span> (isCloserX !== <span class="hljs-number">0</span> &amp;&amp; shared) {
                            <span class="hljs-keyword">return</span> isCloserX;
                        }
                        <span class="hljs-keyword">if</span> (isCloser !== <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">return</span> isCloser;
                        }
                        <span class="hljs-keyword">if</span> (isAbove !== <span class="hljs-number">0</span>) {
                            <span class="hljs-keyword">return</span> isAbove;
                        }
                        <span class="hljs-keyword">return</span> p1.series.index &gt; p2.series.index ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;
                    });
                }
                <span class="hljs-keyword">if</span> (shared) {
                    i = kdpoints.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (kdpoints[i].x !== kdpoints[<span class="hljs-number">0</span>].x || kdpoints[i].series.noSharedTooltip) {
                            kdpoints.splice(i, <span class="hljs-number">1</span>);
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (kdpoints[<span class="hljs-number">0</span>] &amp;&amp; (kdpoints[<span class="hljs-number">0</span>] !== <span class="hljs-keyword">this</span>.prevKDPoint || (tooltip &amp;&amp; tooltip.isHidden))) {
                    <span class="hljs-keyword">if</span> (shared &amp;&amp; !kdpoints[<span class="hljs-number">0</span>].series.noSharedTooltip) {
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; kdpoints.length; i++) {
                            kdpoints[i].onMouseOver(e, kdpoints[i] !== ((hoverSeries &amp;&amp; hoverSeries.directTouch &amp;&amp; hoverPoint) || kdpoints[<span class="hljs-number">0</span>]));
                        }
                        <span class="hljs-keyword">if</span> (kdpoints.length &amp;&amp; tooltip) {
                            tooltip.refresh(kdpoints.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p1, p2</span>) </span>{
                                <span class="hljs-keyword">return</span> p1.series.index - p2.series.index;
                            }), e);
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (tooltip) {
                            tooltip.refresh(kdpoints[<span class="hljs-number">0</span>], e);
                        }
                        <span class="hljs-keyword">if</span> (!hoverSeries || !hoverSeries.directTouch) {
                            kdpoints[<span class="hljs-number">0</span>].onMouseOver(e);
                        }
                    }
                    <span class="hljs-keyword">this</span>.prevKDPoint = kdpoints[<span class="hljs-number">0</span>];
                    updatePosition = <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (updatePosition) {
                    followPointer = hoverSeries &amp;&amp; hoverSeries.tooltipOptions.followPointer;
                    <span class="hljs-keyword">if</span> (tooltip &amp;&amp; followPointer &amp;&amp; !tooltip.isHidden) {
                        anchor = tooltip.getAnchor([{}], e);
                        tooltip.updatePosition({
                            <span class="hljs-attr">plotX</span>: anchor[<span class="hljs-number">0</span>],
                            <span class="hljs-attr">plotY</span>: anchor[<span class="hljs-number">1</span>]
                        });
                    }
                }
                <span class="hljs-keyword">if</span> (!pointer.unDocMouseMove) {
                    pointer.unDocMouseMove = addEvent(doc, <span class="hljs-string">'mousemove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">if</span> (charts[H.hoverChartIndex]) {
                            charts[H.hoverChartIndex].pointer.onDocumentMouseMove(e);
                        }
                    });
                }
                each(shared ? kdpoints : [pick(hoverPoint, kdpoints[<span class="hljs-number">0</span>])], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawPointCrosshair</span>(<span class="hljs-params">point</span>) </span>{
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawAxisCrosshair</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> (!point || point.series &amp;&amp; point.series[axis.coll] === axis) {
                            axis.drawCrosshair(e, point);
                        }
                    });
                });
            },
            <span class="hljs-attr">reset</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">allowMove, delay</span>) </span>{
                <span class="hljs-keyword">var</span> pointer = <span class="hljs-keyword">this</span>,
                    chart = pointer.chart,
                    hoverSeries = chart.hoverSeries,
                    hoverPoint = chart.hoverPoint,
                    hoverPoints = chart.hoverPoints,
                    tooltip = chart.tooltip,
                    tooltipPoints = tooltip &amp;&amp; tooltip.shared ? hoverPoints : hoverPoint;
                <span class="hljs-keyword">if</span> (allowMove &amp;&amp; tooltipPoints) {
                    each(splat(tooltipPoints), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                        <span class="hljs-keyword">if</span> (point.series.isCartesian &amp;&amp; point.plotX === <span class="hljs-literal">undefined</span>) {
                            allowMove = <span class="hljs-literal">false</span>;
                        }
                    });
                }
                <span class="hljs-keyword">if</span> (allowMove) {
                    <span class="hljs-keyword">if</span> (tooltip &amp;&amp; tooltipPoints) {
                        tooltip.refresh(tooltipPoints);
                        <span class="hljs-keyword">if</span> (hoverPoint) {
                            hoverPoint.setState(hoverPoint.state, <span class="hljs-literal">true</span>);
                            each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                                <span class="hljs-keyword">if</span> (axis.crosshair) {
                                    axis.drawCrosshair(<span class="hljs-literal">null</span>, hoverPoint);
                                }
                            });
                        }
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (hoverPoint) {
                        hoverPoint.onMouseOut();
                    }
                    <span class="hljs-keyword">if</span> (hoverPoints) {
                        each(hoverPoints, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                            point.setState();
                        });
                    }
                    <span class="hljs-keyword">if</span> (hoverSeries) {
                        hoverSeries.onMouseOut();
                    }
                    <span class="hljs-keyword">if</span> (tooltip) {
                        tooltip.hide(delay);
                    }
                    <span class="hljs-keyword">if</span> (pointer.unDocMouseMove) {
                        pointer.unDocMouseMove = pointer.unDocMouseMove();
                    }
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        axis.hideCrosshair();
                    });
                    pointer.hoverX = pointer.prevKDPoint = chart.hoverPoints = chart.hoverPoint = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">scaleGroups</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attribs, clip</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    seriesAttribs;
                each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    seriesAttribs = attribs || series.getPlotBox();
                    <span class="hljs-keyword">if</span> (series.xAxis &amp;&amp; series.xAxis.zoomEnabled &amp;&amp; series.group) {
                        series.group.attr(seriesAttribs);
                        <span class="hljs-keyword">if</span> (series.markerGroup) {
                            series.markerGroup.attr(seriesAttribs);
                            series.markerGroup.clip(clip ? chart.clipRect : <span class="hljs-literal">null</span>);
                        }
                        <span class="hljs-keyword">if</span> (series.dataLabelsGroup) {
                            series.dataLabelsGroup.attr(seriesAttribs);
                        }
                    }
                });
                chart.clipRect.attr(clip || chart.clipBox);
            },
            <span class="hljs-attr">dragStart</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                chart.mouseIsDown = e.type;
                chart.cancelClick = <span class="hljs-literal">false</span>;
                chart.mouseDownX = <span class="hljs-keyword">this</span>.mouseDownX = e.chartX;
                chart.mouseDownY = <span class="hljs-keyword">this</span>.mouseDownY = e.chartY;
            },
            <span class="hljs-attr">drag</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    chartOptions = chart.options.chart,
                    chartX = e.chartX,
                    chartY = e.chartY,
                    zoomHor = <span class="hljs-keyword">this</span>.zoomHor,
                    zoomVert = <span class="hljs-keyword">this</span>.zoomVert,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop,
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    clickedInside,
                    size,
                    selectionMarker = <span class="hljs-keyword">this</span>.selectionMarker,
                    mouseDownX = <span class="hljs-keyword">this</span>.mouseDownX,
                    mouseDownY = <span class="hljs-keyword">this</span>.mouseDownY,
                    panKey = chartOptions.panKey &amp;&amp; e[chartOptions.panKey + <span class="hljs-string">'Key'</span>];
                <span class="hljs-keyword">if</span> (selectionMarker &amp;&amp; selectionMarker.touch) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (chartX &lt; plotLeft) {
                    chartX = plotLeft;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chartX &gt; plotLeft + plotWidth) {
                    chartX = plotLeft + plotWidth;
                }
                <span class="hljs-keyword">if</span> (chartY &lt; plotTop) {
                    chartY = plotTop;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chartY &gt; plotTop + plotHeight) {
                    chartY = plotTop + plotHeight;
                }
                <span class="hljs-keyword">this</span>.hasDragged = <span class="hljs-built_in">Math</span>.sqrt(
                    <span class="hljs-built_in">Math</span>.pow(mouseDownX - chartX, <span class="hljs-number">2</span>) +
                    <span class="hljs-built_in">Math</span>.pow(mouseDownY - chartY, <span class="hljs-number">2</span>)
                );
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasDragged &gt; <span class="hljs-number">10</span>) {
                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);
                    <span class="hljs-keyword">if</span> (chart.hasCartesianSeries &amp;&amp; (<span class="hljs-keyword">this</span>.zoomX || <span class="hljs-keyword">this</span>.zoomY) &amp;&amp; clickedInside &amp;&amp; !panKey) {
                        <span class="hljs-keyword">if</span> (!selectionMarker) {
                            <span class="hljs-keyword">this</span>.selectionMarker = selectionMarker = chart.renderer.rect(
                                    plotLeft,
                                    plotTop,
                                    zoomHor ? <span class="hljs-number">1</span> : plotWidth,
                                    zoomVert ? <span class="hljs-number">1</span> : plotHeight,
                                    <span class="hljs-number">0</span>
                                )
                                .attr({
                                    <span class="hljs-attr">fill</span>: chartOptions.selectionMarkerFill || color(<span class="hljs-string">'#335cad'</span>).setOpacity(<span class="hljs-number">0.25</span>).get(),
                                    <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-selection-marker'</span>,
                                    <span class="hljs-string">'zIndex'</span>: <span class="hljs-number">7</span>
                                })
                                .add();
                        }
                    }
                    <span class="hljs-keyword">if</span> (selectionMarker &amp;&amp; zoomHor) {
                        size = chartX - mouseDownX;
                        selectionMarker.attr({
                            <span class="hljs-attr">width</span>: <span class="hljs-built_in">Math</span>.abs(size),
                            <span class="hljs-attr">x</span>: (size &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : size) + mouseDownX
                        });
                    }
                    <span class="hljs-keyword">if</span> (selectionMarker &amp;&amp; zoomVert) {
                        size = chartY - mouseDownY;
                        selectionMarker.attr({
                            <span class="hljs-attr">height</span>: <span class="hljs-built_in">Math</span>.abs(size),
                            <span class="hljs-attr">y</span>: (size &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : size) + mouseDownY
                        });
                    }
                    <span class="hljs-keyword">if</span> (clickedInside &amp;&amp; !selectionMarker &amp;&amp; chartOptions.panning) {
                        chart.pan(e, chartOptions.panning);
                    }
                }
            },
            <span class="hljs-attr">drop</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> pointer = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    hasPinched = <span class="hljs-keyword">this</span>.hasPinched;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.selectionMarker) {
                    <span class="hljs-keyword">var</span> selectionData = {
                            <span class="hljs-attr">originalEvent</span>: e,
                            <span class="hljs-attr">xAxis</span>: [],
                            <span class="hljs-attr">yAxis</span>: []
                        },
                        selectionBox = <span class="hljs-keyword">this</span>.selectionMarker,
                        selectionLeft = selectionBox.attr ? selectionBox.attr(<span class="hljs-string">'x'</span>) : selectionBox.x,
                        selectionTop = selectionBox.attr ? selectionBox.attr(<span class="hljs-string">'y'</span>) : selectionBox.y,
                        selectionWidth = selectionBox.attr ? selectionBox.attr(<span class="hljs-string">'width'</span>) : selectionBox.width,
                        selectionHeight = selectionBox.attr ? selectionBox.attr(<span class="hljs-string">'height'</span>) : selectionBox.height,
                        runZoom;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasDragged || hasPinched) {
                        each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                            <span class="hljs-keyword">if</span> (axis.zoomEnabled &amp;&amp; defined(axis.min) &amp;&amp; (hasPinched || pointer[{
                                    <span class="hljs-attr">xAxis</span>: <span class="hljs-string">'zoomX'</span>,
                                    <span class="hljs-attr">yAxis</span>: <span class="hljs-string">'zoomY'</span>
                                }[axis.coll]])) {
                                <span class="hljs-keyword">var</span> horiz = axis.horiz,
                                    minPixelPadding = e.type === <span class="hljs-string">'touchend'</span> ? axis.minPixelPadding : <span class="hljs-number">0</span>,
                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),
                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);
                                selectionData[axis.coll].push({
                                    <span class="hljs-attr">axis</span>: axis,
                                    <span class="hljs-attr">min</span>: <span class="hljs-built_in">Math</span>.min(selectionMin, selectionMax),
                                    <span class="hljs-attr">max</span>: <span class="hljs-built_in">Math</span>.max(selectionMin, selectionMax)
                                });
                                runZoom = <span class="hljs-literal">true</span>;
                            }
                        });
                        <span class="hljs-keyword">if</span> (runZoom) {
                            fireEvent(chart, <span class="hljs-string">'selection'</span>, selectionData, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
                                chart.zoom(extend(args, hasPinched ? {
                                    <span class="hljs-attr">animation</span>: <span class="hljs-literal">false</span>
                                } : <span class="hljs-literal">null</span>));
                            });
                        }
                    }
                    <span class="hljs-keyword">this</span>.selectionMarker = <span class="hljs-keyword">this</span>.selectionMarker.destroy();
                    <span class="hljs-keyword">if</span> (hasPinched) {
                        <span class="hljs-keyword">this</span>.scaleGroups();
                    }
                }
                <span class="hljs-keyword">if</span> (chart) {
                    css(chart.container, {
                        <span class="hljs-attr">cursor</span>: chart._cursor
                    });
                    chart.cancelClick = <span class="hljs-keyword">this</span>.hasDragged &gt; <span class="hljs-number">10</span>;
                    chart.mouseIsDown = <span class="hljs-keyword">this</span>.hasDragged = <span class="hljs-keyword">this</span>.hasPinched = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">this</span>.pinchDown = [];
                }
            },
            <span class="hljs-attr">onContainerMouseDown</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                e = <span class="hljs-keyword">this</span>.normalize(e);
                <span class="hljs-keyword">this</span>.zoomOption(e);
                <span class="hljs-keyword">if</span> (e.preventDefault) {
                    e.preventDefault();
                }
                <span class="hljs-keyword">this</span>.dragStart(e);
            },
            <span class="hljs-attr">onDocumentMouseUp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">if</span> (charts[H.hoverChartIndex]) {
                    charts[H.hoverChartIndex].pointer.drop(e);
                }
            },
            <span class="hljs-attr">onDocumentMouseMove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    chartPosition = <span class="hljs-keyword">this</span>.chartPosition;
                e = <span class="hljs-keyword">this</span>.normalize(e, chartPosition);
                <span class="hljs-keyword">if</span> (chartPosition &amp;&amp; !<span class="hljs-keyword">this</span>.inClass(e.target, <span class="hljs-string">'highcharts-tracker'</span>) &amp;&amp;
                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {
                    <span class="hljs-keyword">this</span>.reset();
                }
            },
            <span class="hljs-attr">onContainerMouseLeave</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = charts[H.hoverChartIndex];
                <span class="hljs-keyword">if</span> (chart &amp;&amp; (e.relatedTarget || e.toElement)) {
                    chart.pointer.reset();
                    chart.pointer.chartPosition = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">onContainerMouseMove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                <span class="hljs-keyword">if</span> (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {
                    H.hoverChartIndex = chart.index;
                }
                e = <span class="hljs-keyword">this</span>.normalize(e);
                e.returnValue = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (chart.mouseIsDown === <span class="hljs-string">'mousedown'</span>) {
                    <span class="hljs-keyword">this</span>.drag(e);
                }
                <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.inClass(e.target, <span class="hljs-string">'highcharts-tracker'</span>) ||
                        chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) &amp;&amp; !chart.openMenu) {
                    <span class="hljs-keyword">this</span>.runPointActions(e);
                }
            },
            <span class="hljs-attr">inClass</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, className</span>) </span>{
                <span class="hljs-keyword">var</span> elemClassName;
                <span class="hljs-keyword">while</span> (element) {
                    elemClassName = attr(element, <span class="hljs-string">'class'</span>);
                    <span class="hljs-keyword">if</span> (elemClassName) {
                        <span class="hljs-keyword">if</span> (elemClassName.indexOf(className) !== <span class="hljs-number">-1</span>) {
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                        }
                        <span class="hljs-keyword">if</span> (elemClassName.indexOf(<span class="hljs-string">'highcharts-container'</span>) !== <span class="hljs-number">-1</span>) {
                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                        }
                    }
                    element = element.parentNode;
                }
            },
            <span class="hljs-attr">onTrackerMouseOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.chart.hoverSeries,
                    relatedTarget = e.relatedTarget || e.toElement;
                <span class="hljs-keyword">if</span> (series &amp;&amp; relatedTarget &amp;&amp; !series.options.stickyTracking &amp;&amp;
                    !<span class="hljs-keyword">this</span>.inClass(relatedTarget, <span class="hljs-string">'highcharts-tooltip'</span>) &amp;&amp;
                    (!<span class="hljs-keyword">this</span>.inClass(relatedTarget, <span class="hljs-string">'highcharts-series-'</span> + series.index) ||
                        !<span class="hljs-keyword">this</span>.inClass(relatedTarget, <span class="hljs-string">'highcharts-tracker'</span>)
                    )
                ) {
                    series.onMouseOut();
                }
            },
            <span class="hljs-attr">onContainerClick</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    hoverPoint = chart.hoverPoint,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop;
                e = <span class="hljs-keyword">this</span>.normalize(e);
                <span class="hljs-keyword">if</span> (!chart.cancelClick) {
                    <span class="hljs-keyword">if</span> (hoverPoint &amp;&amp; <span class="hljs-keyword">this</span>.inClass(e.target, <span class="hljs-string">'highcharts-tracker'</span>)) {
                        fireEvent(hoverPoint.series, <span class="hljs-string">'click'</span>, extend(e, {
                            <span class="hljs-attr">point</span>: hoverPoint
                        }));
                        <span class="hljs-keyword">if</span> (chart.hoverPoint) {
                            hoverPoint.firePointEvent(<span class="hljs-string">'click'</span>, e);
                        }
                    } <span class="hljs-keyword">else</span> {
                        extend(e, <span class="hljs-keyword">this</span>.getCoordinates(e));
                        <span class="hljs-keyword">if</span> (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
                            fireEvent(chart, <span class="hljs-string">'click'</span>, e);
                        }
                    }
                }
            },
            <span class="hljs-attr">setDOMEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> pointer = <span class="hljs-keyword">this</span>,
                    container = pointer.chart.container;
                container.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    pointer.onContainerMouseDown(e);
                };
                container.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    pointer.onContainerMouseMove(e);
                };
                container.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    pointer.onContainerClick(e);
                };
                addEvent(container, <span class="hljs-string">'mouseleave'</span>, pointer.onContainerMouseLeave);
                <span class="hljs-keyword">if</span> (H.chartCount === <span class="hljs-number">1</span>) {
                    addEvent(doc, <span class="hljs-string">'mouseup'</span>, pointer.onDocumentMouseUp);
                }
                <span class="hljs-keyword">if</span> (H.hasTouch) {
                    container.ontouchstart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        pointer.onContainerTouchStart(e);
                    };
                    container.ontouchmove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        pointer.onContainerTouchMove(e);
                    };
                    <span class="hljs-keyword">if</span> (H.chartCount === <span class="hljs-number">1</span>) {
                        addEvent(doc, <span class="hljs-string">'touchend'</span>, pointer.onDocumentTouchEnd);
                    }
                }
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> prop;
                removeEvent(<span class="hljs-keyword">this</span>.chart.container, <span class="hljs-string">'mouseleave'</span>, <span class="hljs-keyword">this</span>.onContainerMouseLeave);
                <span class="hljs-keyword">if</span> (!H.chartCount) {
                    removeEvent(doc, <span class="hljs-string">'mouseup'</span>, <span class="hljs-keyword">this</span>.onDocumentMouseUp);
                    removeEvent(doc, <span class="hljs-string">'touchend'</span>, <span class="hljs-keyword">this</span>.onDocumentTouchEnd);
                }
                clearInterval(<span class="hljs-keyword">this</span>.tooltipTimeout);
                <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">this</span>[prop] = <span class="hljs-literal">null</span>;
                }
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> charts = H.charts,
            each = H.each,
            extend = H.extend,
            map = H.map,
            noop = H.noop,
            pick = H.pick,
            Pointer = H.Pointer;
        extend(Pointer.prototype, {
            <span class="hljs-attr">pinchTranslate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pinchDown, touches, transform, selectionMarker, clip, lastValidTouch</span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.zoomHor) {
                    <span class="hljs-keyword">this</span>.pinchTranslateDirection(<span class="hljs-literal">true</span>, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.zoomVert) {
                    <span class="hljs-keyword">this</span>.pinchTranslateDirection(<span class="hljs-literal">false</span>, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
            },
            <span class="hljs-attr">pinchTranslateDirection</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">horiz, pinchDown, touches, transform,
                selectionMarker, clip, lastValidTouch, forcedScale</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    xy = horiz ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'y'</span>,
                    XY = horiz ? <span class="hljs-string">'X'</span> : <span class="hljs-string">'Y'</span>,
                    sChartXY = <span class="hljs-string">'chart'</span> + XY,
                    wh = horiz ? <span class="hljs-string">'width'</span> : <span class="hljs-string">'height'</span>,
                    plotLeftTop = chart[<span class="hljs-string">'plot'</span> + (horiz ? <span class="hljs-string">'Left'</span> : <span class="hljs-string">'Top'</span>)],
                    selectionWH,
                    selectionXY,
                    clipXY,
                    scale = forcedScale || <span class="hljs-number">1</span>,
                    inverted = chart.inverted,
                    bounds = chart.bounds[horiz ? <span class="hljs-string">'h'</span> : <span class="hljs-string">'v'</span>],
                    singleTouch = pinchDown.length === <span class="hljs-number">1</span>,
                    touch0Start = pinchDown[<span class="hljs-number">0</span>][sChartXY],
                    touch0Now = touches[<span class="hljs-number">0</span>][sChartXY],
                    touch1Start = !singleTouch &amp;&amp; pinchDown[<span class="hljs-number">1</span>][sChartXY],
                    touch1Now = !singleTouch &amp;&amp; touches[<span class="hljs-number">1</span>][sChartXY],
                    outOfBounds,
                    transformScale,
                    scaleKey,
                    setScale = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (!singleTouch &amp;&amp; <span class="hljs-built_in">Math</span>.abs(touch0Start - touch1Start) &gt; <span class="hljs-number">20</span>) {
                            scale = forcedScale || <span class="hljs-built_in">Math</span>.abs(touch0Now - touch1Now) / <span class="hljs-built_in">Math</span>.abs(touch0Start - touch1Start);
                        }
                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;
                        selectionWH = chart[<span class="hljs-string">'plot'</span> + (horiz ? <span class="hljs-string">'Width'</span> : <span class="hljs-string">'Height'</span>)] / scale;
                    };
                setScale();
                selectionXY = clipXY;
                <span class="hljs-keyword">if</span> (selectionXY &lt; bounds.min) {
                    selectionXY = bounds.min;
                    outOfBounds = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectionXY + selectionWH &gt; bounds.max) {
                    selectionXY = bounds.max - selectionWH;
                    outOfBounds = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">if</span> (outOfBounds) {
                    touch0Now -= <span class="hljs-number">0.8</span> * (touch0Now - lastValidTouch[xy][<span class="hljs-number">0</span>]);
                    <span class="hljs-keyword">if</span> (!singleTouch) {
                        touch1Now -= <span class="hljs-number">0.8</span> * (touch1Now - lastValidTouch[xy][<span class="hljs-number">1</span>]);
                    }
                    setScale();
                } <span class="hljs-keyword">else</span> {
                    lastValidTouch[xy] = [touch0Now, touch1Now];
                }
                <span class="hljs-keyword">if</span> (!inverted) {
                    clip[xy] = clipXY - plotLeftTop;
                    clip[wh] = selectionWH;
                }
                scaleKey = inverted ? (horiz ? <span class="hljs-string">'scaleY'</span> : <span class="hljs-string">'scaleX'</span>) : <span class="hljs-string">'scale'</span> + XY;
                transformScale = inverted ? <span class="hljs-number">1</span> / scale : scale;
                selectionMarker[wh] = selectionWH;
                selectionMarker[xy] = selectionXY;
                transform[scaleKey] = scale;
                transform[<span class="hljs-string">'translate'</span> + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));
            },
            <span class="hljs-attr">pinch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>,
                    chart = self.chart,
                    pinchDown = self.pinchDown,
                    touches = e.touches,
                    touchesLength = touches.length,
                    lastValidTouch = self.lastValidTouch,
                    hasZoom = self.hasZoom,
                    selectionMarker = self.selectionMarker,
                    transform = {},
                    fireClickEvent = touchesLength === <span class="hljs-number">1</span> &amp;&amp; ((self.inClass(e.target, <span class="hljs-string">'highcharts-tracker'</span>) &amp;&amp;
                        chart.runTrackerClick) || self.runChartClick),
                    clip = {};
                <span class="hljs-keyword">if</span> (touchesLength &gt; <span class="hljs-number">1</span>) {
                    self.initiated = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">if</span> (hasZoom &amp;&amp; self.initiated &amp;&amp; !fireClickEvent) {
                    e.preventDefault();
                }
                map(touches, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">return</span> self.normalize(e);
                });
                <span class="hljs-keyword">if</span> (e.type === <span class="hljs-string">'touchstart'</span>) {
                    each(touches, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, i</span>) </span>{
                        pinchDown[i] = {
                            <span class="hljs-attr">chartX</span>: e.chartX,
                            <span class="hljs-attr">chartY</span>: e.chartY
                        };
                    });
                    lastValidTouch.x = [pinchDown[<span class="hljs-number">0</span>].chartX, pinchDown[<span class="hljs-number">1</span>] &amp;&amp; pinchDown[<span class="hljs-number">1</span>].chartX];
                    lastValidTouch.y = [pinchDown[<span class="hljs-number">0</span>].chartY, pinchDown[<span class="hljs-number">1</span>] &amp;&amp; pinchDown[<span class="hljs-number">1</span>].chartY];
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> (axis.zoomEnabled) {
                            <span class="hljs-keyword">var</span> bounds = chart.bounds[axis.horiz ? <span class="hljs-string">'h'</span> : <span class="hljs-string">'v'</span>],
                                minPixelPadding = axis.minPixelPadding,
                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),
                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),
                                absMin = <span class="hljs-built_in">Math</span>.min(min, max),
                                absMax = <span class="hljs-built_in">Math</span>.max(min, max);
                            bounds.min = <span class="hljs-built_in">Math</span>.min(axis.pos, absMin - minPixelPadding);
                            bounds.max = <span class="hljs-built_in">Math</span>.max(axis.pos + axis.len, absMax + minPixelPadding);
                        }
                    });
                    self.res = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (self.followTouchMove &amp;&amp; touchesLength === <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">this</span>.runPointActions(self.normalize(e));
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pinchDown.length) {
                    <span class="hljs-keyword">if</span> (!selectionMarker) {
                        self.selectionMarker = selectionMarker = extend({
                            <span class="hljs-attr">destroy</span>: noop,
                            <span class="hljs-attr">touch</span>: <span class="hljs-literal">true</span>
                        }, chart.plotBox);
                    }
                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                    self.hasPinched = hasZoom;
                    self.scaleGroups(transform, clip);
                    <span class="hljs-keyword">if</span> (self.res) {
                        self.res = <span class="hljs-literal">false</span>;
                        <span class="hljs-keyword">this</span>.reset(<span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);
                    }
                }
            },
            <span class="hljs-attr">touch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, start</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    hasMoved,
                    pinchDown,
                    isInside;
                <span class="hljs-keyword">if</span> (chart.index !== H.hoverChartIndex) {
                    <span class="hljs-keyword">this</span>.onContainerMouseLeave({
                        <span class="hljs-attr">relatedTarget</span>: <span class="hljs-literal">true</span>
                    });
                }
                H.hoverChartIndex = chart.index;
                <span class="hljs-keyword">if</span> (e.touches.length === <span class="hljs-number">1</span>) {
                    e = <span class="hljs-keyword">this</span>.normalize(e);
                    isInside = chart.isInsidePlot(
                        e.chartX - chart.plotLeft,
                        e.chartY - chart.plotTop
                    );
                    <span class="hljs-keyword">if</span> (isInside &amp;&amp; !chart.openMenu) {
                        <span class="hljs-keyword">if</span> (start) {
                            <span class="hljs-keyword">this</span>.runPointActions(e);
                        }
                        <span class="hljs-keyword">if</span> (e.type === <span class="hljs-string">'touchmove'</span>) {
                            pinchDown = <span class="hljs-keyword">this</span>.pinchDown;
                            hasMoved = pinchDown[<span class="hljs-number">0</span>] ? <span class="hljs-built_in">Math</span>.sqrt(
                                <span class="hljs-built_in">Math</span>.pow(pinchDown[<span class="hljs-number">0</span>].chartX - e.chartX, <span class="hljs-number">2</span>) +
                                <span class="hljs-built_in">Math</span>.pow(pinchDown[<span class="hljs-number">0</span>].chartY - e.chartY, <span class="hljs-number">2</span>)
                            ) &gt;= <span class="hljs-number">4</span> : <span class="hljs-literal">false</span>;
                        }
                        <span class="hljs-keyword">if</span> (pick(hasMoved, <span class="hljs-literal">true</span>)) {
                            <span class="hljs-keyword">this</span>.pinch(e);
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start) {
                        <span class="hljs-keyword">this</span>.reset();
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.touches.length === <span class="hljs-number">2</span>) {
                    <span class="hljs-keyword">this</span>.pinch(e);
                }
            },
            <span class="hljs-attr">onContainerTouchStart</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">this</span>.zoomOption(e);
                <span class="hljs-keyword">this</span>.touch(e, <span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">onContainerTouchMove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">this</span>.touch(e);
            },
            <span class="hljs-attr">onDocumentTouchEnd</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">if</span> (charts[H.hoverChartIndex]) {
                    charts[H.hoverChartIndex].pointer.drop(e);
                }
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            charts = H.charts,
            css = H.css,
            doc = H.doc,
            extend = H.extend,
            noop = H.noop,
            Pointer = H.Pointer,
            removeEvent = H.removeEvent,
            win = H.win,
            wrap = H.wrap;
        <span class="hljs-keyword">if</span> (win.PointerEvent || win.MSPointerEvent) {
            <span class="hljs-keyword">var</span> touches = {},
                hasPointerEvent = !!win.PointerEvent,
                getWebkitTouches = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> key,
                        fake = [];
                    fake.item = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) </span>{
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[i];
                    };
                    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> touches) {
                        <span class="hljs-keyword">if</span> (touches.hasOwnProperty(key)) {
                            fake.push({
                                <span class="hljs-attr">pageX</span>: touches[key].pageX,
                                <span class="hljs-attr">pageY</span>: touches[key].pageY,
                                <span class="hljs-attr">target</span>: touches[key].target
                            });
                        }
                    }
                    <span class="hljs-keyword">return</span> fake;
                },
                translateMSPointer = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, method, wktype, func</span>) </span>{
                    <span class="hljs-keyword">var</span> p;
                    <span class="hljs-keyword">if</span> ((e.pointerType === <span class="hljs-string">'touch'</span> || e.pointerType === e.MSPOINTER_TYPE_TOUCH) &amp;&amp; charts[H.hoverChartIndex]) {
                        func(e);
                        p = charts[H.hoverChartIndex].pointer;
                        p[method]({
                            <span class="hljs-attr">type</span>: wktype,
                            <span class="hljs-attr">target</span>: e.currentTarget,
                            <span class="hljs-attr">preventDefault</span>: noop,
                            <span class="hljs-attr">touches</span>: getWebkitTouches()
                        });
                    }
                };
            extend(Pointer.prototype, {
                <span class="hljs-attr">onContainerPointerDown</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    translateMSPointer(e, <span class="hljs-string">'onContainerTouchStart'</span>, <span class="hljs-string">'touchstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        touches[e.pointerId] = {
                            <span class="hljs-attr">pageX</span>: e.pageX,
                            <span class="hljs-attr">pageY</span>: e.pageY,
                            <span class="hljs-attr">target</span>: e.currentTarget
                        };
                    });
                },
                <span class="hljs-attr">onContainerPointerMove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    translateMSPointer(e, <span class="hljs-string">'onContainerTouchMove'</span>, <span class="hljs-string">'touchmove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        touches[e.pointerId] = {
                            <span class="hljs-attr">pageX</span>: e.pageX,
                            <span class="hljs-attr">pageY</span>: e.pageY
                        };
                        <span class="hljs-keyword">if</span> (!touches[e.pointerId].target) {
                            touches[e.pointerId].target = e.currentTarget;
                        }
                    });
                },
                <span class="hljs-attr">onDocumentPointerUp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    translateMSPointer(e, <span class="hljs-string">'onDocumentTouchEnd'</span>, <span class="hljs-string">'touchend'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">delete</span> touches[e.pointerId];
                    });
                },
                <span class="hljs-attr">batchMSEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
                    fn(<span class="hljs-keyword">this</span>.chart.container, hasPointerEvent ? <span class="hljs-string">'pointerdown'</span> : <span class="hljs-string">'MSPointerDown'</span>, <span class="hljs-keyword">this</span>.onContainerPointerDown);
                    fn(<span class="hljs-keyword">this</span>.chart.container, hasPointerEvent ? <span class="hljs-string">'pointermove'</span> : <span class="hljs-string">'MSPointerMove'</span>, <span class="hljs-keyword">this</span>.onContainerPointerMove);
                    fn(doc, hasPointerEvent ? <span class="hljs-string">'pointerup'</span> : <span class="hljs-string">'MSPointerUp'</span>, <span class="hljs-keyword">this</span>.onDocumentPointerUp);
                }
            });
            wrap(Pointer.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, chart, options</span>) </span>{
                proceed.call(<span class="hljs-keyword">this</span>, chart, options);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasZoom) {
                    css(chart.container, {
                        <span class="hljs-string">'-ms-touch-action'</span>: <span class="hljs-string">'none'</span>,
                        <span class="hljs-string">'touch-action'</span>: <span class="hljs-string">'none'</span>
                    });
                }
            });
            wrap(Pointer.prototype, <span class="hljs-string">'setDOMEvents'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
                proceed.apply(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasZoom || <span class="hljs-keyword">this</span>.followTouchMove) {
                    <span class="hljs-keyword">this</span>.batchMSEvents(addEvent);
                }
            });
            wrap(Pointer.prototype, <span class="hljs-string">'destroy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
                <span class="hljs-keyword">this</span>.batchMSEvents(removeEvent);
                proceed.call(<span class="hljs-keyword">this</span>);
            });
        }
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Legend,
            addEvent = H.addEvent,
            css = H.css,
            discardElement = H.discardElement,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            isFirefox = H.isFirefox,
            marginNames = H.marginNames,
            merge = H.merge,
            pick = H.pick,
            setAnimation = H.setAnimation,
            stableSort = H.stableSort,
            win = H.win,
            wrap = H.wrap;
        Legend = H.Legend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
            <span class="hljs-keyword">this</span>.init(chart, options);
        };
        Legend.prototype = {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
                <span class="hljs-keyword">this</span>.chart = chart;
                <span class="hljs-keyword">this</span>.setOptions(options);
                <span class="hljs-keyword">if</span> (options.enabled) {
                    <span class="hljs-keyword">this</span>.render();
                    addEvent(<span class="hljs-keyword">this</span>.chart, <span class="hljs-string">'endResize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">this</span>.legend.positionCheckboxes();
                    });
                }
            },
            <span class="hljs-attr">setOptions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">var</span> padding = pick(options.padding, <span class="hljs-number">8</span>);
                <span class="hljs-keyword">this</span>.options = options;
                <span class="hljs-keyword">this</span>.itemStyle = options.itemStyle;
                <span class="hljs-keyword">this</span>.itemHiddenStyle = merge(<span class="hljs-keyword">this</span>.itemStyle, options.itemHiddenStyle);
                <span class="hljs-keyword">this</span>.itemMarginTop = options.itemMarginTop || <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.padding = padding;
                <span class="hljs-keyword">this</span>.initialItemX = padding;
                <span class="hljs-keyword">this</span>.initialItemY = padding - <span class="hljs-number">5</span>;
                <span class="hljs-keyword">this</span>.maxItemWidth = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.itemHeight = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.symbolWidth = pick(options.symbolWidth, <span class="hljs-number">16</span>);
                <span class="hljs-keyword">this</span>.pages = [];
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                <span class="hljs-keyword">this</span>.setOptions(merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options, options));
                <span class="hljs-keyword">this</span>.destroy();
                chart.isDirtyLegend = chart.isDirtyBox = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    chart.redraw();
                }
            },
            <span class="hljs-attr">colorizeItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, visible</span>) </span>{
                item.legendGroup[visible ? <span class="hljs-string">'removeClass'</span> : <span class="hljs-string">'addClass'</span>](<span class="hljs-string">'highcharts-legend-item-hidden'</span>);
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    options = legend.options,
                    legendItem = item.legendItem,
                    legendLine = item.legendLine,
                    legendSymbol = item.legendSymbol,
                    hiddenColor = legend.itemHiddenStyle.color,
                    textColor = visible ? options.itemStyle.color : hiddenColor,
                    symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,
                    markerOptions = item.options &amp;&amp; item.options.marker,
                    symbolAttr = {
                        <span class="hljs-attr">fill</span>: symbolColor
                    },
                    key;
                <span class="hljs-keyword">if</span> (legendItem) {
                    legendItem.css({
                        <span class="hljs-attr">fill</span>: textColor,
                        <span class="hljs-attr">color</span>: textColor
                    });
                }
                <span class="hljs-keyword">if</span> (legendLine) {
                    legendLine.attr({
                        <span class="hljs-attr">stroke</span>: symbolColor
                    });
                }
                <span class="hljs-keyword">if</span> (legendSymbol) {
                    <span class="hljs-keyword">if</span> (markerOptions &amp;&amp; legendSymbol.isMarker) {
                        symbolAttr = item.pointAttribs();
                        <span class="hljs-keyword">if</span> (!visible) {
                            <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> symbolAttr) {
                                symbolAttr[key] = hiddenColor;
                            }
                        }
                    }
                    legendSymbol.attr(symbolAttr);
                }
            },
            <span class="hljs-attr">positionItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    options = legend.options,
                    symbolPadding = options.symbolPadding,
                    ltr = !options.rtl,
                    legendItemPos = item._legendItemPos,
                    itemX = legendItemPos[<span class="hljs-number">0</span>],
                    itemY = legendItemPos[<span class="hljs-number">1</span>],
                    checkbox = item.checkbox,
                    legendGroup = item.legendGroup;
                <span class="hljs-keyword">if</span> (legendGroup &amp;&amp; legendGroup.element) {
                    legendGroup.translate(
                        ltr ? itemX : legend.legendWidth - itemX - <span class="hljs-number">2</span> * symbolPadding - <span class="hljs-number">4</span>,
                        itemY
                    );
                }
                <span class="hljs-keyword">if</span> (checkbox) {
                    checkbox.x = itemX;
                    checkbox.y = itemY;
                }
            },
            <span class="hljs-attr">destroyItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">var</span> checkbox = item.checkbox;
                each([<span class="hljs-string">'legendItem'</span>, <span class="hljs-string">'legendLine'</span>, <span class="hljs-string">'legendSymbol'</span>, <span class="hljs-string">'legendGroup'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    <span class="hljs-keyword">if</span> (item[key]) {
                        item[key] = item[key].destroy();
                    }
                });
                <span class="hljs-keyword">if</span> (checkbox) {
                    discardElement(item.checkbox);
                }
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroyItems</span>(<span class="hljs-params">key</span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key]) {
                        <span class="hljs-keyword">this</span>[key] = <span class="hljs-keyword">this</span>[key].destroy();
                    }
                }
                each(<span class="hljs-keyword">this</span>.getAllItems(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                    each([<span class="hljs-string">'legendItem'</span>, <span class="hljs-string">'legendGroup'</span>], destroyItems, item);
                });
                each([<span class="hljs-string">'box'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'group'</span>], destroyItems, <span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">this</span>.display = <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">positionCheckboxes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scrollOffset</span>) </span>{
                <span class="hljs-keyword">var</span> alignAttr = <span class="hljs-keyword">this</span>.group &amp;&amp; <span class="hljs-keyword">this</span>.group.alignAttr,
                    translateY,
                    clipHeight = <span class="hljs-keyword">this</span>.clipHeight || <span class="hljs-keyword">this</span>.legendHeight,
                    titleHeight = <span class="hljs-keyword">this</span>.titleHeight;
                <span class="hljs-keyword">if</span> (alignAttr) {
                    translateY = alignAttr.translateY;
                    each(<span class="hljs-keyword">this</span>.allItems, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                        <span class="hljs-keyword">var</span> checkbox = item.checkbox,
                            top;
                        <span class="hljs-keyword">if</span> (checkbox) {
                            top = translateY + titleHeight + checkbox.y + (scrollOffset || <span class="hljs-number">0</span>) + <span class="hljs-number">3</span>;
                            css(checkbox, {
                                <span class="hljs-attr">left</span>: (alignAttr.translateX + item.checkboxOffset + checkbox.x - <span class="hljs-number">20</span>) + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">top</span>: top + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">display</span>: top &gt; translateY - <span class="hljs-number">6</span> &amp;&amp; top &lt; translateY + clipHeight - <span class="hljs-number">6</span> ? <span class="hljs-string">''</span> : <span class="hljs-string">'none'</span>
                            });
                        }
                    });
                }
            },
            <span class="hljs-attr">renderTitle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    padding = <span class="hljs-keyword">this</span>.padding,
                    titleOptions = options.title,
                    titleHeight = <span class="hljs-number">0</span>,
                    bBox;
                <span class="hljs-keyword">if</span> (titleOptions.text) {
                    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.title) {
                        <span class="hljs-keyword">this</span>.title = <span class="hljs-keyword">this</span>.chart.renderer.label(titleOptions.text, padding - <span class="hljs-number">3</span>, padding - <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'legend-title'</span>)
                            .attr({
                                <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                            })
                            .css(titleOptions.style)
                            .add(<span class="hljs-keyword">this</span>.group);
                    }
                    bBox = <span class="hljs-keyword">this</span>.title.getBBox();
                    titleHeight = bBox.height;
                    <span class="hljs-keyword">this</span>.offsetWidth = bBox.width;
                    <span class="hljs-keyword">this</span>.contentGroup.attr({
                        <span class="hljs-attr">translateY</span>: titleHeight
                    });
                }
                <span class="hljs-keyword">this</span>.titleHeight = titleHeight;
            },
            <span class="hljs-attr">setText</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options;
                item.legendItem.attr({
                    <span class="hljs-attr">text</span>: options.labelFormat ? H.format(options.labelFormat, item) : options.labelFormatter.call(item)
                });
            },
            <span class="hljs-attr">renderItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    chart = legend.chart,
                    renderer = chart.renderer,
                    options = legend.options,
                    horizontal = options.layout === <span class="hljs-string">'horizontal'</span>,
                    symbolWidth = legend.symbolWidth,
                    symbolPadding = options.symbolPadding,
                    itemStyle = legend.itemStyle,
                    itemHiddenStyle = legend.itemHiddenStyle,
                    padding = legend.padding,
                    itemDistance = horizontal ? pick(options.itemDistance, <span class="hljs-number">20</span>) : <span class="hljs-number">0</span>,
                    ltr = !options.rtl,
                    itemHeight,
                    widthOption = options.width,
                    itemMarginBottom = options.itemMarginBottom || <span class="hljs-number">0</span>,
                    itemMarginTop = legend.itemMarginTop,
                    initialItemX = legend.initialItemX,
                    bBox,
                    itemWidth,
                    li = item.legendItem,
                    isSeries = !item.series,
                    series = !isSeries &amp;&amp; item.series.drawLegendSymbol ? item.series : item,
                    seriesOptions = series.options,
                    showCheckbox = legend.createCheckboxForItem &amp;&amp; seriesOptions &amp;&amp; seriesOptions.showCheckbox,
                    useHTML = options.useHTML,
                    fontSize = <span class="hljs-number">12</span>;
                <span class="hljs-keyword">if</span> (!li) {
                    item.legendGroup = renderer.g(<span class="hljs-string">'legend-item'</span>)
                        .addClass(<span class="hljs-string">'highcharts-'</span> + series.type + <span class="hljs-string">'-series highcharts-color-'</span> + item.colorIndex +
                            (item.options.className ? <span class="hljs-string">' '</span> + item.options.className : <span class="hljs-string">''</span>) +
                            (isSeries ? <span class="hljs-string">' highcharts-series-'</span> + item.index : <span class="hljs-string">''</span>)
                        )
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        })
                        .add(legend.scrollGroup);
                    item.legendItem = li = renderer.text(
                            <span class="hljs-string">''</span>,
                            ltr ? symbolWidth + symbolPadding : -symbolPadding,
                            legend.baseline || <span class="hljs-number">0</span>,
                            useHTML
                        )
                        .css(merge(item.visible ? itemStyle : itemHiddenStyle))
                        .attr({
                            <span class="hljs-attr">align</span>: ltr ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'right'</span>,
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>
                        })
                        .add(item.legendGroup);
                    <span class="hljs-keyword">if</span> (!legend.baseline) {
                        fontSize = itemStyle.fontSize;
                        legend.fontMetrics = renderer.fontMetrics(
                            fontSize,
                            li
                        );
                        legend.baseline = legend.fontMetrics.f + <span class="hljs-number">3</span> + itemMarginTop;
                        li.attr(<span class="hljs-string">'y'</span>, legend.baseline);
                    }
                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
                    series.drawLegendSymbol(legend, item);
                    <span class="hljs-keyword">if</span> (legend.setItemEvents) {
                        legend.setItemEvents(item, li, useHTML);
                    }
                    <span class="hljs-keyword">if</span> (showCheckbox) {
                        legend.createCheckboxForItem(item);
                    }
                }
                legend.colorizeItem(item, item.visible);
                legend.setText(item);
                bBox = li.getBBox();
                itemWidth = item.checkboxOffset =
                    options.itemWidth ||
                    item.legendItemWidth ||
                    symbolWidth + symbolPadding + bBox.width + itemDistance + (showCheckbox ? <span class="hljs-number">20</span> : <span class="hljs-number">0</span>);
                legend.itemHeight = itemHeight = <span class="hljs-built_in">Math</span>.round(item.legendItemHeight || bBox.height);
                <span class="hljs-keyword">if</span> (horizontal &amp;&amp; legend.itemX - initialItemX + itemWidth &gt;
                    (widthOption || (chart.chartWidth - <span class="hljs-number">2</span> * padding - initialItemX - options.x))) {
                    legend.itemX = initialItemX;
                    legend.itemY += itemMarginTop + legend.lastLineHeight + itemMarginBottom;
                    legend.lastLineHeight = <span class="hljs-number">0</span>;
                }
                legend.maxItemWidth = <span class="hljs-built_in">Math</span>.max(legend.maxItemWidth, itemWidth);
                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;
                legend.lastLineHeight = <span class="hljs-built_in">Math</span>.max(itemHeight, legend.lastLineHeight);
                item._legendItemPos = [legend.itemX, legend.itemY];
                <span class="hljs-keyword">if</span> (horizontal) {
                    legend.itemX += itemWidth;
                } <span class="hljs-keyword">else</span> {
                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                    legend.lastLineHeight = itemHeight;
                }
                legend.offsetWidth = widthOption || <span class="hljs-built_in">Math</span>.max(
                    (horizontal ? legend.itemX - initialItemX - itemDistance : itemWidth) + padding,
                    legend.offsetWidth
                );
            },
            <span class="hljs-attr">getAllItems</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> allItems = [];
                each(<span class="hljs-keyword">this</span>.chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">var</span> seriesOptions = series &amp;&amp; series.options;
                    <span class="hljs-keyword">if</span> (series &amp;&amp; pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? <span class="hljs-literal">undefined</span> : <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) {
                        allItems = allItems.concat(
                            series.legendItems ||
                            (seriesOptions.legendType === <span class="hljs-string">'point'</span> ?
                                series.data :
                                series)
                        );
                    }
                });
                <span class="hljs-keyword">return</span> allItems;
            },
            <span class="hljs-attr">adjustMargins</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">margin, spacing</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    options = <span class="hljs-keyword">this</span>.options,
                    alignment = options.align.charAt(<span class="hljs-number">0</span>) + options.verticalAlign.charAt(<span class="hljs-number">0</span>) + options.layout.charAt(<span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (!options.floating) {
                    each([
                        <span class="hljs-regexp">/(lth|ct|rth)/</span>,
                        /(rtv|rm|rbv)/,
                        /(rbh|cb|lbh)/,
                        /(lbv|lm|ltv)/
                    ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">alignments, side</span>) </span>{
                        <span class="hljs-keyword">if</span> (alignments.test(alignment) &amp;&amp; !defined(margin[side])) {
                            chart[marginNames[side]] = <span class="hljs-built_in">Math</span>.max(
                                chart[marginNames[side]],
                                chart.legend[(side + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> ? <span class="hljs-string">'legendHeight'</span> : <span class="hljs-string">'legendWidth'</span>] + [<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>][side] * options[(side % <span class="hljs-number">2</span>) ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'y'</span>] +
                                pick(options.margin, <span class="hljs-number">12</span>) +
                                spacing[side]
                            );
                        }
                    });
                }
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    chart = legend.chart,
                    renderer = chart.renderer,
                    legendGroup = legend.group,
                    allItems,
                    display,
                    legendWidth,
                    legendHeight,
                    box = legend.box,
                    options = legend.options,
                    padding = legend.padding;
                legend.itemX = legend.initialItemX;
                legend.itemY = legend.initialItemY;
                legend.offsetWidth = <span class="hljs-number">0</span>;
                legend.lastItemY = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (!legendGroup) {
                    legend.group = legendGroup = renderer.g(<span class="hljs-string">'legend'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">7</span>
                        })
                        .add();
                    legend.contentGroup = renderer.g()
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        })
                        .add(legendGroup);
                    legend.scrollGroup = renderer.g()
                        .add(legend.contentGroup);
                }
                legend.renderTitle();
                allItems = legend.getAllItems();
                stableSort(allItems, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                    <span class="hljs-keyword">return</span> ((a.options &amp;&amp; a.options.legendIndex) || <span class="hljs-number">0</span>) - ((b.options &amp;&amp; b.options.legendIndex) || <span class="hljs-number">0</span>);
                });
                <span class="hljs-keyword">if</span> (options.reversed) {
                    allItems.reverse();
                }
                legend.allItems = allItems;
                legend.display = display = !!allItems.length;
                legend.lastLineHeight = <span class="hljs-number">0</span>;
                each(allItems, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                    legend.renderItem(item);
                });
                legendWidth = (options.width || legend.offsetWidth) + padding;
                legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
                legendHeight = legend.handleOverflow(legendHeight);
                legendHeight += padding;
                <span class="hljs-keyword">if</span> (!box) {
                    legend.box = box = renderer.rect()
                        .addClass(<span class="hljs-string">'highcharts-legend-box'</span>)
                        .attr({
                            <span class="hljs-attr">r</span>: options.borderRadius
                        })
                        .add(legendGroup);
                    box.isNew = <span class="hljs-literal">true</span>;
                }
                box
                    .attr({
                        <span class="hljs-attr">stroke</span>: options.borderColor,
                        <span class="hljs-string">'stroke-width'</span>: options.borderWidth || <span class="hljs-number">0</span>,
                        <span class="hljs-attr">fill</span>: options.backgroundColor || <span class="hljs-string">'none'</span>
                    })
                    .shadow(options.shadow);
                <span class="hljs-keyword">if</span> (legendWidth &gt; <span class="hljs-number">0</span> &amp;&amp; legendHeight &gt; <span class="hljs-number">0</span>) {
                    box[box.isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>](
                        box.crisp({
                            <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">width</span>: legendWidth,
                            <span class="hljs-attr">height</span>: legendHeight
                        }, box.strokeWidth())
                    );
                    box.isNew = <span class="hljs-literal">false</span>;
                }
                box[display ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>]();
                legend.legendWidth = legendWidth;
                legend.legendHeight = legendHeight;
                each(allItems, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                    legend.positionItem(item);
                });
                <span class="hljs-keyword">if</span> (display) {
                    legendGroup.align(extend({
                        <span class="hljs-attr">width</span>: legendWidth,
                        <span class="hljs-attr">height</span>: legendHeight
                    }, options), <span class="hljs-literal">true</span>, <span class="hljs-string">'spacingBox'</span>);
                }
                <span class="hljs-keyword">if</span> (!chart.isResizing) {
                    <span class="hljs-keyword">this</span>.positionCheckboxes();
                }
            },
            <span class="hljs-attr">handleOverflow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">legendHeight</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    renderer = chart.renderer,
                    options = <span class="hljs-keyword">this</span>.options,
                    optionsY = options.y,
                    alignTop = options.verticalAlign === <span class="hljs-string">'top'</span>,
                    spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - <span class="hljs-keyword">this</span>.padding,
                    maxHeight = options.maxHeight,
                    clipHeight,
                    clipRect = <span class="hljs-keyword">this</span>.clipRect,
                    navOptions = options.navigation,
                    animation = pick(navOptions.animation, <span class="hljs-literal">true</span>),
                    arrowSize = navOptions.arrowSize || <span class="hljs-number">12</span>,
                    nav = <span class="hljs-keyword">this</span>.nav,
                    pages = <span class="hljs-keyword">this</span>.pages,
                    padding = <span class="hljs-keyword">this</span>.padding,
                    lastY,
                    allItems = <span class="hljs-keyword">this</span>.allItems,
                    clipToHeight = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">height</span>) </span>{
                        <span class="hljs-keyword">if</span> (height) {
                            clipRect.attr({
                                <span class="hljs-attr">height</span>: height
                            });
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clipRect) {
                            legend.clipRect = clipRect.destroy();
                            legend.contentGroup.clip();
                        }
                        <span class="hljs-keyword">if</span> (legend.contentGroup.div) {
                            legend.contentGroup.div.style.clip = height ?
                                <span class="hljs-string">'rect('</span> + padding + <span class="hljs-string">'px,9999px,'</span> +
                                (padding + height) + <span class="hljs-string">'px,0)'</span> :
                                <span class="hljs-string">'auto'</span>;
                        }
                    };
                <span class="hljs-keyword">if</span> (options.layout === <span class="hljs-string">'horizontal'</span> &amp;&amp; options.verticalAlign !== <span class="hljs-string">'middle'</span> &amp;&amp; !options.floating) {
                    spaceHeight /= <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (maxHeight) {
                    spaceHeight = <span class="hljs-built_in">Math</span>.min(spaceHeight, maxHeight);
                }
                pages.length = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (legendHeight &gt; spaceHeight &amp;&amp; navOptions.enabled !== <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">this</span>.clipHeight = clipHeight = <span class="hljs-built_in">Math</span>.max(spaceHeight - <span class="hljs-number">20</span> - <span class="hljs-keyword">this</span>.titleHeight - padding, <span class="hljs-number">0</span>);
                    <span class="hljs-keyword">this</span>.currentPage = pick(<span class="hljs-keyword">this</span>.currentPage, <span class="hljs-number">1</span>);
                    <span class="hljs-keyword">this</span>.fullHeight = legendHeight;
                    each(allItems, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, i</span>) </span>{
                        <span class="hljs-keyword">var</span> y = item._legendItemPos[<span class="hljs-number">1</span>],
                            h = <span class="hljs-built_in">Math</span>.round(item.legendItem.getBBox().height),
                            len = pages.length;
                        <span class="hljs-keyword">if</span> (!len || (y - pages[len - <span class="hljs-number">1</span>] &gt; clipHeight &amp;&amp; (lastY || y) !== pages[len - <span class="hljs-number">1</span>])) {
                            pages.push(lastY || y);
                            len++;
                        }
                        <span class="hljs-keyword">if</span> (i === allItems.length - <span class="hljs-number">1</span> &amp;&amp; y + h - pages[len - <span class="hljs-number">1</span>] &gt; clipHeight) {
                            pages.push(y);
                        }
                        <span class="hljs-keyword">if</span> (y !== lastY) {
                            lastY = y;
                        }
                    });
                    <span class="hljs-keyword">if</span> (!clipRect) {
                        clipRect = legend.clipRect = renderer.clipRect(<span class="hljs-number">0</span>, padding, <span class="hljs-number">9999</span>, <span class="hljs-number">0</span>);
                        legend.contentGroup.clip(clipRect);
                    }
                    clipToHeight(clipHeight);
                    <span class="hljs-keyword">if</span> (!nav) {
                        <span class="hljs-keyword">this</span>.nav = nav = renderer.g().attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        }).add(<span class="hljs-keyword">this</span>.group);
                        <span class="hljs-keyword">this</span>.up = renderer.symbol(<span class="hljs-string">'triangle'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, arrowSize, arrowSize)
                            .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                legend.scroll(<span class="hljs-number">-1</span>, animation);
                            })
                            .add(nav);
                        <span class="hljs-keyword">this</span>.pager = renderer.text(<span class="hljs-string">''</span>, <span class="hljs-number">15</span>, <span class="hljs-number">10</span>)
                            .addClass(<span class="hljs-string">'highcharts-legend-navigation'</span>)
                            .css(navOptions.style)
                            .add(nav);
                        <span class="hljs-keyword">this</span>.down = renderer.symbol(<span class="hljs-string">'triangle-down'</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, arrowSize, arrowSize)
                            .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                legend.scroll(<span class="hljs-number">1</span>, animation);
                            })
                            .add(nav);
                    }
                    legend.scroll(<span class="hljs-number">0</span>);
                    legendHeight = spaceHeight;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nav) {
                    clipToHeight();
                    nav.hide();
                    <span class="hljs-keyword">this</span>.scrollGroup.attr({
                        <span class="hljs-attr">translateY</span>: <span class="hljs-number">1</span>
                    });
                    <span class="hljs-keyword">this</span>.clipHeight = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">return</span> legendHeight;
            },
            <span class="hljs-attr">scroll</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">scrollBy, animation</span>) </span>{
                <span class="hljs-keyword">var</span> pages = <span class="hljs-keyword">this</span>.pages,
                    pageCount = pages.length,
                    currentPage = <span class="hljs-keyword">this</span>.currentPage + scrollBy,
                    clipHeight = <span class="hljs-keyword">this</span>.clipHeight,
                    navOptions = <span class="hljs-keyword">this</span>.options.navigation,
                    pager = <span class="hljs-keyword">this</span>.pager,
                    padding = <span class="hljs-keyword">this</span>.padding,
                    scrollOffset;
                <span class="hljs-keyword">if</span> (currentPage &gt; pageCount) {
                    currentPage = pageCount;
                }
                <span class="hljs-keyword">if</span> (currentPage &gt; <span class="hljs-number">0</span>) {
                    <span class="hljs-keyword">if</span> (animation !== <span class="hljs-literal">undefined</span>) {
                        setAnimation(animation, <span class="hljs-keyword">this</span>.chart);
                    }
                    <span class="hljs-keyword">this</span>.nav.attr({
                        <span class="hljs-attr">translateX</span>: padding,
                        <span class="hljs-attr">translateY</span>: clipHeight + <span class="hljs-keyword">this</span>.padding + <span class="hljs-number">7</span> + <span class="hljs-keyword">this</span>.titleHeight,
                        <span class="hljs-attr">visibility</span>: <span class="hljs-string">'visible'</span>
                    });
                    <span class="hljs-keyword">this</span>.up.attr({
                        <span class="hljs-string">'class'</span>: currentPage === <span class="hljs-number">1</span> ? <span class="hljs-string">'highcharts-legend-nav-inactive'</span> : <span class="hljs-string">'highcharts-legend-nav-active'</span>
                    });
                    pager.attr({
                        <span class="hljs-attr">text</span>: currentPage + <span class="hljs-string">'/'</span> + pageCount
                    });
                    <span class="hljs-keyword">this</span>.down.attr({
                        <span class="hljs-string">'x'</span>: <span class="hljs-number">18</span> + <span class="hljs-keyword">this</span>.pager.getBBox().width,
                        <span class="hljs-string">'class'</span>: currentPage === pageCount ? <span class="hljs-string">'highcharts-legend-nav-inactive'</span> : <span class="hljs-string">'highcharts-legend-nav-active'</span>
                    });
                    <span class="hljs-keyword">this</span>.up
                        .attr({
                            <span class="hljs-attr">fill</span>: currentPage === <span class="hljs-number">1</span> ? navOptions.inactiveColor : navOptions.activeColor
                        })
                        .css({
                            <span class="hljs-attr">cursor</span>: currentPage === <span class="hljs-number">1</span> ? <span class="hljs-string">'default'</span> : <span class="hljs-string">'pointer'</span>
                        });
                    <span class="hljs-keyword">this</span>.down
                        .attr({
                            <span class="hljs-attr">fill</span>: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
                        })
                        .css({
                            <span class="hljs-attr">cursor</span>: currentPage === pageCount ? <span class="hljs-string">'default'</span> : <span class="hljs-string">'pointer'</span>
                        });
                    scrollOffset = -pages[currentPage - <span class="hljs-number">1</span>] + <span class="hljs-keyword">this</span>.initialItemY;
                    <span class="hljs-keyword">this</span>.scrollGroup.animate({
                        <span class="hljs-attr">translateY</span>: scrollOffset
                    });
                    <span class="hljs-keyword">this</span>.currentPage = currentPage;
                    <span class="hljs-keyword">this</span>.positionCheckboxes(scrollOffset);
                }
            }
        };
        H.LegendSymbolMixin = {
            <span class="hljs-attr">drawRectangle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">legend, item</span>) </span>{
                <span class="hljs-keyword">var</span> options = legend.options,
                    symbolHeight = legend.symbolHeight,
                    square = options.squareSymbol,
                    symbolWidth = square ? symbolHeight : legend.symbolWidth;
                item.legendSymbol = <span class="hljs-keyword">this</span>.chart.renderer.rect(
                        square ? (legend.symbolWidth - symbolHeight) / <span class="hljs-number">2</span> : <span class="hljs-number">0</span>,
                        legend.baseline - symbolHeight + <span class="hljs-number">1</span>,
                        symbolWidth,
                        symbolHeight,
                        pick(legend.options.symbolRadius, symbolHeight / <span class="hljs-number">2</span>)
                    )
                    .addClass(<span class="hljs-string">'highcharts-point'</span>)
                    .attr({
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3</span>
                    }).add(item.legendGroup);
            },
            <span class="hljs-attr">drawLineMarker</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">legend</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    markerOptions = options.marker,
                    radius,
                    legendSymbol,
                    symbolWidth = legend.symbolWidth,
                    symbolHeight = legend.symbolHeight,
                    generalRadius = symbolHeight / <span class="hljs-number">2</span>,
                    renderer = <span class="hljs-keyword">this</span>.chart.renderer,
                    legendItemGroup = <span class="hljs-keyword">this</span>.legendGroup,
                    verticalCenter = legend.baseline - <span class="hljs-built_in">Math</span>.round(legend.fontMetrics.b * <span class="hljs-number">0.3</span>),
                    attr = {};
                attr = {
                    <span class="hljs-string">'stroke-width'</span>: options.lineWidth || <span class="hljs-number">0</span>
                };
                <span class="hljs-keyword">if</span> (options.dashStyle) {
                    attr.dashstyle = options.dashStyle;
                }
                <span class="hljs-keyword">this</span>.legendLine = renderer.path([
                        <span class="hljs-string">'M'</span>,
                        <span class="hljs-number">0</span>,
                        verticalCenter,
                        <span class="hljs-string">'L'</span>,
                        symbolWidth,
                        verticalCenter
                    ])
                    .addClass(<span class="hljs-string">'highcharts-graph'</span>)
                    .attr(attr)
                    .add(legendItemGroup);
                <span class="hljs-keyword">if</span> (markerOptions &amp;&amp; markerOptions.enabled !== <span class="hljs-literal">false</span>) {
                    radius = <span class="hljs-built_in">Math</span>.min(
                        pick(markerOptions.radius, generalRadius),
                        generalRadius
                    );
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.symbol.indexOf(<span class="hljs-string">'url'</span>) === <span class="hljs-number">0</span>) {
                        markerOptions = merge(markerOptions, {
                            <span class="hljs-attr">width</span>: symbolHeight,
                            <span class="hljs-attr">height</span>: symbolHeight
                        });
                        radius = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">this</span>.legendSymbol = legendSymbol = renderer.symbol(
                            <span class="hljs-keyword">this</span>.symbol,
                            (symbolWidth / <span class="hljs-number">2</span>) - radius,
                            verticalCenter - radius,
                            <span class="hljs-number">2</span> * radius,
                            <span class="hljs-number">2</span> * radius,
                            markerOptions
                        )
                        .addClass(<span class="hljs-string">'highcharts-point'</span>)
                        .add(legendItemGroup);
                    legendSymbol.isMarker = <span class="hljs-literal">true</span>;
                }
            }
        };
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/Trident\/7\.0/</span>.test(win.navigator.userAgent) || isFirefox) {
            wrap(Legend.prototype, <span class="hljs-string">'positionItem'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, item</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    runPositionItem = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (item._legendItemPos) {
                            proceed.call(legend, item);
                        }
                    };
                runPositionItem();
                setTimeout(runPositionItem);
            });
        }
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            animate = H.animate,
            animObject = H.animObject,
            attr = H.attr,
            doc = H.doc,
            Axis = H.Axis,
            createElement = H.createElement,
            defaultOptions = H.defaultOptions,
            discardElement = H.discardElement,
            charts = H.charts,
            css = H.css,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            find = H.find,
            fireEvent = H.fireEvent,
            getStyle = H.getStyle,
            grep = H.grep,
            isNumber = H.isNumber,
            isObject = H.isObject,
            isString = H.isString,
            Legend = H.Legend,
            marginNames = H.marginNames,
            merge = H.merge,
            Pointer = H.Pointer,
            pick = H.pick,
            pInt = H.pInt,
            removeEvent = H.removeEvent,
            seriesTypes = H.seriesTypes,
            splat = H.splat,
            svg = H.svg,
            syncTimeout = H.syncTimeout,
            win = H.win,
            Renderer = H.Renderer;
        <span class="hljs-keyword">var</span> Chart = H.Chart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">this</span>.getArgs.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        };
        H.chart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Chart(a, b, c);
        };
        Chart.prototype = {
            <span class="hljs-attr">callbacks</span>: [],
            <span class="hljs-attr">getArgs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">if</span> (isString(args[<span class="hljs-number">0</span>]) || args[<span class="hljs-number">0</span>].nodeName) {
                    <span class="hljs-keyword">this</span>.renderTo = args.shift();
                }
                <span class="hljs-keyword">this</span>.init(args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);
            },
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">userOptions, callback</span>) </span>{
                <span class="hljs-keyword">var</span> options,
                    seriesOptions = userOptions.series;
                userOptions.series = <span class="hljs-literal">null</span>;
                options = merge(defaultOptions, userOptions);
                options.series = userOptions.series = seriesOptions;
                <span class="hljs-keyword">this</span>.userOptions = userOptions;
                <span class="hljs-keyword">this</span>.respRules = [];
                <span class="hljs-keyword">var</span> optionsChart = options.chart;
                <span class="hljs-keyword">var</span> chartEvents = optionsChart.events;
                <span class="hljs-keyword">this</span>.margin = [];
                <span class="hljs-keyword">this</span>.spacing = [];
                <span class="hljs-keyword">this</span>.bounds = {
                    <span class="hljs-attr">h</span>: {},
                    <span class="hljs-attr">v</span>: {}
                };
                <span class="hljs-keyword">this</span>.callback = callback;
                <span class="hljs-keyword">this</span>.isResizing = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.options = options;
                <span class="hljs-keyword">this</span>.axes = [];
                <span class="hljs-keyword">this</span>.series = [];
                <span class="hljs-keyword">this</span>.hasCartesianSeries = optionsChart.showAxes;
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    eventType;
                chart.index = charts.length;
                charts.push(chart);
                H.chartCount++;
                <span class="hljs-keyword">if</span> (chartEvents) {
                    <span class="hljs-keyword">for</span> (eventType <span class="hljs-keyword">in</span> chartEvents) {
                        addEvent(chart, eventType, chartEvents[eventType]);
                    }
                }
                chart.xAxis = [];
                chart.yAxis = [];
                chart.pointCount = chart.colorCounter = chart.symbolCounter = <span class="hljs-number">0</span>;
                chart.firstRender();
            },
            <span class="hljs-attr">initSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    optionsChart = chart.options.chart,
                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
                    series,
                    Constr = seriesTypes[type];
                <span class="hljs-keyword">if</span> (!Constr) {
                    H.error(<span class="hljs-number">17</span>, <span class="hljs-literal">true</span>);
                }
                series = <span class="hljs-keyword">new</span> Constr();
                series.init(<span class="hljs-keyword">this</span>, options);
                <span class="hljs-keyword">return</span> series;
            },
            <span class="hljs-attr">orderSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fromIndex</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.series,
                    i = fromIndex || <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span> (; i &lt; series.length; i++) {
                    <span class="hljs-keyword">if</span> (series[i]) {
                        series[i].index = i;
                        series[i].name = series[i].name ||
                            <span class="hljs-string">'Series '</span> + (series[i].index + <span class="hljs-number">1</span>);
                    }
                }
            },
            <span class="hljs-attr">isInsidePlot</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">plotX, plotY, inverted</span>) </span>{
                <span class="hljs-keyword">var</span> x = inverted ? plotY : plotX,
                    y = inverted ? plotX : plotY;
                <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> &amp;&amp;
                    x &lt;= <span class="hljs-keyword">this</span>.plotWidth &amp;&amp;
                    y &gt;= <span class="hljs-number">0</span> &amp;&amp;
                    y &lt;= <span class="hljs-keyword">this</span>.plotHeight;
            },
            <span class="hljs-attr">redraw</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">animation</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    axes = chart.axes,
                    series = chart.series,
                    pointer = chart.pointer,
                    legend = chart.legend,
                    redrawLegend = chart.isDirtyLegend,
                    hasStackedSeries,
                    hasDirtyStacks,
                    hasCartesianSeries = chart.hasCartesianSeries,
                    isDirtyBox = chart.isDirtyBox,
                    seriesLength = series.length,
                    i = seriesLength,
                    serie,
                    renderer = chart.renderer,
                    isHiddenChart = renderer.isHidden(),
                    afterRedraw = [];
                <span class="hljs-keyword">if</span> (chart.setResponsive) {
                    chart.setResponsive(<span class="hljs-literal">false</span>);
                }
                H.setAnimation(animation, chart);
                <span class="hljs-keyword">if</span> (isHiddenChart) {
                    chart.cloneRenderTo();
                }
                chart.layOutTitles();
                <span class="hljs-keyword">while</span> (i--) {
                    serie = series[i];
                    <span class="hljs-keyword">if</span> (serie.options.stacking) {
                        hasStackedSeries = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (serie.isDirty) {
                            hasDirtyStacks = <span class="hljs-literal">true</span>;
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (hasDirtyStacks) {
                    i = seriesLength;
                    <span class="hljs-keyword">while</span> (i--) {
                        serie = series[i];
                        <span class="hljs-keyword">if</span> (serie.options.stacking) {
                            serie.isDirty = <span class="hljs-literal">true</span>;
                        }
                    }
                }
                each(series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    <span class="hljs-keyword">if</span> (serie.isDirty) {
                        <span class="hljs-keyword">if</span> (serie.options.legendType === <span class="hljs-string">'point'</span>) {
                            <span class="hljs-keyword">if</span> (serie.updateTotals) {
                                serie.updateTotals();
                            }
                            redrawLegend = <span class="hljs-literal">true</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (serie.isDirtyData) {
                        fireEvent(serie, <span class="hljs-string">'updatedData'</span>);
                    }
                });
                <span class="hljs-keyword">if</span> (redrawLegend &amp;&amp; legend.options.enabled) {
                    legend.render();
                    chart.isDirtyLegend = <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (hasStackedSeries) {
                    chart.getStacks();
                }
                <span class="hljs-keyword">if</span> (hasCartesianSeries) {
                    each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        axis.updateNames();
                        axis.setScale();
                    });
                }
                chart.getMargins();
                <span class="hljs-keyword">if</span> (hasCartesianSeries) {
                    each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> (axis.isDirty) {
                            isDirtyBox = <span class="hljs-literal">true</span>;
                        }
                    });
                    each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">var</span> key = axis.min + <span class="hljs-string">','</span> + axis.max;
                        <span class="hljs-keyword">if</span> (axis.extKey !== key) {
                            axis.extKey = key;
                            afterRedraw.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                fireEvent(axis, <span class="hljs-string">'afterSetExtremes'</span>, extend(axis.eventArgs, axis.getExtremes()));
                                <span class="hljs-keyword">delete</span> axis.eventArgs;
                            });
                        }
                        <span class="hljs-keyword">if</span> (isDirtyBox || hasStackedSeries) {
                            axis.redraw();
                        }
                    });
                }
                <span class="hljs-keyword">if</span> (isDirtyBox) {
                    chart.drawChartBox();
                }
                fireEvent(chart, <span class="hljs-string">'predraw'</span>);
                each(series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    <span class="hljs-keyword">if</span> ((isDirtyBox || serie.isDirty) &amp;&amp; serie.visible) {
                        serie.redraw();
                    }
                    serie.isDirtyData = <span class="hljs-literal">false</span>;
                });
                <span class="hljs-keyword">if</span> (pointer) {
                    pointer.reset(<span class="hljs-literal">true</span>);
                }
                renderer.draw();
                fireEvent(chart, <span class="hljs-string">'redraw'</span>);
                fireEvent(chart, <span class="hljs-string">'render'</span>);
                <span class="hljs-keyword">if</span> (isHiddenChart) {
                    chart.cloneRenderTo(<span class="hljs-literal">true</span>);
                }
                each(afterRedraw, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>) </span>{
                    callback.call();
                });
            },
            <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>{
                <span class="hljs-keyword">var</span> ret,
                    series = <span class="hljs-keyword">this</span>.series,
                    i;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">itemById</span>(<span class="hljs-params">item</span>) </span>{
                    <span class="hljs-keyword">return</span> item.id === id || (item.options &amp;&amp; item.options.id === id);
                }
                ret =
                    find(<span class="hljs-keyword">this</span>.axes, itemById) ||
                    find(<span class="hljs-keyword">this</span>.series, itemById);
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; !ret &amp;&amp; i &lt; series.length; i++) {
                    ret = find(series[i].points || [], itemById);
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">getAxes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    options = <span class="hljs-keyword">this</span>.options,
                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),
                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),
                    optionsArray;
                each(xAxisOptions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, i</span>) </span>{
                    axis.index = i;
                    axis.isX = <span class="hljs-literal">true</span>;
                });
                each(yAxisOptions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, i</span>) </span>{
                    axis.index = i;
                });
                optionsArray = xAxisOptions.concat(yAxisOptions);
                each(optionsArray, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axisOptions</span>) </span>{
                    <span class="hljs-keyword">new</span> Axis(chart, axisOptions);
                });
            },
            <span class="hljs-attr">getSelectedPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> points = [];
                each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    points = points.concat(grep(serie.points || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                        <span class="hljs-keyword">return</span> point.selected;
                    }));
                });
                <span class="hljs-keyword">return</span> points;
            },
            <span class="hljs-attr">getSelectedSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> grep(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    <span class="hljs-keyword">return</span> serie.selected;
                });
            },
            <span class="hljs-attr">setTitle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">titleOptions, subtitleOptions, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    options = chart.options,
                    chartTitleOptions,
                    chartSubtitleOptions;
                chartTitleOptions = options.title = merge({
                        <span class="hljs-attr">style</span>: {
                            <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>,
                            <span class="hljs-attr">fontSize</span>: options.isStock ? <span class="hljs-string">'16px'</span> : <span class="hljs-string">'18px'</span>
                        }
                    },
                    options.title,
                    titleOptions
                );
                chartSubtitleOptions = options.subtitle = merge({
                        <span class="hljs-attr">style</span>: {
                            <span class="hljs-attr">color</span>: <span class="hljs-string">'#666666'</span>
                        }
                    },
                    options.subtitle,
                    subtitleOptions
                );
                each([
                    [<span class="hljs-string">'title'</span>, titleOptions, chartTitleOptions],
                    [<span class="hljs-string">'subtitle'</span>, subtitleOptions, chartSubtitleOptions]
                ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr, i</span>) </span>{
                    <span class="hljs-keyword">var</span> name = arr[<span class="hljs-number">0</span>],
                        title = chart[name],
                        titleOptions = arr[<span class="hljs-number">1</span>],
                        chartTitleOptions = arr[<span class="hljs-number">2</span>];
                    <span class="hljs-keyword">if</span> (title &amp;&amp; titleOptions) {
                        chart[name] = title = title.destroy();
                    }
                    <span class="hljs-keyword">if</span> (chartTitleOptions &amp;&amp; chartTitleOptions.text &amp;&amp; !title) {
                        chart[name] = chart.renderer.text(
                                chartTitleOptions.text,
                                <span class="hljs-number">0</span>,
                                <span class="hljs-number">0</span>,
                                chartTitleOptions.useHTML
                            )
                            .attr({
                                <span class="hljs-attr">align</span>: chartTitleOptions.align,
                                <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-'</span> + name,
                                <span class="hljs-attr">zIndex</span>: chartTitleOptions.zIndex || <span class="hljs-number">4</span>
                            })
                            .add();
                        chart[name].update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>) </span>{
                            chart.setTitle(!i &amp;&amp; o, i &amp;&amp; o);
                        };
                        chart[name].css(chartTitleOptions.style);
                    }
                });
                chart.layOutTitles(redraw);
            },
            <span class="hljs-attr">layOutTitles</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">redraw</span>) </span>{
                <span class="hljs-keyword">var</span> titleOffset = <span class="hljs-number">0</span>,
                    requiresDirtyBox,
                    renderer = <span class="hljs-keyword">this</span>.renderer,
                    spacingBox = <span class="hljs-keyword">this</span>.spacingBox;
                each([<span class="hljs-string">'title'</span>, <span class="hljs-string">'subtitle'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    <span class="hljs-keyword">var</span> title = <span class="hljs-keyword">this</span>[key],
                        titleOptions = <span class="hljs-keyword">this</span>.options[key],
                        titleSize;
                    <span class="hljs-keyword">if</span> (title) {
                        titleSize = titleOptions.style.fontSize;
                        titleSize = renderer.fontMetrics(titleSize, title).b;
                        title
                            .css({
                                <span class="hljs-attr">width</span>: (titleOptions.width || spacingBox.width + titleOptions.widthAdjust) + <span class="hljs-string">'px'</span>
                            })
                            .align(extend({
                                <span class="hljs-attr">y</span>: titleOffset + titleSize + (key === <span class="hljs-string">'title'</span> ? <span class="hljs-number">-3</span> : <span class="hljs-number">2</span>)
                            }, titleOptions), <span class="hljs-literal">false</span>, <span class="hljs-string">'spacingBox'</span>);
                        <span class="hljs-keyword">if</span> (!titleOptions.floating &amp;&amp; !titleOptions.verticalAlign) {
                            titleOffset = <span class="hljs-built_in">Math</span>.ceil(titleOffset + title.getBBox().height);
                        }
                    }
                }, <span class="hljs-keyword">this</span>);
                requiresDirtyBox = <span class="hljs-keyword">this</span>.titleOffset !== titleOffset;
                <span class="hljs-keyword">this</span>.titleOffset = titleOffset;
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDirtyBox &amp;&amp; requiresDirtyBox) {
                    <span class="hljs-keyword">this</span>.isDirtyBox = requiresDirtyBox;
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasRendered &amp;&amp; pick(redraw, <span class="hljs-literal">true</span>) &amp;&amp; <span class="hljs-keyword">this</span>.isDirtyBox) {
                        <span class="hljs-keyword">this</span>.redraw();
                    }
                }
            },
            <span class="hljs-attr">getChartSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    optionsChart = chart.options.chart,
                    widthOption = optionsChart.width,
                    heightOption = optionsChart.height,
                    renderTo = chart.renderToClone || chart.renderTo;
                <span class="hljs-keyword">if</span> (!defined(widthOption)) {
                    chart.containerWidth = getStyle(renderTo, <span class="hljs-string">'width'</span>);
                }
                <span class="hljs-keyword">if</span> (!defined(heightOption)) {
                    chart.containerHeight = getStyle(renderTo, <span class="hljs-string">'height'</span>);
                }
                chart.chartWidth = <span class="hljs-built_in">Math</span>.max(
                    <span class="hljs-number">0</span>,
                    widthOption || chart.containerWidth || <span class="hljs-number">600</span>
                );
                chart.chartHeight = <span class="hljs-built_in">Math</span>.max(
                    <span class="hljs-number">0</span>,
                    heightOption || chart.containerHeight || <span class="hljs-number">400</span>
                );
            },
            <span class="hljs-attr">cloneRenderTo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">revert</span>) </span>{
                <span class="hljs-keyword">var</span> clone = <span class="hljs-keyword">this</span>.renderToClone,
                    container = <span class="hljs-keyword">this</span>.container;
                <span class="hljs-keyword">if</span> (revert) {
                    <span class="hljs-keyword">if</span> (clone) {
                        <span class="hljs-keyword">while</span> (clone.childNodes.length) {
                            <span class="hljs-keyword">this</span>.renderTo.appendChild(clone.firstChild);
                        }
                        discardElement(clone);
                        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.renderToClone;
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (container &amp;&amp; container.parentNode === <span class="hljs-keyword">this</span>.renderTo) {
                        <span class="hljs-keyword">this</span>.renderTo.removeChild(container);
                    }
                    <span class="hljs-keyword">this</span>.renderToClone = clone = <span class="hljs-keyword">this</span>.renderTo.cloneNode(<span class="hljs-number">0</span>);
                    css(clone, {
                        <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                        <span class="hljs-attr">top</span>: <span class="hljs-string">'-9999px'</span>,
                        <span class="hljs-attr">display</span>: <span class="hljs-string">'block'</span>
                    });
                    <span class="hljs-keyword">if</span> (clone.style.setProperty) {
                        clone.style.setProperty(<span class="hljs-string">'display'</span>, <span class="hljs-string">'block'</span>, <span class="hljs-string">'important'</span>);
                    }
                    doc.body.appendChild(clone);
                    <span class="hljs-keyword">if</span> (container) {
                        clone.appendChild(container);
                    }
                }
            },
            <span class="hljs-attr">setClassName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">className</span>) </span>{
                <span class="hljs-keyword">this</span>.container.className = <span class="hljs-string">'highcharts-container '</span> + (className || <span class="hljs-string">''</span>);
            },
            <span class="hljs-attr">getContainer</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    container,
                    options = chart.options,
                    optionsChart = options.chart,
                    chartWidth,
                    chartHeight,
                    renderTo = chart.renderTo,
                    indexAttrName = <span class="hljs-string">'data-highcharts-chart'</span>,
                    oldChartIndex,
                    Ren,
                    containerId = H.uniqueKey(),
                    containerStyle,
                    key;
                <span class="hljs-keyword">if</span> (!renderTo) {
                    chart.renderTo = renderTo = optionsChart.renderTo;
                }
                <span class="hljs-keyword">if</span> (isString(renderTo)) {
                    chart.renderTo = renderTo = doc.getElementById(renderTo);
                }
                <span class="hljs-keyword">if</span> (!renderTo) {
                    H.error(<span class="hljs-number">13</span>, <span class="hljs-literal">true</span>);
                }
                oldChartIndex = pInt(attr(renderTo, indexAttrName));
                <span class="hljs-keyword">if</span> (isNumber(oldChartIndex) &amp;&amp; charts[oldChartIndex] &amp;&amp; charts[oldChartIndex].hasRendered) {
                    charts[oldChartIndex].destroy();
                }
                attr(renderTo, indexAttrName, chart.index);
                renderTo.innerHTML = <span class="hljs-string">''</span>;
                <span class="hljs-keyword">if</span> (!optionsChart.skipClone &amp;&amp; !renderTo.offsetWidth) {
                    chart.cloneRenderTo();
                }
                chart.getChartSize();
                chartWidth = chart.chartWidth;
                chartHeight = chart.chartHeight;
                containerStyle = extend({
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'relative'</span>,
                    <span class="hljs-attr">overflow</span>: <span class="hljs-string">'hidden'</span>,
                    <span class="hljs-attr">width</span>: chartWidth + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">height</span>: chartHeight + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'left'</span>,
                    <span class="hljs-attr">lineHeight</span>: <span class="hljs-string">'normal'</span>,
                    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-string">'-webkit-tap-highlight-color'</span>: <span class="hljs-string">'rgba(0,0,0,0)'</span>
                }, optionsChart.style);
                chart.container = container = createElement(
                    <span class="hljs-string">'div'</span>, {
                        <span class="hljs-attr">id</span>: containerId
                    },
                    containerStyle,
                    chart.renderToClone || renderTo
                );
                chart._cursor = container.style.cursor;
                Ren = H[optionsChart.renderer] || Renderer;
                chart.renderer = <span class="hljs-keyword">new</span> Ren(
                    container,
                    chartWidth,
                    chartHeight,
                    <span class="hljs-literal">null</span>,
                    optionsChart.forExport,
                    options.exporting &amp;&amp; options.exporting.allowHTML
                );
                chart.setClassName(optionsChart.className);
                chart.renderer.setStyle(optionsChart.style);
                chart.renderer.chartIndex = chart.index;
            },
            <span class="hljs-attr">getMargins</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">skipAxes</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    spacing = chart.spacing,
                    margin = chart.margin,
                    titleOffset = chart.titleOffset;
                chart.resetMargins();
                <span class="hljs-keyword">if</span> (titleOffset &amp;&amp; !defined(margin[<span class="hljs-number">0</span>])) {
                    chart.plotTop = <span class="hljs-built_in">Math</span>.max(chart.plotTop, titleOffset + chart.options.title.margin + spacing[<span class="hljs-number">0</span>]);
                }
                <span class="hljs-keyword">if</span> (chart.legend &amp;&amp; chart.legend.display) {
                    chart.legend.adjustMargins(margin, spacing);
                }
                <span class="hljs-keyword">if</span> (chart.extraMargin) {
                    chart[chart.extraMargin.type] = (chart[chart.extraMargin.type] || <span class="hljs-number">0</span>) + chart.extraMargin.value;
                }
                <span class="hljs-keyword">if</span> (chart.extraTopMargin) {
                    chart.plotTop += chart.extraTopMargin;
                }
                <span class="hljs-keyword">if</span> (!skipAxes) {
                    <span class="hljs-keyword">this</span>.getAxisMargins();
                }
            },
            <span class="hljs-attr">getAxisMargins</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    axisOffset = chart.axisOffset = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],
                    margin = chart.margin;
                <span class="hljs-keyword">if</span> (chart.hasCartesianSeries) {
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> (axis.visible) {
                            axis.getOffset();
                        }
                    });
                }
                each(marginNames, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, side</span>) </span>{
                    <span class="hljs-keyword">if</span> (!defined(margin[side])) {
                        chart[m] += axisOffset[side];
                    }
                });
                chart.setChartSize();
            },
            <span class="hljs-attr">reflow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    optionsChart = chart.options.chart,
                    renderTo = chart.renderTo,
                    hasUserWidth = defined(optionsChart.width),
                    width = optionsChart.width || getStyle(renderTo, <span class="hljs-string">'width'</span>),
                    height = optionsChart.height || getStyle(renderTo, <span class="hljs-string">'height'</span>),
                    target = e ? e.target : win;
                <span class="hljs-keyword">if</span> (!hasUserWidth &amp;&amp; !chart.isPrinting &amp;&amp; width &amp;&amp; height &amp;&amp; (target === win || target === doc)) {
                    <span class="hljs-keyword">if</span> (width !== chart.containerWidth || height !== chart.containerHeight) {
                        clearTimeout(chart.reflowTimeout);
                        chart.reflowTimeout = syncTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (chart.container) {
                                chart.setSize(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">false</span>);
                            }
                        }, e ? <span class="hljs-number">100</span> : <span class="hljs-number">0</span>);
                    }
                    chart.containerWidth = width;
                    chart.containerHeight = height;
                }
            },
            <span class="hljs-attr">initReflow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    unbind;
                unbind = addEvent(win, <span class="hljs-string">'resize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    chart.reflow(e);
                });
                addEvent(chart, <span class="hljs-string">'destroy'</span>, unbind);
            },
            <span class="hljs-attr">setSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height, animation</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    renderer = chart.renderer,
                    globalAnimation;
                chart.isResizing += <span class="hljs-number">1</span>;
                H.setAnimation(animation, chart);
                chart.oldChartHeight = chart.chartHeight;
                chart.oldChartWidth = chart.chartWidth;
                <span class="hljs-keyword">if</span> (width !== <span class="hljs-literal">undefined</span>) {
                    chart.options.chart.width = width;
                }
                <span class="hljs-keyword">if</span> (height !== <span class="hljs-literal">undefined</span>) {
                    chart.options.chart.height = height;
                }
                chart.getChartSize();
                globalAnimation = renderer.globalAnimation;
                (globalAnimation ? animate : css)(chart.container, {
                    <span class="hljs-attr">width</span>: chart.chartWidth + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">height</span>: chart.chartHeight + <span class="hljs-string">'px'</span>
                }, globalAnimation);
                chart.setChartSize(<span class="hljs-literal">true</span>);
                renderer.setSize(chart.chartWidth, chart.chartHeight, animation);
                each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                    axis.isDirty = <span class="hljs-literal">true</span>;
                    axis.setScale();
                });
                chart.isDirtyLegend = <span class="hljs-literal">true</span>;
                chart.isDirtyBox = <span class="hljs-literal">true</span>;
                chart.layOutTitles();
                chart.getMargins();
                chart.redraw(animation);
                chart.oldChartHeight = <span class="hljs-literal">null</span>;
                fireEvent(chart, <span class="hljs-string">'resize'</span>);
                syncTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">if</span> (chart) {
                        fireEvent(chart, <span class="hljs-string">'endResize'</span>, <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            chart.isResizing -= <span class="hljs-number">1</span>;
                        });
                    }
                }, animObject(globalAnimation).duration);
            },
            <span class="hljs-attr">setChartSize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">skipAxes</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    inverted = chart.inverted,
                    renderer = chart.renderer,
                    chartWidth = chart.chartWidth,
                    chartHeight = chart.chartHeight,
                    optionsChart = chart.options.chart,
                    spacing = chart.spacing,
                    clipOffset = chart.clipOffset,
                    clipX,
                    clipY,
                    plotLeft,
                    plotTop,
                    plotWidth,
                    plotHeight,
                    plotBorderWidth;
                chart.plotLeft = plotLeft = <span class="hljs-built_in">Math</span>.round(chart.plotLeft);
                chart.plotTop = plotTop = <span class="hljs-built_in">Math</span>.round(chart.plotTop);
                chart.plotWidth = plotWidth = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.round(chartWidth - plotLeft - chart.marginRight));
                chart.plotHeight = plotHeight = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.round(chartHeight - plotTop - chart.marginBottom));
                chart.plotSizeX = inverted ? plotHeight : plotWidth;
                chart.plotSizeY = inverted ? plotWidth : plotHeight;
                chart.plotBorderWidth = optionsChart.plotBorderWidth || <span class="hljs-number">0</span>;
                chart.spacingBox = renderer.spacingBox = {
                    <span class="hljs-attr">x</span>: spacing[<span class="hljs-number">3</span>],
                    <span class="hljs-attr">y</span>: spacing[<span class="hljs-number">0</span>],
                    <span class="hljs-attr">width</span>: chartWidth - spacing[<span class="hljs-number">3</span>] - spacing[<span class="hljs-number">1</span>],
                    <span class="hljs-attr">height</span>: chartHeight - spacing[<span class="hljs-number">0</span>] - spacing[<span class="hljs-number">2</span>]
                };
                chart.plotBox = renderer.plotBox = {
                    <span class="hljs-attr">x</span>: plotLeft,
                    <span class="hljs-attr">y</span>: plotTop,
                    <span class="hljs-attr">width</span>: plotWidth,
                    <span class="hljs-attr">height</span>: plotHeight
                };
                plotBorderWidth = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.floor(chart.plotBorderWidth / <span class="hljs-number">2</span>);
                clipX = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.max(plotBorderWidth, clipOffset[<span class="hljs-number">3</span>]) / <span class="hljs-number">2</span>);
                clipY = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.max(plotBorderWidth, clipOffset[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>);
                chart.clipBox = {
                    <span class="hljs-attr">x</span>: clipX,
                    <span class="hljs-attr">y</span>: clipY,
                    <span class="hljs-attr">width</span>: <span class="hljs-built_in">Math</span>.floor(chart.plotSizeX - <span class="hljs-built_in">Math</span>.max(plotBorderWidth, clipOffset[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span> - clipX),
                    <span class="hljs-attr">height</span>: <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.floor(chart.plotSizeY - <span class="hljs-built_in">Math</span>.max(plotBorderWidth, clipOffset[<span class="hljs-number">2</span>]) / <span class="hljs-number">2</span> - clipY))
                };
                <span class="hljs-keyword">if</span> (!skipAxes) {
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        axis.setAxisSize();
                        axis.setAxisTranslation();
                    });
                }
            },
            <span class="hljs-attr">resetMargins</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    chartOptions = chart.options.chart;
                each([<span class="hljs-string">'margin'</span>, <span class="hljs-string">'spacing'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">splashArrays</span>(<span class="hljs-params">target</span>) </span>{
                    <span class="hljs-keyword">var</span> value = chartOptions[target],
                        values = isObject(value) ? value : [value, value, value, value];
                    each([<span class="hljs-string">'Top'</span>, <span class="hljs-string">'Right'</span>, <span class="hljs-string">'Bottom'</span>, <span class="hljs-string">'Left'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sideName, side</span>) </span>{
                        chart[target][side] = pick(chartOptions[target + sideName], values[side]);
                    });
                });
                each(marginNames, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, side</span>) </span>{
                    chart[m] = pick(chart.margin[side], chart.spacing[side]);
                });
                chart.axisOffset = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
                chart.clipOffset = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
            },
            <span class="hljs-attr">drawChartBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    optionsChart = chart.options.chart,
                    renderer = chart.renderer,
                    chartWidth = chart.chartWidth,
                    chartHeight = chart.chartHeight,
                    chartBackground = chart.chartBackground,
                    plotBackground = chart.plotBackground,
                    plotBorder = chart.plotBorder,
                    chartBorderWidth,
                    plotBGImage = chart.plotBGImage,
                    chartBackgroundColor = optionsChart.backgroundColor,
                    plotBackgroundColor = optionsChart.plotBackgroundColor,
                    plotBackgroundImage = optionsChart.plotBackgroundImage,
                    mgn,
                    bgAttr,
                    plotLeft = chart.plotLeft,
                    plotTop = chart.plotTop,
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    plotBox = chart.plotBox,
                    clipRect = chart.clipRect,
                    clipBox = chart.clipBox,
                    verb = <span class="hljs-string">'animate'</span>;
                <span class="hljs-keyword">if</span> (!chartBackground) {
                    chart.chartBackground = chartBackground = renderer.rect()
                        .addClass(<span class="hljs-string">'highcharts-background'</span>)
                        .add();
                    verb = <span class="hljs-string">'attr'</span>;
                }
                chartBorderWidth = optionsChart.borderWidth || <span class="hljs-number">0</span>;
                mgn = chartBorderWidth + (optionsChart.shadow ? <span class="hljs-number">8</span> : <span class="hljs-number">0</span>);
                bgAttr = {
                    <span class="hljs-attr">fill</span>: chartBackgroundColor || <span class="hljs-string">'none'</span>
                };
                <span class="hljs-keyword">if</span> (chartBorderWidth || chartBackground[<span class="hljs-string">'stroke-width'</span>]) {
                    bgAttr.stroke = optionsChart.borderColor;
                    bgAttr[<span class="hljs-string">'stroke-width'</span>] = chartBorderWidth;
                }
                chartBackground
                    .attr(bgAttr)
                    .shadow(optionsChart.shadow);
                chartBackground[verb]({
                    <span class="hljs-attr">x</span>: mgn / <span class="hljs-number">2</span>,
                    <span class="hljs-attr">y</span>: mgn / <span class="hljs-number">2</span>,
                    <span class="hljs-attr">width</span>: chartWidth - mgn - chartBorderWidth % <span class="hljs-number">2</span>,
                    <span class="hljs-attr">height</span>: chartHeight - mgn - chartBorderWidth % <span class="hljs-number">2</span>,
                    <span class="hljs-attr">r</span>: optionsChart.borderRadius
                });
                verb = <span class="hljs-string">'animate'</span>;
                <span class="hljs-keyword">if</span> (!plotBackground) {
                    verb = <span class="hljs-string">'attr'</span>;
                    chart.plotBackground = plotBackground = renderer.rect()
                        .addClass(<span class="hljs-string">'highcharts-plot-background'</span>)
                        .add();
                }
                plotBackground[verb](plotBox);
                plotBackground
                    .attr({
                        <span class="hljs-attr">fill</span>: plotBackgroundColor || <span class="hljs-string">'none'</span>
                    })
                    .shadow(optionsChart.plotShadow);
                <span class="hljs-keyword">if</span> (plotBackgroundImage) {
                    <span class="hljs-keyword">if</span> (!plotBGImage) {
                        chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
                            .add();
                    } <span class="hljs-keyword">else</span> {
                        plotBGImage.animate(plotBox);
                    }
                }
                <span class="hljs-keyword">if</span> (!clipRect) {
                    chart.clipRect = renderer.clipRect(clipBox);
                } <span class="hljs-keyword">else</span> {
                    clipRect.animate({
                        <span class="hljs-attr">width</span>: clipBox.width,
                        <span class="hljs-attr">height</span>: clipBox.height
                    });
                }
                verb = <span class="hljs-string">'animate'</span>;
                <span class="hljs-keyword">if</span> (!plotBorder) {
                    verb = <span class="hljs-string">'attr'</span>;
                    chart.plotBorder = plotBorder = renderer.rect()
                        .addClass(<span class="hljs-string">'highcharts-plot-border'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        })
                        .add();
                }
                plotBorder.attr({
                    <span class="hljs-attr">stroke</span>: optionsChart.plotBorderColor,
                    <span class="hljs-string">'stroke-width'</span>: optionsChart.plotBorderWidth || <span class="hljs-number">0</span>,
                    <span class="hljs-attr">fill</span>: <span class="hljs-string">'none'</span>
                });
                plotBorder[verb](plotBorder.crisp({
                    <span class="hljs-attr">x</span>: plotLeft,
                    <span class="hljs-attr">y</span>: plotTop,
                    <span class="hljs-attr">width</span>: plotWidth,
                    <span class="hljs-attr">height</span>: plotHeight
                }, -plotBorder.strokeWidth()));
                chart.isDirtyBox = <span class="hljs-literal">false</span>;
            },
            <span class="hljs-attr">propFromSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    optionsChart = chart.options.chart,
                    klass,
                    seriesOptions = chart.options.series,
                    i,
                    value;
                each([<span class="hljs-string">'inverted'</span>, <span class="hljs-string">'angular'</span>, <span class="hljs-string">'polar'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
                    value =
                        optionsChart[key] ||
                        (klass &amp;&amp; klass.prototype[key]);
                    i = seriesOptions &amp;&amp; seriesOptions.length;
                    <span class="hljs-keyword">while</span> (!value &amp;&amp; i--) {
                        klass = seriesTypes[seriesOptions[i].type];
                        <span class="hljs-keyword">if</span> (klass &amp;&amp; klass.prototype[key]) {
                            value = <span class="hljs-literal">true</span>;
                        }
                    }
                    chart[key] = value;
                });
            },
            <span class="hljs-attr">linkSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    chartSeries = chart.series;
                each(chartSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    series.linkedSeries.length = <span class="hljs-number">0</span>;
                });
                each(chartSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">var</span> linkedTo = series.options.linkedTo;
                    <span class="hljs-keyword">if</span> (isString(linkedTo)) {
                        <span class="hljs-keyword">if</span> (linkedTo === <span class="hljs-string">':previous'</span>) {
                            linkedTo = chart.series[series.index - <span class="hljs-number">1</span>];
                        } <span class="hljs-keyword">else</span> {
                            linkedTo = chart.get(linkedTo);
                        }
                        <span class="hljs-keyword">if</span> (linkedTo &amp;&amp; linkedTo.linkedParent !== series) {
                            linkedTo.linkedSeries.push(series);
                            series.linkedParent = linkedTo;
                            series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible);
                        }
                    }
                });
            },
            <span class="hljs-attr">renderSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serie</span>) </span>{
                    serie.translate();
                    serie.render();
                });
            },
            <span class="hljs-attr">renderLabels</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    labels = chart.options.labels;
                <span class="hljs-keyword">if</span> (labels.items) {
                    each(labels.items, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">label</span>) </span>{
                        <span class="hljs-keyword">var</span> style = extend(labels.style, label.style),
                            x = pInt(style.left) + chart.plotLeft,
                            y = pInt(style.top) + chart.plotTop + <span class="hljs-number">12</span>;
                        <span class="hljs-keyword">delete</span> style.left;
                        <span class="hljs-keyword">delete</span> style.top;
                        chart.renderer.text(
                                label.html,
                                x,
                                y
                            )
                            .attr({
                                <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>
                            })
                            .css(style)
                            .add();
                    });
                }
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    axes = chart.axes,
                    renderer = chart.renderer,
                    options = chart.options,
                    tempWidth,
                    tempHeight,
                    redoHorizontal,
                    redoVertical;
                chart.setTitle();
                chart.legend = <span class="hljs-keyword">new</span> Legend(chart, options.legend);
                <span class="hljs-keyword">if</span> (chart.getStacks) {
                    chart.getStacks();
                }
                chart.getMargins(<span class="hljs-literal">true</span>);
                chart.setChartSize();
                tempWidth = chart.plotWidth;
                tempHeight = chart.plotHeight = chart.plotHeight - <span class="hljs-number">21</span>;
                each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                    axis.setScale();
                });
                chart.getAxisMargins();
                redoHorizontal = tempWidth / chart.plotWidth &gt; <span class="hljs-number">1.1</span>;
                redoVertical = tempHeight / chart.plotHeight &gt; <span class="hljs-number">1.05</span>;
                <span class="hljs-keyword">if</span> (redoHorizontal || redoVertical) {
                    each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> ((axis.horiz &amp;&amp; redoHorizontal) || (!axis.horiz &amp;&amp; redoVertical)) {
                            axis.setTickInterval(<span class="hljs-literal">true</span>);
                        }
                    });
                    chart.getMargins();
                }
                chart.drawChartBox();
                <span class="hljs-keyword">if</span> (chart.hasCartesianSeries) {
                    each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        <span class="hljs-keyword">if</span> (axis.visible) {
                            axis.render();
                        }
                    });
                }
                <span class="hljs-keyword">if</span> (!chart.seriesGroup) {
                    chart.seriesGroup = renderer.g(<span class="hljs-string">'series-group'</span>)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3</span>
                        })
                        .add();
                }
                chart.renderSeries();
                chart.renderLabels();
                chart.addCredits();
                <span class="hljs-keyword">if</span> (chart.setResponsive) {
                    chart.setResponsive();
                }
                chart.hasRendered = <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">addCredits</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">credits</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>;
                credits = merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options.credits, credits);
                <span class="hljs-keyword">if</span> (credits.enabled &amp;&amp; !<span class="hljs-keyword">this</span>.credits) {
                    <span class="hljs-keyword">this</span>.credits = <span class="hljs-keyword">this</span>.renderer.text(
                            credits.text + (<span class="hljs-keyword">this</span>.mapCredits || <span class="hljs-string">''</span>),
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>
                        )
                        .addClass(<span class="hljs-string">'highcharts-credits'</span>)
                        .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (credits.href) {
                                win.location.href = credits.href;
                            }
                        })
                        .attr({
                            <span class="hljs-attr">align</span>: credits.position.align,
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">8</span>
                        })
                        .css(credits.style)
                        .add()
                        .align(credits.position);
                    <span class="hljs-keyword">this</span>.credits.update = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                        chart.credits = chart.credits.destroy();
                        chart.addCredits(options);
                    };
                }
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    axes = chart.axes,
                    series = chart.series,
                    container = chart.container,
                    i,
                    parentNode = container &amp;&amp; container.parentNode;
                fireEvent(chart, <span class="hljs-string">'destroy'</span>);
                charts[chart.index] = <span class="hljs-literal">undefined</span>;
                H.chartCount--;
                chart.renderTo.removeAttribute(<span class="hljs-string">'data-highcharts-chart'</span>);
                removeEvent(chart);
                i = axes.length;
                <span class="hljs-keyword">while</span> (i--) {
                    axes[i] = axes[i].destroy();
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scroller &amp;&amp; <span class="hljs-keyword">this</span>.scroller.destroy) {
                    <span class="hljs-keyword">this</span>.scroller.destroy();
                }
                i = series.length;
                <span class="hljs-keyword">while</span> (i--) {
                    series[i] = series[i].destroy();
                }
                each([
                    <span class="hljs-string">'title'</span>, <span class="hljs-string">'subtitle'</span>, <span class="hljs-string">'chartBackground'</span>, <span class="hljs-string">'plotBackground'</span>,
                    <span class="hljs-string">'plotBGImage'</span>, <span class="hljs-string">'plotBorder'</span>, <span class="hljs-string">'seriesGroup'</span>, <span class="hljs-string">'clipRect'</span>, <span class="hljs-string">'credits'</span>,
                    <span class="hljs-string">'pointer'</span>, <span class="hljs-string">'rangeSelector'</span>, <span class="hljs-string">'legend'</span>, <span class="hljs-string">'resetZoomButton'</span>, <span class="hljs-string">'tooltip'</span>,
                    <span class="hljs-string">'renderer'</span>
                ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                    <span class="hljs-keyword">var</span> prop = chart[name];
                    <span class="hljs-keyword">if</span> (prop &amp;&amp; prop.destroy) {
                        chart[name] = prop.destroy();
                    }
                });
                <span class="hljs-keyword">if</span> (container) {
                    container.innerHTML = <span class="hljs-string">''</span>;
                    removeEvent(container);
                    <span class="hljs-keyword">if</span> (parentNode) {
                        discardElement(container);
                    }
                }
                <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> chart) {
                    <span class="hljs-keyword">delete</span> chart[i];
                }
            },
            <span class="hljs-attr">isReadyToRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>;
                <span class="hljs-keyword">if</span> ((!svg &amp;&amp; (win == win.top &amp;&amp; doc.readyState !== <span class="hljs-string">'complete'</span>))) {
                    doc.attachEvent(<span class="hljs-string">'onreadystatechange'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        doc.detachEvent(<span class="hljs-string">'onreadystatechange'</span>, chart.firstRender);
                        <span class="hljs-keyword">if</span> (doc.readyState === <span class="hljs-string">'complete'</span>) {
                            chart.firstRender();
                        }
                    });
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">firstRender</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    options = chart.options;
                <span class="hljs-keyword">if</span> (!chart.isReadyToRender()) {
                    <span class="hljs-keyword">return</span>;
                }
                chart.getContainer();
                fireEvent(chart, <span class="hljs-string">'init'</span>);
                chart.resetMargins();
                chart.setChartSize();
                chart.propFromSeries();
                chart.getAxes();
                each(options.series || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">serieOptions</span>) </span>{
                    chart.initSeries(serieOptions);
                });
                chart.linkSeries();
                fireEvent(chart, <span class="hljs-string">'beforeRender'</span>);
                <span class="hljs-keyword">if</span> (Pointer) {
                    chart.pointer = <span class="hljs-keyword">new</span> Pointer(chart, options);
                }
                chart.render();
                <span class="hljs-keyword">if</span> (!chart.renderer.imgCount &amp;&amp; chart.onload) {
                    chart.onload();
                }
                chart.cloneRenderTo(<span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">onload</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                each([<span class="hljs-keyword">this</span>.callback].concat(<span class="hljs-keyword">this</span>.callbacks), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>{
                    <span class="hljs-keyword">if</span> (fn &amp;&amp; <span class="hljs-keyword">this</span>.index !== <span class="hljs-literal">undefined</span>) {
                        fn.apply(<span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>]);
                    }
                }, <span class="hljs-keyword">this</span>);
                fireEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'load'</span>);
                fireEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'render'</span>);
                <span class="hljs-keyword">if</span> (defined(<span class="hljs-keyword">this</span>.index) &amp;&amp; <span class="hljs-keyword">this</span>.options.chart.reflow !== <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">this</span>.initReflow();
                }
                <span class="hljs-keyword">this</span>.onload = <span class="hljs-literal">null</span>;
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Point,
            each = H.each,
            extend = H.extend,
            erase = H.erase,
            fireEvent = H.fireEvent,
            format = H.format,
            isArray = H.isArray,
            isNumber = H.isNumber,
            pick = H.pick,
            removeEvent = H.removeEvent;
        Point = H.Point = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{};
        Point.prototype = {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series, options, x</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    colors,
                    colorCount = series.chart.options.chart.colorCount,
                    colorIndex;
                point.series = series;
                point.color = series.color;
                point.applyOptions(options, x);
                <span class="hljs-keyword">if</span> (series.options.colorByPoint) {
                    colors = series.options.colors || series.chart.options.colors;
                    point.color = point.color || colors[series.colorCounter];
                    colorCount = colors.length;
                    colorIndex = series.colorCounter;
                    series.colorCounter++;
                    <span class="hljs-keyword">if</span> (series.colorCounter === colorCount) {
                        series.colorCounter = <span class="hljs-number">0</span>;
                    }
                } <span class="hljs-keyword">else</span> {
                    colorIndex = series.colorIndex;
                }
                point.colorIndex = pick(point.colorIndex, colorIndex);
                series.chart.pointCount++;
                <span class="hljs-keyword">return</span> point;
            },
            <span class="hljs-attr">applyOptions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, x</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    pointValKey = series.options.pointValKey || series.pointValKey;
                options = Point.prototype.optionsToObject.call(<span class="hljs-keyword">this</span>, options);
                extend(point, options);
                point.options = point.options ? extend(point.options, options) : options;
                <span class="hljs-keyword">if</span> (options.group) {
                    <span class="hljs-keyword">delete</span> point.group;
                }
                <span class="hljs-keyword">if</span> (pointValKey) {
                    point.y = point[pointValKey];
                }
                point.isNull = pick(
                    point.isValid &amp;&amp; !point.isValid(),
                    point.x === <span class="hljs-literal">null</span> || !isNumber(point.y, <span class="hljs-literal">true</span>)
                );
                <span class="hljs-keyword">if</span> (point.selected) {
                    point.state = <span class="hljs-string">'select'</span>;
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> point &amp;&amp; x === <span class="hljs-literal">undefined</span> &amp;&amp; series.xAxis &amp;&amp; series.xAxis.hasNames) {
                    point.x = series.xAxis.nameToX(point);
                }
                <span class="hljs-keyword">if</span> (point.x === <span class="hljs-literal">undefined</span> &amp;&amp; series) {
                    <span class="hljs-keyword">if</span> (x === <span class="hljs-literal">undefined</span>) {
                        point.x = series.autoIncrement(point);
                    } <span class="hljs-keyword">else</span> {
                        point.x = x;
                    }
                }
                <span class="hljs-keyword">return</span> point;
            },
            <span class="hljs-attr">optionsToObject</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">var</span> ret = {},
                    series = <span class="hljs-keyword">this</span>.series,
                    keys = series.options.keys,
                    pointArrayMap = keys || series.pointArrayMap || [<span class="hljs-string">'y'</span>],
                    valueCount = pointArrayMap.length,
                    firstItemType,
                    i = <span class="hljs-number">0</span>,
                    j = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (isNumber(options) || options === <span class="hljs-literal">null</span>) {
                    ret[pointArrayMap[<span class="hljs-number">0</span>]] = options;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray(options)) {
                    <span class="hljs-keyword">if</span> (!keys &amp;&amp; options.length &gt; valueCount) {
                        firstItemType = <span class="hljs-keyword">typeof</span> options[<span class="hljs-number">0</span>];
                        <span class="hljs-keyword">if</span> (firstItemType === <span class="hljs-string">'string'</span>) {
                            ret.name = options[<span class="hljs-number">0</span>];
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstItemType === <span class="hljs-string">'number'</span>) {
                            ret.x = options[<span class="hljs-number">0</span>];
                        }
                        i++;
                    }
                    <span class="hljs-keyword">while</span> (j &lt; valueCount) {
                        <span class="hljs-keyword">if</span> (!keys || options[i] !== <span class="hljs-literal">undefined</span>) {
                            ret[pointArrayMap[j]] = options[i];
                        }
                        i++;
                        j++;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options === <span class="hljs-string">'object'</span>) {
                    ret = options;
                    <span class="hljs-keyword">if</span> (options.dataLabels) {
                        series._hasPointLabels = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">if</span> (options.marker) {
                        series._hasPointMarkers = <span class="hljs-literal">true</span>;
                    }
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">getClassName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-string">'highcharts-point'</span> +
                    (<span class="hljs-keyword">this</span>.selected ? <span class="hljs-string">' highcharts-point-select'</span> : <span class="hljs-string">''</span>) +
                    (<span class="hljs-keyword">this</span>.negative ? <span class="hljs-string">' highcharts-negative'</span> : <span class="hljs-string">''</span>) +
                    (<span class="hljs-keyword">this</span>.isNull ? <span class="hljs-string">' highcharts-null-point'</span> : <span class="hljs-string">''</span>) +
                    (<span class="hljs-keyword">this</span>.colorIndex !== <span class="hljs-literal">undefined</span> ? <span class="hljs-string">' highcharts-color-'</span> +
                        <span class="hljs-keyword">this</span>.colorIndex : <span class="hljs-string">''</span>) +
                    (<span class="hljs-keyword">this</span>.options.className ? <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.options.className : <span class="hljs-string">''</span>) +
                    (<span class="hljs-keyword">this</span>.zone &amp;&amp; <span class="hljs-keyword">this</span>.zone.className ? <span class="hljs-string">' '</span> +
                        <span class="hljs-keyword">this</span>.zone.className.replace(<span class="hljs-string">'highcharts-negative'</span>, <span class="hljs-string">''</span>) : <span class="hljs-string">''</span>);
            },
            <span class="hljs-attr">getZone</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.series,
                    zones = series.zones,
                    zoneAxis = series.zoneAxis || <span class="hljs-string">'y'</span>,
                    i = <span class="hljs-number">0</span>,
                    zone;
                zone = zones[i];
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>[zoneAxis] &gt;= zone.value) {
                    zone = zones[++i];
                }
                <span class="hljs-keyword">if</span> (zone &amp;&amp; zone.color &amp;&amp; !<span class="hljs-keyword">this</span>.options.color) {
                    <span class="hljs-keyword">this</span>.color = zone.color;
                }
                <span class="hljs-keyword">return</span> zone;
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    chart = series.chart,
                    hoverPoints = chart.hoverPoints,
                    prop;
                chart.pointCount--;
                <span class="hljs-keyword">if</span> (hoverPoints) {
                    point.setState();
                    erase(hoverPoints, point);
                    <span class="hljs-keyword">if</span> (!hoverPoints.length) {
                        chart.hoverPoints = <span class="hljs-literal">null</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (point === chart.hoverPoint) {
                    point.onMouseOut();
                }
                <span class="hljs-keyword">if</span> (point.graphic || point.dataLabel) {
                    removeEvent(point);
                    point.destroyElements();
                }
                <span class="hljs-keyword">if</span> (point.legendItem) {
                    chart.legend.destroyItem(point);
                }
                <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> point) {
                    point[prop] = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">destroyElements</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    props = [<span class="hljs-string">'graphic'</span>, <span class="hljs-string">'dataLabel'</span>, <span class="hljs-string">'dataLabelUpper'</span>, <span class="hljs-string">'connector'</span>, <span class="hljs-string">'shadowGroup'</span>],
                    prop,
                    i = <span class="hljs-number">6</span>;
                <span class="hljs-keyword">while</span> (i--) {
                    prop = props[i];
                    <span class="hljs-keyword">if</span> (point[prop]) {
                        point[prop] = point[prop].destroy();
                    }
                }
            },
            <span class="hljs-attr">getLabelConfig</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: <span class="hljs-keyword">this</span>.category,
                    <span class="hljs-attr">y</span>: <span class="hljs-keyword">this</span>.y,
                    <span class="hljs-attr">color</span>: <span class="hljs-keyword">this</span>.color,
                    <span class="hljs-attr">colorIndex</span>: <span class="hljs-keyword">this</span>.colorIndex,
                    <span class="hljs-attr">key</span>: <span class="hljs-keyword">this</span>.name || <span class="hljs-keyword">this</span>.category,
                    <span class="hljs-attr">series</span>: <span class="hljs-keyword">this</span>.series,
                    <span class="hljs-attr">point</span>: <span class="hljs-keyword">this</span>,
                    <span class="hljs-attr">percentage</span>: <span class="hljs-keyword">this</span>.percentage,
                    <span class="hljs-attr">total</span>: <span class="hljs-keyword">this</span>.total || <span class="hljs-keyword">this</span>.stackTotal
                };
            },
            <span class="hljs-attr">tooltipFormatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pointFormat</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.series,
                    seriesTooltipOptions = series.tooltipOptions,
                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, <span class="hljs-string">''</span>),
                    valuePrefix = seriesTooltipOptions.valuePrefix || <span class="hljs-string">''</span>,
                    valueSuffix = seriesTooltipOptions.valueSuffix || <span class="hljs-string">''</span>;
                each(series.pointArrayMap || [<span class="hljs-string">'y'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    key = <span class="hljs-string">'{point.'</span> + key;
                    <span class="hljs-keyword">if</span> (valuePrefix || valueSuffix) {
                        pointFormat = pointFormat.replace(key + <span class="hljs-string">'}'</span>, valuePrefix + key + <span class="hljs-string">'}'</span> + valueSuffix);
                    }
                    pointFormat = pointFormat.replace(key + <span class="hljs-string">'}'</span>, key + <span class="hljs-string">':,.'</span> + valueDecimals + <span class="hljs-string">'f}'</span>);
                });
                <span class="hljs-keyword">return</span> format(pointFormat, {
                    <span class="hljs-attr">point</span>: <span class="hljs-keyword">this</span>,
                    <span class="hljs-attr">series</span>: <span class="hljs-keyword">this</span>.series
                });
            },
            <span class="hljs-attr">firePointEvent</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventType, eventArgs, defaultFunction</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = <span class="hljs-keyword">this</span>.series,
                    seriesOptions = series.options;
                <span class="hljs-keyword">if</span> (seriesOptions.point.events[eventType] || (point.options &amp;&amp; point.options.events &amp;&amp; point.options.events[eventType])) {
                    <span class="hljs-keyword">this</span>.importEvents();
                }
                <span class="hljs-keyword">if</span> (eventType === <span class="hljs-string">'click'</span> &amp;&amp; seriesOptions.allowPointSelect) {
                    defaultFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                        <span class="hljs-keyword">if</span> (point.select) {
                            point.select(<span class="hljs-literal">null</span>, event.ctrlKey || event.metaKey || event.shiftKey);
                        }
                    };
                }
                fireEvent(<span class="hljs-keyword">this</span>, eventType, eventArgs, defaultFunction);
            },
            <span class="hljs-attr">visible</span>: <span class="hljs-literal">true</span>
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            animObject = H.animObject,
            arrayMax = H.arrayMax,
            arrayMin = H.arrayMin,
            correctFloat = H.correctFloat,
            <span class="hljs-built_in">Date</span> = H.Date,
            defaultOptions = H.defaultOptions,
            defaultPlotOptions = H.defaultPlotOptions,
            defined = H.defined,
            each = H.each,
            erase = H.erase,
            extend = H.extend,
            fireEvent = H.fireEvent,
            grep = H.grep,
            isArray = H.isArray,
            isNumber = H.isNumber,
            isString = H.isString,
            LegendSymbolMixin = H.LegendSymbolMixin,
            merge = H.merge,
            pick = H.pick,
            Point = H.Point,
            removeEvent = H.removeEvent,
            splat = H.splat,
            SVGElement = H.SVGElement,
            syncTimeout = H.syncTimeout,
            win = H.win;
        H.Series = H.seriesType(<span class="hljs-string">'line'</span>, <span class="hljs-literal">null</span>, {
            <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">allowPointSelect</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">showCheckbox</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">animation</span>: {
                <span class="hljs-attr">duration</span>: <span class="hljs-number">1000</span>
            },
            <span class="hljs-attr">events</span>: {},
            <span class="hljs-attr">marker</span>: {
                <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">lineColor</span>: <span class="hljs-string">'#ffffff'</span>,
                <span class="hljs-attr">radius</span>: <span class="hljs-number">4</span>,
                <span class="hljs-attr">states</span>: {
                    <span class="hljs-attr">hover</span>: {
                        <span class="hljs-attr">animation</span>: {
                            <span class="hljs-attr">duration</span>: <span class="hljs-number">50</span>
                        },
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">radiusPlus</span>: <span class="hljs-number">2</span>,
                        <span class="hljs-attr">lineWidthPlus</span>: <span class="hljs-number">1</span>
                    },
                    <span class="hljs-attr">select</span>: {
                        <span class="hljs-attr">fillColor</span>: <span class="hljs-string">'#cccccc'</span>,
                        <span class="hljs-attr">lineColor</span>: <span class="hljs-string">'#000000'</span>,
                        <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">2</span>
                    }
                }
            },
            <span class="hljs-attr">point</span>: {
                <span class="hljs-attr">events</span>: {}
            },
            <span class="hljs-attr">dataLabels</span>: {
                <span class="hljs-attr">align</span>: <span class="hljs-string">'center'</span>,
                <span class="hljs-attr">formatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.y === <span class="hljs-literal">null</span> ? <span class="hljs-string">''</span> : H.numberFormat(<span class="hljs-keyword">this</span>.y, <span class="hljs-number">-1</span>);
                },
                <span class="hljs-attr">style</span>: {
                    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'11px'</span>,
                    <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>,
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'contrast'</span>,
                    <span class="hljs-attr">textOutline</span>: <span class="hljs-string">'1px contrast'</span>
                },
                <span class="hljs-attr">verticalAlign</span>: <span class="hljs-string">'bottom'</span>,
                <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">padding</span>: <span class="hljs-number">5</span>
            },
            <span class="hljs-attr">cropThreshold</span>: <span class="hljs-number">300</span>,
            <span class="hljs-attr">pointRange</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">softThreshold</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">lineWidthPlus</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">marker</span>: {},
                    <span class="hljs-attr">halo</span>: {
                        <span class="hljs-attr">size</span>: <span class="hljs-number">10</span>,
                        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.25</span>
                    }
                },
                <span class="hljs-attr">select</span>: {
                    <span class="hljs-attr">marker</span>: {}
                }
            },
            <span class="hljs-attr">stickyTracking</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">turboThreshold</span>: <span class="hljs-number">1000</span>
        }, {
            <span class="hljs-attr">isCartesian</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">pointClass</span>: Point,
            <span class="hljs-attr">sorted</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">requireSorting</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">directTouch</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">axisTypes</span>: [<span class="hljs-string">'xAxis'</span>, <span class="hljs-string">'yAxis'</span>],
            <span class="hljs-attr">colorCounter</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">parallelArrays</span>: [<span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>],
            <span class="hljs-attr">coll</span>: <span class="hljs-string">'series'</span>,
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart, options</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    eventType,
                    events,
                    chartSeries = chart.series,
                    lastSeries;
                series.chart = chart;
                series.options = options = series.setOptions(options);
                series.linkedSeries = [];
                series.bindAxes();
                extend(series, {
                    <span class="hljs-attr">name</span>: options.name,
                    <span class="hljs-attr">state</span>: <span class="hljs-string">''</span>,
                    <span class="hljs-attr">visible</span>: options.visible !== <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">selected</span>: options.selected === <span class="hljs-literal">true</span>
                });
                events = options.events;
                <span class="hljs-keyword">for</span> (eventType <span class="hljs-keyword">in</span> events) {
                    addEvent(series, eventType, events[eventType]);
                }
                <span class="hljs-keyword">if</span> (
                    (events &amp;&amp; events.click) ||
                    (options.point &amp;&amp; options.point.events &amp;&amp; options.point.events.click) ||
                    options.allowPointSelect
                ) {
                    chart.runTrackerClick = <span class="hljs-literal">true</span>;
                }
                series.getColor();
                series.getSymbol();
                each(series.parallelArrays, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    series[key + <span class="hljs-string">'Data'</span>] = [];
                });
                series.setData(options.data, <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">if</span> (series.isCartesian) {
                    chart.hasCartesianSeries = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">if</span> (chartSeries.length) {
                    lastSeries = chartSeries[chartSeries.length - <span class="hljs-number">1</span>];
                }
                series._i = pick(lastSeries &amp;&amp; lastSeries._i, <span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>;
                chart.orderSeries(<span class="hljs-keyword">this</span>.insert(chartSeries));
            },
            <span class="hljs-attr">insert</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection</span>) </span>{
                <span class="hljs-keyword">var</span> indexOption = <span class="hljs-keyword">this</span>.options.index,
                    i;
                <span class="hljs-keyword">if</span> (isNumber(indexOption)) {
                    i = collection.length;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (indexOption &gt;=
                            pick(collection[i].options.index, collection[i]._i)) {
                            collection.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (i === <span class="hljs-number">-1</span>) {
                        collection.unshift(<span class="hljs-keyword">this</span>);
                    }
                    i = i + <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    collection.push(<span class="hljs-keyword">this</span>);
                }
                <span class="hljs-keyword">return</span> pick(i, collection.length - <span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">bindAxes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    seriesOptions = series.options,
                    chart = series.chart,
                    axisOptions;
                each(series.axisTypes || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AXIS</span>) </span>{
                    each(chart[AXIS], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        axisOptions = axis.options;
                        <span class="hljs-keyword">if</span> ((seriesOptions[AXIS] === axisOptions.index) ||
                            (seriesOptions[AXIS] !== <span class="hljs-literal">undefined</span> &amp;&amp; seriesOptions[AXIS] === axisOptions.id) ||
                            (seriesOptions[AXIS] === <span class="hljs-literal">undefined</span> &amp;&amp; axisOptions.index === <span class="hljs-number">0</span>)) {
                            series.insert(axis.series);
                            series[AXIS] = axis;
                            axis.isDirty = <span class="hljs-literal">true</span>;
                        }
                    });
                    <span class="hljs-keyword">if</span> (!series[AXIS] &amp;&amp; series.optionalAxis !== AXIS) {
                        H.error(<span class="hljs-number">18</span>, <span class="hljs-literal">true</span>);
                    }
                });
            },
            <span class="hljs-attr">updateParallelArrays</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                <span class="hljs-keyword">var</span> series = point.series,
                    args = <span class="hljs-built_in">arguments</span>,
                    fn = isNumber(i) ?
                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        <span class="hljs-keyword">var</span> val = key === <span class="hljs-string">'y'</span> &amp;&amp; series.toYData ? series.toYData(point) : point[key];
                        series[key + <span class="hljs-string">'Data'</span>][i] = val;
                    } :
                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        <span class="hljs-built_in">Array</span>.prototype[i].apply(series[key + <span class="hljs-string">'Data'</span>], <span class="hljs-built_in">Array</span>.prototype.slice.call(args, <span class="hljs-number">2</span>));
                    };
                each(series.parallelArrays, fn);
            },
            <span class="hljs-attr">autoIncrement</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    xIncrement = <span class="hljs-keyword">this</span>.xIncrement,
                    date,
                    pointInterval,
                    pointIntervalUnit = options.pointIntervalUnit;
                xIncrement = pick(xIncrement, options.pointStart, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">this</span>.pointInterval = pointInterval = pick(<span class="hljs-keyword">this</span>.pointInterval, options.pointInterval, <span class="hljs-number">1</span>);
                <span class="hljs-keyword">if</span> (pointIntervalUnit) {
                    date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(xIncrement);
                    <span class="hljs-keyword">if</span> (pointIntervalUnit === <span class="hljs-string">'day'</span>) {
                        date = +date[<span class="hljs-built_in">Date</span>.hcSetDate](date[<span class="hljs-built_in">Date</span>.hcGetDate]() + pointInterval);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pointIntervalUnit === <span class="hljs-string">'month'</span>) {
                        date = +date[<span class="hljs-built_in">Date</span>.hcSetMonth](date[<span class="hljs-built_in">Date</span>.hcGetMonth]() + pointInterval);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pointIntervalUnit === <span class="hljs-string">'year'</span>) {
                        date = +date[<span class="hljs-built_in">Date</span>.hcSetFullYear](date[<span class="hljs-built_in">Date</span>.hcGetFullYear]() + pointInterval);
                    }
                    pointInterval = date - xIncrement;
                }
                <span class="hljs-keyword">this</span>.xIncrement = xIncrement + pointInterval;
                <span class="hljs-keyword">return</span> xIncrement;
            },
            <span class="hljs-attr">setOptions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">itemOptions</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    chartOptions = chart.options,
                    plotOptions = chartOptions.plotOptions,
                    userOptions = chart.userOptions || {},
                    userPlotOptions = userOptions.plotOptions || {},
                    typeOptions = plotOptions[<span class="hljs-keyword">this</span>.type],
                    options,
                    zones;
                <span class="hljs-keyword">this</span>.userOptions = itemOptions;
                options = merge(
                    typeOptions,
                    plotOptions.series,
                    itemOptions
                );
                <span class="hljs-keyword">this</span>.tooltipOptions = merge(
                    defaultOptions.tooltip,
                    defaultOptions.plotOptions[<span class="hljs-keyword">this</span>.type].tooltip,
                    userOptions.tooltip,
                    userPlotOptions.series &amp;&amp; userPlotOptions.series.tooltip,
                    userPlotOptions[<span class="hljs-keyword">this</span>.type] &amp;&amp; userPlotOptions[<span class="hljs-keyword">this</span>.type].tooltip,
                    itemOptions.tooltip
                );
                <span class="hljs-keyword">if</span> (typeOptions.marker === <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">delete</span> options.marker;
                }
                <span class="hljs-keyword">this</span>.zoneAxis = options.zoneAxis;
                zones = <span class="hljs-keyword">this</span>.zones = (options.zones || []).slice();
                <span class="hljs-keyword">if</span> ((options.negativeColor || options.negativeFillColor) &amp;&amp; !options.zones) {
                    zones.push({
                        <span class="hljs-attr">value</span>: options[<span class="hljs-keyword">this</span>.zoneAxis + <span class="hljs-string">'Threshold'</span>] || options.threshold || <span class="hljs-number">0</span>,
                        <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-negative'</span>,
                        <span class="hljs-attr">color</span>: options.negativeColor,
                        <span class="hljs-attr">fillColor</span>: options.negativeFillColor
                    });
                }
                <span class="hljs-keyword">if</span> (zones.length) {
                    <span class="hljs-keyword">if</span> (defined(zones[zones.length - <span class="hljs-number">1</span>].value)) {
                        zones.push({
                            <span class="hljs-attr">color</span>: <span class="hljs-keyword">this</span>.color,
                            <span class="hljs-attr">fillColor</span>: <span class="hljs-keyword">this</span>.fillColor
                        });
                    }
                }
                <span class="hljs-keyword">return</span> options;
            },
            <span class="hljs-attr">getCyclic</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, value, defaults</span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    userOptions = <span class="hljs-keyword">this</span>.userOptions,
                    indexName = prop + <span class="hljs-string">'Index'</span>,
                    counterName = prop + <span class="hljs-string">'Counter'</span>,
                    len = defaults ? defaults.length : pick(
                        chart.options.chart[prop + <span class="hljs-string">'Count'</span>],
                        chart[prop + <span class="hljs-string">'Count'</span>]
                    ),
                    setting;
                <span class="hljs-keyword">if</span> (!value) {
                    setting = pick(userOptions[indexName], userOptions[<span class="hljs-string">'_'</span> + indexName]);
                    <span class="hljs-keyword">if</span> (defined(setting)) {
                        i = setting;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (!chart.series.length) {
                            chart[counterName] = <span class="hljs-number">0</span>;
                        }
                        userOptions[<span class="hljs-string">'_'</span> + indexName] = i = chart[counterName] % len;
                        chart[counterName] += <span class="hljs-number">1</span>;
                    }
                    <span class="hljs-keyword">if</span> (defaults) {
                        value = defaults[i];
                    }
                }
                <span class="hljs-keyword">if</span> (i !== <span class="hljs-literal">undefined</span>) {
                    <span class="hljs-keyword">this</span>[indexName] = i;
                }
                <span class="hljs-keyword">this</span>[prop] = value;
            },
            <span class="hljs-attr">getColor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.colorByPoint) {
                    <span class="hljs-keyword">this</span>.options.color = <span class="hljs-literal">null</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.getCyclic(<span class="hljs-string">'color'</span>, <span class="hljs-keyword">this</span>.options.color || defaultPlotOptions[<span class="hljs-keyword">this</span>.type].color, <span class="hljs-keyword">this</span>.chart.options.colors);
                }
            },
            <span class="hljs-attr">getSymbol</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> seriesMarkerOption = <span class="hljs-keyword">this</span>.options.marker;
                <span class="hljs-keyword">this</span>.getCyclic(<span class="hljs-string">'symbol'</span>, seriesMarkerOption.symbol, <span class="hljs-keyword">this</span>.chart.options.symbols);
            },
            <span class="hljs-attr">drawLegendSymbol</span>: LegendSymbolMixin.drawLineMarker,
            <span class="hljs-attr">setData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, redraw, animation, updatePoints</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    oldData = series.points,
                    oldDataLength = (oldData &amp;&amp; oldData.length) || <span class="hljs-number">0</span>,
                    dataLength,
                    options = series.options,
                    chart = series.chart,
                    firstPoint = <span class="hljs-literal">null</span>,
                    xAxis = series.xAxis,
                    i,
                    turboThreshold = options.turboThreshold,
                    pt,
                    xData = <span class="hljs-keyword">this</span>.xData,
                    yData = <span class="hljs-keyword">this</span>.yData,
                    pointArrayMap = series.pointArrayMap,
                    valueCount = pointArrayMap &amp;&amp; pointArrayMap.length;
                data = data || [];
                dataLength = data.length;
                redraw = pick(redraw, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (updatePoints !== <span class="hljs-literal">false</span> &amp;&amp; dataLength &amp;&amp; oldDataLength === dataLength &amp;&amp; !series.cropped &amp;&amp; !series.hasGroupedData &amp;&amp; series.visible) {
                    each(data, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                        <span class="hljs-keyword">if</span> (oldData[i].update &amp;&amp; point !== options.data[i]) {
                            oldData[i].update(point, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);
                        }
                    });
                } <span class="hljs-keyword">else</span> {
                    series.xIncrement = <span class="hljs-literal">null</span>;
                    series.colorCounter = <span class="hljs-number">0</span>;
                    each(<span class="hljs-keyword">this</span>.parallelArrays, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        series[key + <span class="hljs-string">'Data'</span>].length = <span class="hljs-number">0</span>;
                    });
                    <span class="hljs-keyword">if</span> (turboThreshold &amp;&amp; dataLength &gt; turboThreshold) {
                        i = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">while</span> (firstPoint === <span class="hljs-literal">null</span> &amp;&amp; i &lt; dataLength) {
                            firstPoint = data[i];
                            i++;
                        }
                        <span class="hljs-keyword">if</span> (isNumber(firstPoint)) {
                            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                                xData[i] = <span class="hljs-keyword">this</span>.autoIncrement();
                                yData[i] = data[i];
                            }
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isArray(firstPoint)) {
                            <span class="hljs-keyword">if</span> (valueCount) {
                                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[<span class="hljs-number">0</span>];
                                    yData[i] = pt.slice(<span class="hljs-number">1</span>, valueCount + <span class="hljs-number">1</span>);
                                }
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                                    pt = data[i];
                                    xData[i] = pt[<span class="hljs-number">0</span>];
                                    yData[i] = pt[<span class="hljs-number">1</span>];
                                }
                            }
                        } <span class="hljs-keyword">else</span> {
                            H.error(<span class="hljs-number">12</span>);
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                            <span class="hljs-keyword">if</span> (data[i] !== <span class="hljs-literal">undefined</span>) {
                                pt = {
                                    <span class="hljs-attr">series</span>: series
                                };
                                series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                                series.updateParallelArrays(pt, i);
                            }
                        }
                    }
                    <span class="hljs-keyword">if</span> (isString(yData[<span class="hljs-number">0</span>])) {
                        H.error(<span class="hljs-number">14</span>, <span class="hljs-literal">true</span>);
                    }
                    series.data = [];
                    series.options.data = series.userOptions.data = data;
                    i = oldDataLength;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (oldData[i] &amp;&amp; oldData[i].destroy) {
                            oldData[i].destroy();
                        }
                    }
                    <span class="hljs-keyword">if</span> (xAxis) {
                        xAxis.minRange = xAxis.userMinRange;
                    }
                    series.isDirty = chart.isDirtyBox = <span class="hljs-literal">true</span>;
                    series.isDirtyData = !!oldData;
                    animation = <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (options.legendType === <span class="hljs-string">'point'</span>) {
                    <span class="hljs-keyword">this</span>.processData();
                    <span class="hljs-keyword">this</span>.generatePoints();
                }
                <span class="hljs-keyword">if</span> (redraw) {
                    chart.redraw(animation);
                }
            },
            <span class="hljs-attr">processData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">force</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    processedXData = series.xData,
                    processedYData = series.yData,
                    dataLength = processedXData.length,
                    croppedData,
                    cropStart = <span class="hljs-number">0</span>,
                    cropped,
                    distance,
                    closestPointRange,
                    xAxis = series.xAxis,
                    i,
                    options = series.options,
                    cropThreshold = options.cropThreshold,
                    getExtremesFromAll = series.getExtremesFromAll || options.getExtremesFromAll,
                    isCartesian = series.isCartesian,
                    xExtremes,
                    val2lin = xAxis &amp;&amp; xAxis.val2lin,
                    isLog = xAxis &amp;&amp; xAxis.isLog,
                    min,
                    max;
                <span class="hljs-keyword">if</span> (isCartesian &amp;&amp; !series.isDirty &amp;&amp; !xAxis.isDirty &amp;&amp; !series.yAxis.isDirty &amp;&amp; !force) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (xAxis) {
                    xExtremes = xAxis.getExtremes();
                    min = xExtremes.min;
                    max = xExtremes.max;
                }
                <span class="hljs-keyword">if</span> (isCartesian &amp;&amp; series.sorted &amp;&amp; !getExtremesFromAll &amp;&amp; (!cropThreshold || dataLength &gt; cropThreshold || series.forceCrop)) {
                    <span class="hljs-keyword">if</span> (processedXData[dataLength - <span class="hljs-number">1</span>] &lt; min || processedXData[<span class="hljs-number">0</span>] &gt; max) {
                        processedXData = [];
                        processedYData = [];
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (processedXData[<span class="hljs-number">0</span>] &lt; min || processedXData[dataLength - <span class="hljs-number">1</span>] &gt; max) {
                        croppedData = <span class="hljs-keyword">this</span>.cropData(series.xData, series.yData, min, max);
                        processedXData = croppedData.xData;
                        processedYData = croppedData.yData;
                        cropStart = croppedData.start;
                        cropped = <span class="hljs-literal">true</span>;
                    }
                }
                i = processedXData.length || <span class="hljs-number">1</span>;
                <span class="hljs-keyword">while</span> (--i) {
                    distance = isLog ?
                        val2lin(processedXData[i]) - val2lin(processedXData[i - <span class="hljs-number">1</span>]) :
                        processedXData[i] - processedXData[i - <span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span> (distance &gt; <span class="hljs-number">0</span> &amp;&amp; (closestPointRange === <span class="hljs-literal">undefined</span> || distance &lt; closestPointRange)) {
                        closestPointRange = distance;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (distance &lt; <span class="hljs-number">0</span> &amp;&amp; series.requireSorting) {
                        H.error(<span class="hljs-number">15</span>);
                    }
                }
                series.cropped = cropped;
                series.cropStart = cropStart;
                series.processedXData = processedXData;
                series.processedYData = processedYData;
                series.closestPointRange = closestPointRange;
            },
            <span class="hljs-attr">cropData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xData, yData, min, max</span>) </span>{
                <span class="hljs-keyword">var</span> dataLength = xData.length,
                    cropStart = <span class="hljs-number">0</span>,
                    cropEnd = dataLength,
                    cropShoulder = pick(<span class="hljs-keyword">this</span>.cropShoulder, <span class="hljs-number">1</span>),
                    i,
                    j;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                    <span class="hljs-keyword">if</span> (xData[i] &gt;= min) {
                        cropStart = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, i - cropShoulder);
                        <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-keyword">for</span> (j = i; j &lt; dataLength; j++) {
                    <span class="hljs-keyword">if</span> (xData[j] &gt; max) {
                        cropEnd = j + cropShoulder;
                        <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">xData</span>: xData.slice(cropStart, cropEnd),
                    <span class="hljs-attr">yData</span>: yData.slice(cropStart, cropEnd),
                    <span class="hljs-attr">start</span>: cropStart,
                    <span class="hljs-attr">end</span>: cropEnd
                };
            },
            <span class="hljs-attr">generatePoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    dataOptions = options.data,
                    data = series.data,
                    dataLength,
                    processedXData = series.processedXData,
                    processedYData = series.processedYData,
                    PointClass = series.pointClass,
                    processedDataLength = processedXData.length,
                    cropStart = series.cropStart || <span class="hljs-number">0</span>,
                    cursor,
                    hasGroupedData = series.hasGroupedData,
                    point,
                    points = [],
                    i;
                <span class="hljs-keyword">if</span> (!data &amp;&amp; !hasGroupedData) {
                    <span class="hljs-keyword">var</span> arr = [];
                    arr.length = dataOptions.length;
                    data = series.data = arr;
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processedDataLength; i++) {
                    cursor = cropStart + i;
                    <span class="hljs-keyword">if</span> (!hasGroupedData) {
                        point = data[cursor];
                        <span class="hljs-keyword">if</span> (!point &amp;&amp; dataOptions[cursor] !== <span class="hljs-literal">undefined</span>) {
                            data[cursor] = point = (<span class="hljs-keyword">new</span> PointClass()).init(series, dataOptions[cursor], processedXData[i]);
                        }
                    } <span class="hljs-keyword">else</span> {
                        point = (<span class="hljs-keyword">new</span> PointClass()).init(series, [processedXData[i]].concat(splat(processedYData[i])));
                        point.dataGroup = series.groupMap[i];
                    }
                    point.index = cursor;
                    points[i] = point;
                }
                <span class="hljs-keyword">if</span> (data &amp;&amp; (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                        <span class="hljs-keyword">if</span> (i === cropStart &amp;&amp; !hasGroupedData) {
                            i += processedDataLength;
                        }
                        <span class="hljs-keyword">if</span> (data[i]) {
                            data[i].destroyElements();
                            data[i].plotX = <span class="hljs-literal">undefined</span>;
                        }
                    }
                }
                series.data = data;
                series.points = points;
            },
            <span class="hljs-attr">getExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">yData</span>) </span>{
                <span class="hljs-keyword">var</span> xAxis = <span class="hljs-keyword">this</span>.xAxis,
                    yAxis = <span class="hljs-keyword">this</span>.yAxis,
                    xData = <span class="hljs-keyword">this</span>.processedXData,
                    yDataLength,
                    activeYData = [],
                    activeCounter = <span class="hljs-number">0</span>,
                    xExtremes = xAxis.getExtremes(),
                    xMin = xExtremes.min,
                    xMax = xExtremes.max,
                    validValue,
                    withinRange,
                    x,
                    y,
                    i,
                    j;
                yData = yData || <span class="hljs-keyword">this</span>.stackedYData || <span class="hljs-keyword">this</span>.processedYData || [];
                yDataLength = yData.length;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; yDataLength; i++) {
                    x = xData[i];
                    y = yData[i];
                    validValue = (isNumber(y, <span class="hljs-literal">true</span>) || isArray(y)) &amp;&amp; (!yAxis.isLog || (y.length || y &gt; <span class="hljs-number">0</span>));
                    withinRange = <span class="hljs-keyword">this</span>.getExtremesFromAll || <span class="hljs-keyword">this</span>.options.getExtremesFromAll || <span class="hljs-keyword">this</span>.cropped ||
                        ((xData[i + <span class="hljs-number">1</span>] || x) &gt;= xMin &amp;&amp; (xData[i - <span class="hljs-number">1</span>] || x) &lt;= xMax);
                    <span class="hljs-keyword">if</span> (validValue &amp;&amp; withinRange) {
                        j = y.length;
                        <span class="hljs-keyword">if</span> (j) {
                            <span class="hljs-keyword">while</span> (j--) {
                                <span class="hljs-keyword">if</span> (y[j] !== <span class="hljs-literal">null</span>) {
                                    activeYData[activeCounter++] = y[j];
                                }
                            }
                        } <span class="hljs-keyword">else</span> {
                            activeYData[activeCounter++] = y;
                        }
                    }
                }
                <span class="hljs-keyword">this</span>.dataMin = arrayMin(activeYData);
                <span class="hljs-keyword">this</span>.dataMax = arrayMax(activeYData);
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.processedXData) {
                    <span class="hljs-keyword">this</span>.processData();
                }
                <span class="hljs-keyword">this</span>.generatePoints();
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    stacking = options.stacking,
                    xAxis = series.xAxis,
                    categories = xAxis.categories,
                    yAxis = series.yAxis,
                    points = series.points,
                    dataLength = points.length,
                    hasModifyValue = !!series.modifyValue,
                    i,
                    pointPlacement = options.pointPlacement,
                    dynamicallyPlaced = pointPlacement === <span class="hljs-string">'between'</span> || isNumber(pointPlacement),
                    threshold = options.threshold,
                    stackThreshold = options.startFromThreshold ? threshold : <span class="hljs-number">0</span>,
                    plotX,
                    plotY,
                    lastPlotX,
                    stackIndicator,
                    closestPointRangePx = <span class="hljs-built_in">Number</span>.MAX_VALUE;
                <span class="hljs-keyword">if</span> (pointPlacement === <span class="hljs-string">'between'</span>) {
                    pointPlacement = <span class="hljs-number">0.5</span>;
                }
                <span class="hljs-keyword">if</span> (isNumber(pointPlacement)) {
                    pointPlacement *= pick(options.pointRange || xAxis.pointRange);
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; dataLength; i++) {
                    <span class="hljs-keyword">var</span> point = points[i],
                        xValue = point.x,
                        yValue = point.y,
                        yBottom = point.low,
                        stack = stacking &amp;&amp; yAxis.stacks[(series.negStacks &amp;&amp; yValue &lt; (stackThreshold ? <span class="hljs-number">0</span> : threshold) ? <span class="hljs-string">'-'</span> : <span class="hljs-string">''</span>) + series.stackKey],
                        pointStack,
                        stackValues;
                    <span class="hljs-keyword">if</span> (yAxis.isLog &amp;&amp; yValue !== <span class="hljs-literal">null</span> &amp;&amp; yValue &lt;= <span class="hljs-number">0</span>) {
                        point.isNull = <span class="hljs-literal">true</span>;
                    }
                    point.plotX = plotX = correctFloat(
                        <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">-1e5</span>, xAxis.translate(
                            xValue,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">1</span>,
                            pointPlacement,
                            <span class="hljs-keyword">this</span>.type === <span class="hljs-string">'flags'</span>
                        )), <span class="hljs-number">1e5</span>)
                    );
                    <span class="hljs-keyword">if</span> (stacking &amp;&amp; series.visible &amp;&amp; !point.isNull &amp;&amp; stack &amp;&amp; stack[xValue]) {
                        stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                        pointStack = stack[xValue];
                        stackValues = pointStack.points[stackIndicator.key];
                        yBottom = stackValues[<span class="hljs-number">0</span>];
                        yValue = stackValues[<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">if</span> (yBottom === stackThreshold &amp;&amp; stackIndicator.key === stack[xValue].base) {
                            yBottom = pick(threshold, yAxis.min);
                        }
                        <span class="hljs-keyword">if</span> (yAxis.isLog &amp;&amp; yBottom &lt;= <span class="hljs-number">0</span>) {
                            yBottom = <span class="hljs-literal">null</span>;
                        }
                        point.total = point.stackTotal = pointStack.total;
                        point.percentage = pointStack.total &amp;&amp; (point.y / pointStack.total * <span class="hljs-number">100</span>);
                        point.stackY = yValue;
                        pointStack.setOffset(series.pointXOffset || <span class="hljs-number">0</span>, series.barW || <span class="hljs-number">0</span>);
                    }
                    point.yBottom = defined(yBottom) ?
                        yAxis.translate(yBottom, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) :
                        <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">if</span> (hasModifyValue) {
                        yValue = series.modifyValue(yValue, point);
                    }
                    point.plotY = plotY = (<span class="hljs-keyword">typeof</span> yValue === <span class="hljs-string">'number'</span> &amp;&amp; yValue !== <span class="hljs-literal">Infinity</span>) ?
                        <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">-1e5</span>, yAxis.translate(yValue, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)), <span class="hljs-number">1e5</span>) :
                        <span class="hljs-literal">undefined</span>;
                    point.isInside = plotY !== <span class="hljs-literal">undefined</span> &amp;&amp; plotY &gt;= <span class="hljs-number">0</span> &amp;&amp; plotY &lt;= yAxis.len &amp;&amp;
                        plotX &gt;= <span class="hljs-number">0</span> &amp;&amp; plotX &lt;= xAxis.len;
                    point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, pointPlacement)) : plotX;
                    point.negative = point.y &lt; (threshold || <span class="hljs-number">0</span>);
                    point.category = categories &amp;&amp; categories[point.x] !== <span class="hljs-literal">undefined</span> ?
                        categories[point.x] : point.x;
                    <span class="hljs-keyword">if</span> (!point.isNull) {
                        <span class="hljs-keyword">if</span> (lastPlotX !== <span class="hljs-literal">undefined</span>) {
                            closestPointRangePx = <span class="hljs-built_in">Math</span>.min(closestPointRangePx, <span class="hljs-built_in">Math</span>.abs(plotX - lastPlotX));
                        }
                        lastPlotX = plotX;
                    }
                    point.zone = <span class="hljs-keyword">this</span>.zones.length &amp;&amp; point.getZone();
                }
                series.closestPointRangePx = closestPointRangePx;
            },
            <span class="hljs-attr">getValidPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, insideOnly</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                <span class="hljs-keyword">return</span> grep(points || <span class="hljs-keyword">this</span>.points || [], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isValidPoint</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">if</span> (insideOnly &amp;&amp; !chart.isInsidePlot(point.plotX, point.plotY, chart.inverted)) {
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    }
                    <span class="hljs-keyword">return</span> !point.isNull;
                });
            },
            <span class="hljs-attr">setClip</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">animation</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    options = <span class="hljs-keyword">this</span>.options,
                    renderer = chart.renderer,
                    inverted = chart.inverted,
                    seriesClipBox = <span class="hljs-keyword">this</span>.clipBox,
                    clipBox = seriesClipBox || chart.clipBox,
                    sharedClipKey = <span class="hljs-keyword">this</span>.sharedClipKey || [<span class="hljs-string">'_sharedClip'</span>, animation &amp;&amp; animation.duration, animation &amp;&amp; animation.easing, clipBox.height, options.xAxis, options.yAxis].join(<span class="hljs-string">','</span>),
                    clipRect = chart[sharedClipKey],
                    markerClipRect = chart[sharedClipKey + <span class="hljs-string">'m'</span>];
                <span class="hljs-keyword">if</span> (!clipRect) {
                    <span class="hljs-keyword">if</span> (animation) {
                        clipBox.width = <span class="hljs-number">0</span>;
                        chart[sharedClipKey + <span class="hljs-string">'m'</span>] = markerClipRect = renderer.clipRect(<span class="hljs-number">-99</span>,
                            inverted ? -chart.plotLeft : -chart.plotTop,
                            <span class="hljs-number">99</span>,
                            inverted ? chart.chartWidth : chart.chartHeight
                        );
                    }
                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
                    clipRect.count = {
                        <span class="hljs-attr">length</span>: <span class="hljs-number">0</span>
                    };
                }
                <span class="hljs-keyword">if</span> (animation) {
                    <span class="hljs-keyword">if</span> (!clipRect.count[<span class="hljs-keyword">this</span>.index]) {
                        clipRect.count[<span class="hljs-keyword">this</span>.index] = <span class="hljs-literal">true</span>;
                        clipRect.count.length += <span class="hljs-number">1</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (options.clip !== <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">this</span>.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);
                    <span class="hljs-keyword">this</span>.markerGroup.clip(markerClipRect);
                    <span class="hljs-keyword">this</span>.sharedClipKey = sharedClipKey;
                }
                <span class="hljs-keyword">if</span> (!animation) {
                    <span class="hljs-keyword">if</span> (clipRect.count[<span class="hljs-keyword">this</span>.index]) {
                        <span class="hljs-keyword">delete</span> clipRect.count[<span class="hljs-keyword">this</span>.index];
                        clipRect.count.length -= <span class="hljs-number">1</span>;
                    }
                    <span class="hljs-keyword">if</span> (clipRect.count.length === <span class="hljs-number">0</span> &amp;&amp; sharedClipKey &amp;&amp; chart[sharedClipKey]) {
                        <span class="hljs-keyword">if</span> (!seriesClipBox) {
                            chart[sharedClipKey] = chart[sharedClipKey].destroy();
                        }
                        <span class="hljs-keyword">if</span> (chart[sharedClipKey + <span class="hljs-string">'m'</span>]) {
                            <span class="hljs-keyword">this</span>.markerGroup.clip();
                            chart[sharedClipKey + <span class="hljs-string">'m'</span>] = chart[sharedClipKey + <span class="hljs-string">'m'</span>].destroy();
                        }
                    }
                }
            },
            <span class="hljs-attr">animate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">init</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    clipRect,
                    animation = animObject(series.options.animation),
                    sharedClipKey;
                <span class="hljs-keyword">if</span> (init) {
                    series.setClip(animation);
                } <span class="hljs-keyword">else</span> {
                    sharedClipKey = <span class="hljs-keyword">this</span>.sharedClipKey;
                    clipRect = chart[sharedClipKey];
                    <span class="hljs-keyword">if</span> (clipRect) {
                        clipRect.animate({
                            <span class="hljs-attr">width</span>: chart.plotSizeX
                        }, animation);
                    }
                    <span class="hljs-keyword">if</span> (chart[sharedClipKey + <span class="hljs-string">'m'</span>]) {
                        chart[sharedClipKey + <span class="hljs-string">'m'</span>].animate({
                            <span class="hljs-attr">width</span>: chart.plotSizeX + <span class="hljs-number">99</span>
                        }, animation);
                    }
                    series.animate = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">afterAnimate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.setClip();
                fireEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'afterAnimate'</span>);
            },
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points,
                    chart = series.chart,
                    plotY,
                    i,
                    point,
                    symbol,
                    graphic,
                    options = series.options,
                    seriesMarkerOptions = options.marker,
                    pointMarkerOptions,
                    hasPointMarker,
                    enabled,
                    isInside,
                    markerGroup = series.markerGroup,
                    xAxis = series.xAxis,
                    markerAttribs,
                    globallyEnabled = pick(
                        seriesMarkerOptions.enabled,
                        xAxis.isRadial ? <span class="hljs-literal">true</span> : <span class="hljs-literal">null</span>,
                        series.closestPointRangePx &gt; <span class="hljs-number">2</span> * seriesMarkerOptions.radius
                    );
                <span class="hljs-keyword">if</span> (seriesMarkerOptions.enabled !== <span class="hljs-literal">false</span> || series._hasPointMarkers) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; points.length; i++) {
                        point = points[i];
                        plotY = point.plotY;
                        graphic = point.graphic;
                        pointMarkerOptions = point.marker || {};
                        hasPointMarker = !!point.marker;
                        enabled = (globallyEnabled &amp;&amp; pointMarkerOptions.enabled === <span class="hljs-literal">undefined</span>) || pointMarkerOptions.enabled;
                        isInside = point.isInside;
                        <span class="hljs-keyword">if</span> (enabled &amp;&amp; isNumber(plotY) &amp;&amp; point.y !== <span class="hljs-literal">null</span>) {
                            symbol = pick(pointMarkerOptions.symbol, series.symbol);
                            point.hasImage = symbol.indexOf(<span class="hljs-string">'url'</span>) === <span class="hljs-number">0</span>;
                            markerAttribs = series.markerAttribs(
                                point,
                                point.selected &amp;&amp; <span class="hljs-string">'select'</span>
                            );
                            <span class="hljs-keyword">if</span> (graphic) {
                                graphic[isInside ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>](<span class="hljs-literal">true</span>)
                                    .animate(markerAttribs);
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isInside &amp;&amp; (markerAttribs.width &gt; <span class="hljs-number">0</span> || point.hasImage)) {
                                point.graphic = graphic = chart.renderer.symbol(
                                        symbol,
                                        markerAttribs.x,
                                        markerAttribs.y,
                                        markerAttribs.width,
                                        markerAttribs.height,
                                        hasPointMarker ? pointMarkerOptions : seriesMarkerOptions
                                    )
                                    .add(markerGroup);
                            }
                            <span class="hljs-keyword">if</span> (graphic) {
                                graphic.attr(series.pointAttribs(point, point.selected &amp;&amp; <span class="hljs-string">'select'</span>));
                            }
                            <span class="hljs-keyword">if</span> (graphic) {
                                graphic.addClass(point.getClassName(), <span class="hljs-literal">true</span>);
                            }
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (graphic) {
                            point.graphic = graphic.destroy();
                        }
                    }
                }
            },
            <span class="hljs-attr">markerAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> seriesMarkerOptions = <span class="hljs-keyword">this</span>.options.marker,
                    seriesStateOptions,
                    pointMarkerOptions = point.marker || {},
                    pointStateOptions,
                    radius = pick(
                        pointMarkerOptions.radius,
                        seriesMarkerOptions.radius
                    ),
                    attribs;
                <span class="hljs-keyword">if</span> (state) {
                    seriesStateOptions = seriesMarkerOptions.states[state];
                    pointStateOptions = pointMarkerOptions.states &amp;&amp;
                        pointMarkerOptions.states[state];
                    radius = pick(
                        pointStateOptions &amp;&amp; pointStateOptions.radius,
                        seriesStateOptions &amp;&amp; seriesStateOptions.radius,
                        radius + (seriesStateOptions &amp;&amp; seriesStateOptions.radiusPlus || <span class="hljs-number">0</span>)
                    );
                }
                <span class="hljs-keyword">if</span> (point.hasImage) {
                    radius = <span class="hljs-number">0</span>;
                }
                attribs = {
                    <span class="hljs-attr">x</span>: <span class="hljs-built_in">Math</span>.floor(point.plotX) - radius,
                    <span class="hljs-attr">y</span>: point.plotY - radius
                };
                <span class="hljs-keyword">if</span> (radius) {
                    attribs.width = attribs.height = <span class="hljs-number">2</span> * radius;
                }
                <span class="hljs-keyword">return</span> attribs;
            },
            <span class="hljs-attr">pointAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> seriesMarkerOptions = <span class="hljs-keyword">this</span>.options.marker,
                    seriesStateOptions,
                    pointOptions = point &amp;&amp; point.options,
                    pointMarkerOptions = (pointOptions &amp;&amp; pointOptions.marker) || {},
                    pointStateOptions,
                    color = <span class="hljs-keyword">this</span>.color,
                    pointColorOption = pointOptions &amp;&amp; pointOptions.color,
                    pointColor = point &amp;&amp; point.color,
                    strokeWidth = pick(
                        pointMarkerOptions.lineWidth,
                        seriesMarkerOptions.lineWidth
                    ),
                    zoneColor = point &amp;&amp; point.zone &amp;&amp; point.zone.color,
                    fill,
                    stroke;
                color = pointColorOption || zoneColor || pointColor || color;
                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;
                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;
                <span class="hljs-keyword">if</span> (state) {
                    seriesStateOptions = seriesMarkerOptions.states[state];
                    pointStateOptions = (pointMarkerOptions.states &amp;&amp; pointMarkerOptions.states[state]) || {};
                    strokeWidth = pick(
                        pointStateOptions.lineWidth,
                        seriesStateOptions.lineWidth,
                        strokeWidth + pick(
                            pointStateOptions.lineWidthPlus,
                            seriesStateOptions.lineWidthPlus,
                            <span class="hljs-number">0</span>
                        )
                    );
                    fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
                    stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-string">'stroke'</span>: stroke,
                    <span class="hljs-string">'stroke-width'</span>: strokeWidth,
                    <span class="hljs-string">'fill'</span>: fill
                };
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    issue134 = <span class="hljs-regexp">/AppleWebKit\/533/</span>.test(win.navigator.userAgent),
                    destroy,
                    i,
                    data = series.data || [],
                    point,
                    prop,
                    axis;
                fireEvent(series, <span class="hljs-string">'destroy'</span>);
                removeEvent(series);
                each(series.axisTypes || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">AXIS</span>) </span>{
                    axis = series[AXIS];
                    <span class="hljs-keyword">if</span> (axis &amp;&amp; axis.series) {
                        erase(axis.series, series);
                        axis.isDirty = axis.forceRedraw = <span class="hljs-literal">true</span>;
                    }
                });
                <span class="hljs-keyword">if</span> (series.legendItem) {
                    series.chart.legend.destroyItem(series);
                }
                i = data.length;
                <span class="hljs-keyword">while</span> (i--) {
                    point = data[i];
                    <span class="hljs-keyword">if</span> (point &amp;&amp; point.destroy) {
                        point.destroy();
                    }
                }
                series.points = <span class="hljs-literal">null</span>;
                clearTimeout(series.animationTimeout);
                <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> series) {
                    <span class="hljs-keyword">if</span> (series[prop] <span class="hljs-keyword">instanceof</span> SVGElement &amp;&amp; !series[prop].survive) {
                        destroy = issue134 &amp;&amp; prop === <span class="hljs-string">'group'</span> ?
                            <span class="hljs-string">'hide'</span> :
                            <span class="hljs-string">'destroy'</span>;
                        series[prop][destroy]();
                    }
                }
                <span class="hljs-keyword">if</span> (chart.hoverSeries === series) {
                    chart.hoverSeries = <span class="hljs-literal">null</span>;
                }
                erase(chart.series, series);
                chart.orderSeries();
                <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> series) {
                    <span class="hljs-keyword">delete</span> series[prop];
                }
            },
            <span class="hljs-attr">getGraphPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, nullsAsZeroes, connectCliffs</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    step = options.step,
                    reversed,
                    graphPath = [],
                    xMap = [],
                    gap;
                points = points || series.points;
                reversed = points.reversed;
                <span class="hljs-keyword">if</span> (reversed) {
                    points.reverse();
                }
                step = {
                    <span class="hljs-attr">right</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">center</span>: <span class="hljs-number">2</span>
                }[step] || (step &amp;&amp; <span class="hljs-number">3</span>);
                <span class="hljs-keyword">if</span> (step &amp;&amp; reversed) {
                    step = <span class="hljs-number">4</span> - step;
                }
                <span class="hljs-keyword">if</span> (options.connectNulls &amp;&amp; !nullsAsZeroes &amp;&amp; !connectCliffs) {
                    points = <span class="hljs-keyword">this</span>.getValidPoints(points);
                }
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                    <span class="hljs-keyword">var</span> plotX = point.plotX,
                        plotY = point.plotY,
                        lastPoint = points[i - <span class="hljs-number">1</span>],
                        pathToPoint;
                    <span class="hljs-keyword">if</span> ((point.leftCliff || (lastPoint &amp;&amp; lastPoint.rightCliff)) &amp;&amp; !connectCliffs) {
                        gap = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">if</span> (point.isNull &amp;&amp; !defined(nullsAsZeroes) &amp;&amp; i &gt; <span class="hljs-number">0</span>) {
                        gap = !options.connectNulls;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (point.isNull &amp;&amp; !nullsAsZeroes) {
                        gap = <span class="hljs-literal">true</span>;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || gap) {
                            pathToPoint = [<span class="hljs-string">'M'</span>, point.plotX, point.plotY];
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (series.getPointSpline) {
                            pathToPoint = series.getPointSpline(points, point, i);
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step) {
                            <span class="hljs-keyword">if</span> (step === <span class="hljs-number">1</span>) {
                                pathToPoint = [
                                    <span class="hljs-string">'L'</span>,
                                    lastPoint.plotX,
                                    plotY
                                ];
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step === <span class="hljs-number">2</span>) {
                                pathToPoint = [
                                    <span class="hljs-string">'L'</span>,
                                    (lastPoint.plotX + plotX) / <span class="hljs-number">2</span>,
                                    lastPoint.plotY,
                                    <span class="hljs-string">'L'</span>,
                                    (lastPoint.plotX + plotX) / <span class="hljs-number">2</span>,
                                    plotY
                                ];
                            } <span class="hljs-keyword">else</span> {
                                pathToPoint = [
                                    <span class="hljs-string">'L'</span>,
                                    plotX,
                                    lastPoint.plotY
                                ];
                            }
                            pathToPoint.push(<span class="hljs-string">'L'</span>, plotX, plotY);
                        } <span class="hljs-keyword">else</span> {
                            pathToPoint = [
                                <span class="hljs-string">'L'</span>,
                                plotX,
                                plotY
                            ];
                        }
                        xMap.push(point.x);
                        <span class="hljs-keyword">if</span> (step) {
                            xMap.push(point.x);
                        }
                        graphPath.push.apply(graphPath, pathToPoint);
                        gap = <span class="hljs-literal">false</span>;
                    }
                });
                graphPath.xMap = xMap;
                series.graphPath = graphPath;
                <span class="hljs-keyword">return</span> graphPath;
            },
            <span class="hljs-attr">drawGraph</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = <span class="hljs-keyword">this</span>.options,
                    graphPath = (<span class="hljs-keyword">this</span>.gappedPath || <span class="hljs-keyword">this</span>.getGraphPath).call(<span class="hljs-keyword">this</span>),
                    props = [
                        [
                            <span class="hljs-string">'graph'</span>,
                            <span class="hljs-string">'highcharts-graph'</span>,
                            options.lineColor || <span class="hljs-keyword">this</span>.color,
                            options.dashStyle
                        ]
                    ];
                each(<span class="hljs-keyword">this</span>.zones, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">zone, i</span>) </span>{
                    props.push([
                        <span class="hljs-string">'zone-graph-'</span> + i,
                        <span class="hljs-string">'highcharts-graph highcharts-zone-graph-'</span> + i + <span class="hljs-string">' '</span> + (zone.className || <span class="hljs-string">''</span>),
                        zone.color || series.color,
                        zone.dashStyle || options.dashStyle
                    ]);
                });
                each(props, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, i</span>) </span>{
                    <span class="hljs-keyword">var</span> graphKey = prop[<span class="hljs-number">0</span>],
                        graph = series[graphKey],
                        attribs;
                    <span class="hljs-keyword">if</span> (graph) {
                        graph.endX = graphPath.xMap;
                        graph.animate({
                            <span class="hljs-attr">d</span>: graphPath
                        });
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (graphPath.length) {
                        series[graphKey] = series.chart.renderer.path(graphPath)
                            .addClass(prop[<span class="hljs-number">1</span>])
                            .attr({
                                <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                            })
                            .add(series.group);
                        attribs = {
                            <span class="hljs-string">'stroke'</span>: prop[<span class="hljs-number">2</span>],
                            <span class="hljs-string">'stroke-width'</span>: options.lineWidth,
                            <span class="hljs-string">'fill'</span>: (series.fillGraph &amp;&amp; series.color) || <span class="hljs-string">'none'</span>
                        };
                        <span class="hljs-keyword">if</span> (prop[<span class="hljs-number">3</span>]) {
                            attribs.dashstyle = prop[<span class="hljs-number">3</span>];
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.linecap !== <span class="hljs-string">'square'</span>) {
                            attribs[<span class="hljs-string">'stroke-linecap'</span>] = attribs[<span class="hljs-string">'stroke-linejoin'</span>] = <span class="hljs-string">'round'</span>;
                        }
                        graph = series[graphKey]
                            .attr(attribs)
                            .shadow((i &lt; <span class="hljs-number">2</span>) &amp;&amp; options.shadow);
                    }
                    <span class="hljs-keyword">if</span> (graph) {
                        graph.startX = graphPath.xMap;
                        graph.isArea = graphPath.isArea;
                    }
                });
            },
            <span class="hljs-attr">applyZones</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    renderer = chart.renderer,
                    zones = <span class="hljs-keyword">this</span>.zones,
                    translatedFrom,
                    translatedTo,
                    clips = <span class="hljs-keyword">this</span>.clips || [],
                    clipAttr,
                    graph = <span class="hljs-keyword">this</span>.graph,
                    area = <span class="hljs-keyword">this</span>.area,
                    chartSizeMax = <span class="hljs-built_in">Math</span>.max(chart.chartWidth, chart.chartHeight),
                    axis = <span class="hljs-keyword">this</span>[(<span class="hljs-keyword">this</span>.zoneAxis || <span class="hljs-string">'y'</span>) + <span class="hljs-string">'Axis'</span>],
                    extremes,
                    reversed,
                    inverted = chart.inverted,
                    horiz,
                    pxRange,
                    pxPosMin,
                    pxPosMax,
                    ignoreZones = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (zones.length &amp;&amp; (graph || area) &amp;&amp; axis &amp;&amp; axis.min !== <span class="hljs-literal">undefined</span>) {
                    reversed = axis.reversed;
                    horiz = axis.horiz;
                    <span class="hljs-keyword">if</span> (graph) {
                        graph.hide();
                    }
                    <span class="hljs-keyword">if</span> (area) {
                        area.hide();
                    }
                    extremes = axis.getExtremes();
                    each(zones, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">threshold, i</span>) </span>{
                        translatedFrom = reversed ?
                            (horiz ? chart.plotWidth : <span class="hljs-number">0</span>) :
                            (horiz ? <span class="hljs-number">0</span> : axis.toPixels(extremes.min));
                        translatedFrom = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(pick(translatedTo, translatedFrom), <span class="hljs-number">0</span>), chartSizeMax);
                        translatedTo = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.round(axis.toPixels(pick(threshold.value, extremes.max), <span class="hljs-literal">true</span>)), <span class="hljs-number">0</span>), chartSizeMax);
                        <span class="hljs-keyword">if</span> (ignoreZones) {
                            translatedFrom = translatedTo = axis.toPixels(extremes.max);
                        }
                        pxRange = <span class="hljs-built_in">Math</span>.abs(translatedFrom - translatedTo);
                        pxPosMin = <span class="hljs-built_in">Math</span>.min(translatedFrom, translatedTo);
                        pxPosMax = <span class="hljs-built_in">Math</span>.max(translatedFrom, translatedTo);
                        <span class="hljs-keyword">if</span> (axis.isXAxis) {
                            clipAttr = {
                                <span class="hljs-attr">x</span>: inverted ? pxPosMax : pxPosMin,
                                <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
                                <span class="hljs-attr">width</span>: pxRange,
                                <span class="hljs-attr">height</span>: chartSizeMax
                            };
                            <span class="hljs-keyword">if</span> (!horiz) {
                                clipAttr.x = chart.plotHeight - clipAttr.x;
                            }
                        } <span class="hljs-keyword">else</span> {
                            clipAttr = {
                                <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                                <span class="hljs-attr">y</span>: inverted ? pxPosMax : pxPosMin,
                                <span class="hljs-attr">width</span>: chartSizeMax,
                                <span class="hljs-attr">height</span>: pxRange
                            };
                            <span class="hljs-keyword">if</span> (horiz) {
                                clipAttr.y = chart.plotWidth - clipAttr.y;
                            }
                        }
                        <span class="hljs-keyword">if</span> (inverted &amp;&amp; renderer.isVML) {
                            <span class="hljs-keyword">if</span> (axis.isXAxis) {
                                clipAttr = {
                                    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                                    <span class="hljs-attr">y</span>: reversed ? pxPosMin : pxPosMax,
                                    <span class="hljs-attr">height</span>: clipAttr.width,
                                    <span class="hljs-attr">width</span>: chart.chartWidth
                                };
                            } <span class="hljs-keyword">else</span> {
                                clipAttr = {
                                    <span class="hljs-attr">x</span>: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                                    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
                                    <span class="hljs-attr">width</span>: clipAttr.height,
                                    <span class="hljs-attr">height</span>: chart.chartHeight
                                };
                            }
                        }
                        <span class="hljs-keyword">if</span> (clips[i]) {
                            clips[i].animate(clipAttr);
                        } <span class="hljs-keyword">else</span> {
                            clips[i] = renderer.clipRect(clipAttr);
                            <span class="hljs-keyword">if</span> (graph) {
                                series[<span class="hljs-string">'zone-graph-'</span> + i].clip(clips[i]);
                            }
                            <span class="hljs-keyword">if</span> (area) {
                                series[<span class="hljs-string">'zone-area-'</span> + i].clip(clips[i]);
                            }
                        }
                        ignoreZones = threshold.value &gt; extremes.max;
                    });
                    <span class="hljs-keyword">this</span>.clips = clips;
                }
            },
            <span class="hljs-attr">invertGroups</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inverted</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    remover;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInvert</span>(<span class="hljs-params"></span>) </span>{
                    each([<span class="hljs-string">'group'</span>, <span class="hljs-string">'markerGroup'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">groupName</span>) </span>{
                        <span class="hljs-keyword">if</span> (series[groupName]) {
                            series[groupName].width = series.yAxis.len;
                            series[groupName].height = series.xAxis.len;
                            series[groupName].invert(inverted);
                        }
                    });
                }
                <span class="hljs-keyword">if</span> (!series.xAxis) {
                    <span class="hljs-keyword">return</span>;
                }
                remover = addEvent(chart, <span class="hljs-string">'resize'</span>, setInvert);
                addEvent(series, <span class="hljs-string">'destroy'</span>, remover);
                setInvert(inverted);
                series.invertGroups = setInvert;
            },
            <span class="hljs-attr">plotGroup</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop, name, visibility, zIndex, parent</span>) </span>{
                <span class="hljs-keyword">var</span> group = <span class="hljs-keyword">this</span>[prop],
                    isNew = !group;
                <span class="hljs-keyword">if</span> (isNew) {
                    <span class="hljs-keyword">this</span>[prop] = group = <span class="hljs-keyword">this</span>.chart.renderer.g(name)
                        .attr({
                            <span class="hljs-attr">zIndex</span>: zIndex || <span class="hljs-number">0.1</span>
                        })
                        .add(parent);
                    group.addClass(<span class="hljs-string">'highcharts-series-'</span> + <span class="hljs-keyword">this</span>.index + <span class="hljs-string">' highcharts-'</span> + <span class="hljs-keyword">this</span>.type + <span class="hljs-string">'-series highcharts-color-'</span> + <span class="hljs-keyword">this</span>.colorIndex +
                        <span class="hljs-string">' '</span> + (<span class="hljs-keyword">this</span>.options.className || <span class="hljs-string">''</span>));
                }
                group.attr({
                    <span class="hljs-attr">visibility</span>: visibility
                })[isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>](<span class="hljs-keyword">this</span>.getPlotBox());
                <span class="hljs-keyword">return</span> group;
            },
            <span class="hljs-attr">getPlotBox</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    xAxis = <span class="hljs-keyword">this</span>.xAxis,
                    yAxis = <span class="hljs-keyword">this</span>.yAxis;
                <span class="hljs-keyword">if</span> (chart.inverted) {
                    xAxis = yAxis;
                    yAxis = <span class="hljs-keyword">this</span>.xAxis;
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">translateX</span>: xAxis ? xAxis.left : chart.plotLeft,
                    <span class="hljs-attr">translateY</span>: yAxis ? yAxis.top : chart.plotTop,
                    <span class="hljs-attr">scaleX</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">scaleY</span>: <span class="hljs-number">1</span>
                };
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    group,
                    options = series.options,
                    animDuration = !!series.animate &amp;&amp; chart.renderer.isSVG &amp;&amp; animObject(options.animation).duration,
                    visibility = series.visible ? <span class="hljs-string">'inherit'</span> : <span class="hljs-string">'hidden'</span>,
                    zIndex = options.zIndex,
                    hasRendered = series.hasRendered,
                    chartSeriesGroup = chart.seriesGroup,
                    inverted = chart.inverted;
                group = series.plotGroup(
                    <span class="hljs-string">'group'</span>,
                    <span class="hljs-string">'series'</span>,
                    visibility,
                    zIndex,
                    chartSeriesGroup
                );
                series.markerGroup = series.plotGroup(
                    <span class="hljs-string">'markerGroup'</span>,
                    <span class="hljs-string">'markers'</span>,
                    visibility,
                    zIndex,
                    chartSeriesGroup
                );
                <span class="hljs-keyword">if</span> (animDuration) {
                    series.animate(<span class="hljs-literal">true</span>);
                }
                group.inverted = series.isCartesian ? inverted : <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (series.drawGraph) {
                    series.drawGraph();
                    series.applyZones();
                }
                <span class="hljs-keyword">if</span> (series.drawDataLabels) {
                    series.drawDataLabels();
                }
                <span class="hljs-keyword">if</span> (series.visible) {
                    series.drawPoints();
                }
                <span class="hljs-keyword">if</span> (series.drawTracker &amp;&amp; series.options.enableMouseTracking !== <span class="hljs-literal">false</span>) {
                    series.drawTracker();
                }
                series.invertGroups(inverted);
                <span class="hljs-keyword">if</span> (options.clip !== <span class="hljs-literal">false</span> &amp;&amp; !series.sharedClipKey &amp;&amp; !hasRendered) {
                    group.clip(chart.clipRect);
                }
                <span class="hljs-keyword">if</span> (animDuration) {
                    series.animate();
                }
                <span class="hljs-keyword">if</span> (!hasRendered) {
                    series.animationTimeout = syncTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        series.afterAnimate();
                    }, animDuration);
                }
                series.isDirty = <span class="hljs-literal">false</span>;
                series.hasRendered = <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">redraw</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    wasDirty = series.isDirty || series.isDirtyData,
                    group = series.group,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis;
                <span class="hljs-keyword">if</span> (group) {
                    <span class="hljs-keyword">if</span> (chart.inverted) {
                        group.attr({
                            <span class="hljs-attr">width</span>: chart.plotWidth,
                            <span class="hljs-attr">height</span>: chart.plotHeight
                        });
                    }
                    group.animate({
                        <span class="hljs-attr">translateX</span>: pick(xAxis &amp;&amp; xAxis.left, chart.plotLeft),
                        <span class="hljs-attr">translateY</span>: pick(yAxis &amp;&amp; yAxis.top, chart.plotTop)
                    });
                }
                series.translate();
                series.render();
                <span class="hljs-keyword">if</span> (wasDirty) {
                    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.kdTree;
                }
            },
            <span class="hljs-attr">kdDimensions</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">kdAxisArray</span>: [<span class="hljs-string">'clientX'</span>, <span class="hljs-string">'plotY'</span>],
            <span class="hljs-attr">searchPoint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, compareX</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    inverted = series.chart.inverted;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchKDTree({
                    <span class="hljs-attr">clientX</span>: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                    <span class="hljs-attr">plotY</span>: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
                }, compareX);
            },
            <span class="hljs-attr">buildKDTree</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.buildingKdTree = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    dimensions = series.kdDimensions;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_kdtree</span>(<span class="hljs-params">points, depth, dimensions</span>) </span>{
                    <span class="hljs-keyword">var</span> axis,
                        median,
                        length = points &amp;&amp; points.length;
                    <span class="hljs-keyword">if</span> (length) {
                        axis = series.kdAxisArray[depth % dimensions];
                        points.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                            <span class="hljs-keyword">return</span> a[axis] - b[axis];
                        });
                        median = <span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>);
                        <span class="hljs-keyword">return</span> {
                            <span class="hljs-attr">point</span>: points[median],
                            <span class="hljs-attr">left</span>: _kdtree(points.slice(<span class="hljs-number">0</span>, median), depth + <span class="hljs-number">1</span>, dimensions),
                            <span class="hljs-attr">right</span>: _kdtree(points.slice(median + <span class="hljs-number">1</span>), depth + <span class="hljs-number">1</span>, dimensions)
                        };
                    }
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startRecursive</span>(<span class="hljs-params"></span>) </span>{
                    series.kdTree = _kdtree(
                        series.getValidPoints(
                            <span class="hljs-literal">null</span>, !series.directTouch
                        ),
                        dimensions,
                        dimensions
                    );
                    series.buildingKdTree = <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">delete</span> series.kdTree;
                syncTimeout(startRecursive, series.options.kdNow ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">searchKDTree</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, compareX</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    kdX = <span class="hljs-keyword">this</span>.kdAxisArray[<span class="hljs-number">0</span>],
                    kdY = <span class="hljs-keyword">this</span>.kdAxisArray[<span class="hljs-number">1</span>],
                    kdComparer = compareX ? <span class="hljs-string">'distX'</span> : <span class="hljs-string">'dist'</span>;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDistance</span>(<span class="hljs-params">p1, p2</span>) </span>{
                    <span class="hljs-keyword">var</span> x = (defined(p1[kdX]) &amp;&amp; defined(p2[kdX])) ? <span class="hljs-built_in">Math</span>.pow(p1[kdX] - p2[kdX], <span class="hljs-number">2</span>) : <span class="hljs-literal">null</span>,
                        y = (defined(p1[kdY]) &amp;&amp; defined(p2[kdY])) ? <span class="hljs-built_in">Math</span>.pow(p1[kdY] - p2[kdY], <span class="hljs-number">2</span>) : <span class="hljs-literal">null</span>,
                        r = (x || <span class="hljs-number">0</span>) + (y || <span class="hljs-number">0</span>);
                    p2.dist = defined(r) ? <span class="hljs-built_in">Math</span>.sqrt(r) : <span class="hljs-built_in">Number</span>.MAX_VALUE;
                    p2.distX = defined(x) ? <span class="hljs-built_in">Math</span>.sqrt(x) : <span class="hljs-built_in">Number</span>.MAX_VALUE;
                }

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_search</span>(<span class="hljs-params">search, tree, depth, dimensions</span>) </span>{
                    <span class="hljs-keyword">var</span> point = tree.point,
                        axis = series.kdAxisArray[depth % dimensions],
                        tdist,
                        sideA,
                        sideB,
                        ret = point,
                        nPoint1,
                        nPoint2;
                    setDistance(search, point);
                    tdist = search[axis] - point[axis];
                    sideA = tdist &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'right'</span>;
                    sideB = tdist &lt; <span class="hljs-number">0</span> ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>;
                    <span class="hljs-keyword">if</span> (tree[sideA]) {
                        nPoint1 = _search(search, tree[sideA], depth + <span class="hljs-number">1</span>, dimensions);
                        ret = (nPoint1[kdComparer] &lt; ret[kdComparer] ? nPoint1 : point);
                    }
                    <span class="hljs-keyword">if</span> (tree[sideB]) {
                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.sqrt(tdist * tdist) &lt; ret[kdComparer]) {
                            nPoint2 = _search(search, tree[sideB], depth + <span class="hljs-number">1</span>, dimensions);
                            ret = (nPoint2[kdComparer] &lt; ret[kdComparer] ? nPoint2 : ret);
                        }
                    }
                    <span class="hljs-keyword">return</span> ret;
                }
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.kdTree &amp;&amp; !<span class="hljs-keyword">this</span>.buildingKdTree) {
                    <span class="hljs-keyword">this</span>.buildKDTree();
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.kdTree) {
                    <span class="hljs-keyword">return</span> _search(point,
                        <span class="hljs-keyword">this</span>.kdTree, <span class="hljs-keyword">this</span>.kdDimensions, <span class="hljs-keyword">this</span>.kdDimensions);
                }
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Axis = H.Axis,
            Chart = H.Chart,
            correctFloat = H.correctFloat,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            each = H.each,
            format = H.format,
            pick = H.pick,
            Series = H.Series;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StackItem</span>(<span class="hljs-params">axis, options, isNegative, x, stackOption</span>) </span>{
            <span class="hljs-keyword">var</span> inverted = axis.chart.inverted;
            <span class="hljs-keyword">this</span>.axis = axis;
            <span class="hljs-keyword">this</span>.isNegative = isNegative;
            <span class="hljs-keyword">this</span>.options = options;
            <span class="hljs-keyword">this</span>.x = x;
            <span class="hljs-keyword">this</span>.total = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">this</span>.points = {};
            <span class="hljs-keyword">this</span>.stack = stackOption;
            <span class="hljs-keyword">this</span>.leftCliff = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">this</span>.rightCliff = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">this</span>.alignOptions = {
                <span class="hljs-attr">align</span>: options.align ||
                    (inverted ? (isNegative ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'right'</span>) : <span class="hljs-string">'center'</span>),
                <span class="hljs-attr">verticalAlign</span>: options.verticalAlign ||
                    (inverted ? <span class="hljs-string">'middle'</span> : (isNegative ? <span class="hljs-string">'bottom'</span> : <span class="hljs-string">'top'</span>)),
                <span class="hljs-attr">y</span>: pick(options.y, inverted ? <span class="hljs-number">4</span> : (isNegative ? <span class="hljs-number">14</span> : <span class="hljs-number">-6</span>)),
                <span class="hljs-attr">x</span>: pick(options.x, inverted ? (isNegative ? <span class="hljs-number">-6</span> : <span class="hljs-number">6</span>) : <span class="hljs-number">0</span>)
            };
            <span class="hljs-keyword">this</span>.textAlign = options.textAlign ||
                (inverted ? (isNegative ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>) : <span class="hljs-string">'center'</span>);
        }
        StackItem.prototype = {
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                destroyObjectProperties(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.axis);
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">group</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    formatOption = options.format,
                    str = formatOption ?
                    format(formatOption, <span class="hljs-keyword">this</span>) :
                    options.formatter.call(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.label) {
                    <span class="hljs-keyword">this</span>.label.attr({
                        <span class="hljs-attr">text</span>: str,
                        <span class="hljs-attr">visibility</span>: <span class="hljs-string">'hidden'</span>
                    });
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.label =
                        <span class="hljs-keyword">this</span>.axis.chart.renderer.text(str, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, options.useHTML)
                        .css(options.style)
                        .attr({
                            <span class="hljs-attr">align</span>: <span class="hljs-keyword">this</span>.textAlign,
                            <span class="hljs-attr">rotation</span>: options.rotation,
                            <span class="hljs-attr">visibility</span>: <span class="hljs-string">'hidden'</span>
                        })
                        .add(group);
                }
            },
            <span class="hljs-attr">setOffset</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xOffset, xWidth</span>) </span>{
                <span class="hljs-keyword">var</span> stackItem = <span class="hljs-keyword">this</span>,
                    axis = stackItem.axis,
                    chart = axis.chart,
                    inverted = chart.inverted,
                    reversed = axis.reversed,
                    neg = (<span class="hljs-keyword">this</span>.isNegative &amp;&amp; !reversed) ||
                    (!<span class="hljs-keyword">this</span>.isNegative &amp;&amp; reversed),
                    y = axis.translate(
                        axis.usePercentage ? <span class="hljs-number">100</span> : <span class="hljs-keyword">this</span>.total,
                        <span class="hljs-number">0</span>,
                        <span class="hljs-number">0</span>,
                        <span class="hljs-number">0</span>,
                        <span class="hljs-number">1</span>
                    ),
                    yZero = axis.translate(<span class="hljs-number">0</span>),
                    h = <span class="hljs-built_in">Math</span>.abs(y - yZero),
                    x = chart.xAxis[<span class="hljs-number">0</span>].translate(<span class="hljs-keyword">this</span>.x) + xOffset,
                    plotHeight = chart.plotHeight,
                    stackBox = {
                        <span class="hljs-attr">x</span>: inverted ? (neg ? y : y - h) : x,
                        <span class="hljs-attr">y</span>: inverted ?
                            plotHeight - x - xWidth : (neg ? (plotHeight - y - h) :
                                plotHeight - y),
                        <span class="hljs-attr">width</span>: inverted ? h : xWidth,
                        <span class="hljs-attr">height</span>: inverted ? xWidth : h
                    },
                    label = <span class="hljs-keyword">this</span>.label,
                    alignAttr;
                <span class="hljs-keyword">if</span> (label) {
                    label.align(<span class="hljs-keyword">this</span>.alignOptions, <span class="hljs-literal">null</span>, stackBox);
                    alignAttr = label.alignAttr;
                    label[
                        <span class="hljs-keyword">this</span>.options.crop === <span class="hljs-literal">false</span> || chart.isInsidePlot(
                            alignAttr.x,
                            alignAttr.y
                        ) ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>](<span class="hljs-literal">true</span>);
                }
            }
        };
        Chart.prototype.getStacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>;
            each(chart.yAxis, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                <span class="hljs-keyword">if</span> (axis.stacks &amp;&amp; axis.hasVisibleSeries) {
                    axis.oldStacks = axis.stacks;
                }
            });
            each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                <span class="hljs-keyword">if</span> (series.options.stacking &amp;&amp; (series.visible === <span class="hljs-literal">true</span> ||
                        chart.options.chart.ignoreHiddenSeries === <span class="hljs-literal">false</span>)) {
                    series.stackKey = series.type + pick(series.options.stack, <span class="hljs-string">''</span>);
                }
            });
        };
        Axis.prototype.buildStacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> axisSeries = <span class="hljs-keyword">this</span>.series,
                series,
                reversedStacks = pick(<span class="hljs-keyword">this</span>.options.reversedStacks, <span class="hljs-literal">true</span>),
                len = axisSeries.length,
                i;
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isXAxis) {
                <span class="hljs-keyword">this</span>.usePercentage = <span class="hljs-literal">false</span>;
                i = len;
                <span class="hljs-keyword">while</span> (i--) {
                    axisSeries[reversedStacks ? i : len - i - <span class="hljs-number">1</span>].setStackedPoints();
                }
                i = len;
                <span class="hljs-keyword">while</span> (i--) {
                    series = axisSeries[reversedStacks ? i : len - i - <span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span> (series.setStackCliffs) {
                        series.setStackCliffs();
                    }
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.usePercentage) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                        axisSeries[i].setPercentStacks();
                    }
                }
            }
        };
        Axis.prototype.renderStackTotals = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                chart = axis.chart,
                renderer = chart.renderer,
                stacks = axis.stacks,
                stackKey,
                oneStack,
                stackCategory,
                stackTotalGroup = axis.stackTotalGroup;
            <span class="hljs-keyword">if</span> (!stackTotalGroup) {
                axis.stackTotalGroup = stackTotalGroup =
                    renderer.g(<span class="hljs-string">'stack-labels'</span>)
                    .attr({
                        <span class="hljs-attr">visibility</span>: <span class="hljs-string">'visible'</span>,
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">6</span>
                    })
                    .add();
            }
            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
            <span class="hljs-keyword">for</span> (stackKey <span class="hljs-keyword">in</span> stacks) {
                oneStack = stacks[stackKey];
                <span class="hljs-keyword">for</span> (stackCategory <span class="hljs-keyword">in</span> oneStack) {
                    oneStack[stackCategory].render(stackTotalGroup);
                }
            }
        };
        Axis.prototype.resetStacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> stacks = <span class="hljs-keyword">this</span>.stacks,
                type,
                i;
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isXAxis) {
                <span class="hljs-keyword">for</span> (type <span class="hljs-keyword">in</span> stacks) {
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> stacks[type]) {
                        <span class="hljs-keyword">if</span> (stacks[type][i].touched &lt; <span class="hljs-keyword">this</span>.stacksTouched) {
                            stacks[type][i].destroy();
                            <span class="hljs-keyword">delete</span> stacks[type][i];
                        } <span class="hljs-keyword">else</span> {
                            stacks[type][i].total = <span class="hljs-literal">null</span>;
                            stacks[type][i].cum = <span class="hljs-literal">null</span>;
                        }
                    }
                }
            }
        };
        Axis.prototype.cleanStacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> stacks, type, i;
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isXAxis) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.oldStacks) {
                    stacks = <span class="hljs-keyword">this</span>.stacks = <span class="hljs-keyword">this</span>.oldStacks;
                }
                <span class="hljs-keyword">for</span> (type <span class="hljs-keyword">in</span> stacks) {
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> stacks[type]) {
                        stacks[type][i].cum = stacks[type][i].total;
                    }
                }
            }
        };
        Series.prototype.setStackedPoints = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.options.stacking || (<span class="hljs-keyword">this</span>.visible !== <span class="hljs-literal">true</span> &amp;&amp;
                    <span class="hljs-keyword">this</span>.chart.options.chart.ignoreHiddenSeries !== <span class="hljs-literal">false</span>)) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                xData = series.processedXData,
                yData = series.processedYData,
                stackedYData = [],
                yDataLength = yData.length,
                seriesOptions = series.options,
                threshold = seriesOptions.threshold,
                stackThreshold = seriesOptions.startFromThreshold ? threshold : <span class="hljs-number">0</span>,
                stackOption = seriesOptions.stack,
                stacking = seriesOptions.stacking,
                stackKey = series.stackKey,
                negKey = <span class="hljs-string">'-'</span> + stackKey,
                negStacks = series.negStacks,
                yAxis = series.yAxis,
                stacks = yAxis.stacks,
                oldStacks = yAxis.oldStacks,
                stackIndicator,
                isNegative,
                stack,
                other,
                key,
                pointKey,
                i,
                x,
                y;
            yAxis.stacksTouched += <span class="hljs-number">1</span>;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; yDataLength; i++) {
                x = xData[i];
                y = yData[i];
                stackIndicator = series.getStackIndicator(
                    stackIndicator,
                    x,
                    series.index
                );
                pointKey = stackIndicator.key;
                isNegative = negStacks &amp;&amp; y &lt; (stackThreshold ? <span class="hljs-number">0</span> : threshold);
                key = isNegative ? negKey : stackKey;
                <span class="hljs-keyword">if</span> (!stacks[key]) {
                    stacks[key] = {};
                }
                <span class="hljs-keyword">if</span> (!stacks[key][x]) {
                    <span class="hljs-keyword">if</span> (oldStacks[key] &amp;&amp; oldStacks[key][x]) {
                        stacks[key][x] = oldStacks[key][x];
                        stacks[key][x].total = <span class="hljs-literal">null</span>;
                    } <span class="hljs-keyword">else</span> {
                        stacks[key][x] = <span class="hljs-keyword">new</span> StackItem(
                            yAxis,
                            yAxis.options.stackLabels,
                            isNegative,
                            x,
                            stackOption
                        );
                    }
                }
                stack = stacks[key][x];
                <span class="hljs-keyword">if</span> (y !== <span class="hljs-literal">null</span>) {
                    stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];
                    <span class="hljs-keyword">if</span> (!defined(stack.cum)) {
                        stack.base = pointKey;
                    }
                    stack.touched = yAxis.stacksTouched;
                    <span class="hljs-keyword">if</span> (stackIndicator.index &gt; <span class="hljs-number">0</span> &amp;&amp; series.singleStacks === <span class="hljs-literal">false</span>) {
                        stack.points[pointKey][<span class="hljs-number">0</span>] =
                            stack.points[series.index + <span class="hljs-string">','</span> + x + <span class="hljs-string">',0'</span>][<span class="hljs-number">0</span>];
                    }
                }
                <span class="hljs-keyword">if</span> (stacking === <span class="hljs-string">'percent'</span>) {
                    other = isNegative ? stackKey : negKey;
                    <span class="hljs-keyword">if</span> (negStacks &amp;&amp; stacks[other] &amp;&amp; stacks[other][x]) {
                        other = stacks[other][x];
                        stack.total = other.total =
                            <span class="hljs-built_in">Math</span>.max(other.total, stack.total) + <span class="hljs-built_in">Math</span>.abs(y) || <span class="hljs-number">0</span>;
                    } <span class="hljs-keyword">else</span> {
                        stack.total = correctFloat(stack.total + (<span class="hljs-built_in">Math</span>.abs(y) || <span class="hljs-number">0</span>));
                    }
                } <span class="hljs-keyword">else</span> {
                    stack.total = correctFloat(stack.total + (y || <span class="hljs-number">0</span>));
                }
                stack.cum = pick(stack.cum, stackThreshold) + (y || <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span> (y !== <span class="hljs-literal">null</span>) {
                    stack.points[pointKey].push(stack.cum);
                    stackedYData[i] = stack.cum;
                }
            }
            <span class="hljs-keyword">if</span> (stacking === <span class="hljs-string">'percent'</span>) {
                yAxis.usePercentage = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">this</span>.stackedYData = stackedYData;
            yAxis.oldStacks = {};
        };
        Series.prototype.setPercentStacks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                stackKey = series.stackKey,
                stacks = series.yAxis.stacks,
                processedXData = series.processedXData,
                stackIndicator;
            each([stackKey, <span class="hljs-string">'-'</span> + stackKey], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                <span class="hljs-keyword">var</span> i = processedXData.length,
                    x,
                    stack,
                    pointExtremes,
                    totalFactor;
                <span class="hljs-keyword">while</span> (i--) {
                    x = processedXData[i];
                    stackIndicator = series.getStackIndicator(
                        stackIndicator,
                        x,
                        series.index,
                        key
                    );
                    stack = stacks[key] &amp;&amp; stacks[key][x];
                    pointExtremes = stack &amp;&amp; stack.points[stackIndicator.key];
                    <span class="hljs-keyword">if</span> (pointExtremes) {
                        totalFactor = stack.total ? <span class="hljs-number">100</span> / stack.total : <span class="hljs-number">0</span>;
                        pointExtremes[<span class="hljs-number">0</span>] = correctFloat(pointExtremes[<span class="hljs-number">0</span>] * totalFactor);
                        pointExtremes[<span class="hljs-number">1</span>] = correctFloat(pointExtremes[<span class="hljs-number">1</span>] * totalFactor);
                        series.stackedYData[i] = pointExtremes[<span class="hljs-number">1</span>];
                    }
                }
            });
        };
        Series.prototype.getStackIndicator = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">stackIndicator, x, index, key</span>) </span>{
            <span class="hljs-keyword">if</span> (!defined(stackIndicator) || stackIndicator.x !== x ||
                (key &amp;&amp; stackIndicator.key !== key)) {
                stackIndicator = {
                    <span class="hljs-attr">x</span>: x,
                    <span class="hljs-attr">index</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">key</span>: key
                };
            } <span class="hljs-keyword">else</span> {
                stackIndicator.index++;
            }
            stackIndicator.key = [index, x, stackIndicator.index].join(<span class="hljs-string">','</span>);
            <span class="hljs-keyword">return</span> stackIndicator;
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            animate = H.animate,
            Axis = H.Axis,
            Chart = H.Chart,
            createElement = H.createElement,
            css = H.css,
            defined = H.defined,
            each = H.each,
            erase = H.erase,
            extend = H.extend,
            fireEvent = H.fireEvent,
            inArray = H.inArray,
            isNumber = H.isNumber,
            isObject = H.isObject,
            merge = H.merge,
            pick = H.pick,
            Point = H.Point,
            Series = H.Series,
            seriesTypes = H.seriesTypes,
            setAnimation = H.setAnimation,
            splat = H.splat;
        extend(Chart.prototype, {
            <span class="hljs-attr">addSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, redraw, animation</span>) </span>{
                <span class="hljs-keyword">var</span> series,
                    chart = <span class="hljs-keyword">this</span>;
                <span class="hljs-keyword">if</span> (options) {
                    redraw = pick(redraw, <span class="hljs-literal">true</span>);
                    fireEvent(chart, <span class="hljs-string">'addSeries'</span>, {
                        <span class="hljs-attr">options</span>: options
                    }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        series = chart.initSeries(options);
                        chart.isDirtyLegend = <span class="hljs-literal">true</span>;
                        chart.linkSeries();
                        <span class="hljs-keyword">if</span> (redraw) {
                            chart.redraw(animation);
                        }
                    });
                }
                <span class="hljs-keyword">return</span> series;
            },
            <span class="hljs-attr">addAxis</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, isX, redraw, animation</span>) </span>{
                <span class="hljs-keyword">var</span> key = isX ? <span class="hljs-string">'xAxis'</span> : <span class="hljs-string">'yAxis'</span>,
                    chartOptions = <span class="hljs-keyword">this</span>.options,
                    userOptions = merge(options, {
                        <span class="hljs-attr">index</span>: <span class="hljs-keyword">this</span>[key].length,
                        <span class="hljs-attr">isX</span>: isX
                    });
                <span class="hljs-keyword">new</span> Axis(<span class="hljs-keyword">this</span>, userOptions);
                chartOptions[key] = splat(chartOptions[key] || {});
                chartOptions[key].push(userOptions);
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    <span class="hljs-keyword">this</span>.redraw(animation);
                }
            },
            <span class="hljs-attr">showLoading</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">str</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    options = chart.options,
                    loadingDiv = chart.loadingDiv,
                    loadingOptions = options.loading,
                    setLoadingSize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (loadingDiv) {
                            css(loadingDiv, {
                                <span class="hljs-attr">left</span>: chart.plotLeft + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">top</span>: chart.plotTop + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">width</span>: chart.plotWidth + <span class="hljs-string">'px'</span>,
                                <span class="hljs-attr">height</span>: chart.plotHeight + <span class="hljs-string">'px'</span>
                            });
                        }
                    };
                <span class="hljs-keyword">if</span> (!loadingDiv) {
                    chart.loadingDiv = loadingDiv = createElement(<span class="hljs-string">'div'</span>, {
                        <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-loading highcharts-loading-hidden'</span>
                    }, <span class="hljs-literal">null</span>, chart.container);
                    chart.loadingSpan = createElement(
                        <span class="hljs-string">'span'</span>, {
                            <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-loading-inner'</span>
                        },
                        <span class="hljs-literal">null</span>,
                        loadingDiv
                    );
                    addEvent(chart, <span class="hljs-string">'redraw'</span>, setLoadingSize);
                }
                loadingDiv.className = <span class="hljs-string">'highcharts-loading'</span>;
                chart.loadingSpan.innerHTML = str || options.lang.loading;
                css(loadingDiv, extend(loadingOptions.style, {
                    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">10</span>
                }));
                css(chart.loadingSpan, loadingOptions.labelStyle);
                <span class="hljs-keyword">if</span> (!chart.loadingShown) {
                    css(loadingDiv, {
                        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">display</span>: <span class="hljs-string">''</span>
                    });
                    animate(loadingDiv, {
                        <span class="hljs-attr">opacity</span>: loadingOptions.style.opacity || <span class="hljs-number">0.5</span>
                    }, {
                        <span class="hljs-attr">duration</span>: loadingOptions.showDuration || <span class="hljs-number">0</span>
                    });
                }
                chart.loadingShown = <span class="hljs-literal">true</span>;
                setLoadingSize();
            },
            <span class="hljs-attr">hideLoading</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    loadingDiv = <span class="hljs-keyword">this</span>.loadingDiv;
                <span class="hljs-keyword">if</span> (loadingDiv) {
                    loadingDiv.className = <span class="hljs-string">'highcharts-loading highcharts-loading-hidden'</span>;
                    animate(loadingDiv, {
                        <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>
                    }, {
                        <span class="hljs-attr">duration</span>: options.loading.hideDuration || <span class="hljs-number">100</span>,
                        <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            css(loadingDiv, {
                                <span class="hljs-attr">display</span>: <span class="hljs-string">'none'</span>
                            });
                        }
                    });
                }
                <span class="hljs-keyword">this</span>.loadingShown = <span class="hljs-literal">false</span>;
            },
            <span class="hljs-attr">propsRequireDirtyBox</span>: [<span class="hljs-string">'backgroundColor'</span>, <span class="hljs-string">'borderColor'</span>, <span class="hljs-string">'borderWidth'</span>, <span class="hljs-string">'margin'</span>, <span class="hljs-string">'marginTop'</span>, <span class="hljs-string">'marginRight'</span>,
                <span class="hljs-string">'marginBottom'</span>, <span class="hljs-string">'marginLeft'</span>, <span class="hljs-string">'spacing'</span>, <span class="hljs-string">'spacingTop'</span>, <span class="hljs-string">'spacingRight'</span>, <span class="hljs-string">'spacingBottom'</span>, <span class="hljs-string">'spacingLeft'</span>,
                <span class="hljs-string">'borderRadius'</span>, <span class="hljs-string">'plotBackgroundColor'</span>, <span class="hljs-string">'plotBackgroundImage'</span>, <span class="hljs-string">'plotBorderColor'</span>, <span class="hljs-string">'plotBorderWidth'</span>,
                <span class="hljs-string">'plotShadow'</span>, <span class="hljs-string">'shadow'</span>
            ],
            <span class="hljs-attr">propsRequireUpdateSeries</span>: [<span class="hljs-string">'chart.inverted'</span>, <span class="hljs-string">'chart.polar'</span>,
                <span class="hljs-string">'chart.ignoreHiddenSeries'</span>, <span class="hljs-string">'chart.type'</span>, <span class="hljs-string">'colors'</span>, <span class="hljs-string">'plotOptions'</span>
            ],
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> key,
                    adders = {
                        <span class="hljs-attr">credits</span>: <span class="hljs-string">'addCredits'</span>,
                        <span class="hljs-attr">title</span>: <span class="hljs-string">'setTitle'</span>,
                        <span class="hljs-attr">subtitle</span>: <span class="hljs-string">'setSubtitle'</span>
                    },
                    optionsChart = options.chart,
                    updateAllAxes,
                    updateAllSeries,
                    newWidth,
                    newHeight;
                <span class="hljs-keyword">if</span> (optionsChart) {
                    merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options.chart, optionsChart);
                    <span class="hljs-keyword">if</span> (<span class="hljs-string">'className'</span> <span class="hljs-keyword">in</span> optionsChart) {
                        <span class="hljs-keyword">this</span>.setClassName(optionsChart.className);
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-string">'inverted'</span> <span class="hljs-keyword">in</span> optionsChart || <span class="hljs-string">'polar'</span> <span class="hljs-keyword">in</span> optionsChart) {
                        <span class="hljs-keyword">this</span>.propFromSeries();
                        updateAllAxes = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> optionsChart) {
                        <span class="hljs-keyword">if</span> (optionsChart.hasOwnProperty(key)) {
                            <span class="hljs-keyword">if</span> (inArray(<span class="hljs-string">'chart.'</span> + key, <span class="hljs-keyword">this</span>.propsRequireUpdateSeries) !== <span class="hljs-number">-1</span>) {
                                updateAllSeries = <span class="hljs-literal">true</span>;
                            }
                            <span class="hljs-keyword">if</span> (inArray(key, <span class="hljs-keyword">this</span>.propsRequireDirtyBox) !== <span class="hljs-number">-1</span>) {
                                <span class="hljs-keyword">this</span>.isDirtyBox = <span class="hljs-literal">true</span>;
                            }
                        }
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-string">'style'</span> <span class="hljs-keyword">in</span> optionsChart) {
                        <span class="hljs-keyword">this</span>.renderer.setStyle(optionsChart.style);
                    }
                }
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> options) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key] &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>[key].update === <span class="hljs-string">'function'</span>) {
                        <span class="hljs-keyword">this</span>[key].update(options[key], <span class="hljs-literal">false</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>[adders[key]] === <span class="hljs-string">'function'</span>) {
                        <span class="hljs-keyword">this</span>[adders[key]](options[key]);
                    }
                    <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">'chart'</span> &amp;&amp; inArray(key, <span class="hljs-keyword">this</span>.propsRequireUpdateSeries) !== <span class="hljs-number">-1</span>) {
                        updateAllSeries = <span class="hljs-literal">true</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (options.colors) {
                    <span class="hljs-keyword">this</span>.options.colors = options.colors;
                }
                <span class="hljs-keyword">if</span> (options.plotOptions) {
                    merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options.plotOptions, options.plotOptions);
                }
                each([<span class="hljs-string">'xAxis'</span>, <span class="hljs-string">'yAxis'</span>, <span class="hljs-string">'series'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                    <span class="hljs-keyword">if</span> (options[coll]) {
                        each(splat(options[coll]), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newOptions, i</span>) </span>{
                            <span class="hljs-keyword">var</span> item = (
                                defined(newOptions.id) &amp;&amp;
                                <span class="hljs-keyword">this</span>.get(newOptions.id)
                            ) || <span class="hljs-keyword">this</span>[coll][i];
                            <span class="hljs-keyword">if</span> (item &amp;&amp; item.coll === coll) {
                                item.update(newOptions, <span class="hljs-literal">false</span>);
                            }
                        }, <span class="hljs-keyword">this</span>);
                    }
                }, <span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">if</span> (updateAllAxes) {
                    each(<span class="hljs-keyword">this</span>.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        axis.update({}, <span class="hljs-literal">false</span>);
                    });
                }
                <span class="hljs-keyword">if</span> (updateAllSeries) {
                    each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        series.update({}, <span class="hljs-literal">false</span>);
                    });
                }
                <span class="hljs-keyword">if</span> (options.loading) {
                    merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options.loading, options.loading);
                }
                newWidth = optionsChart &amp;&amp; optionsChart.width;
                newHeight = optionsChart &amp;&amp; optionsChart.height;
                <span class="hljs-keyword">if</span> ((isNumber(newWidth) &amp;&amp; newWidth !== <span class="hljs-keyword">this</span>.chartWidth) ||
                    (isNumber(newHeight) &amp;&amp; newHeight !== <span class="hljs-keyword">this</span>.chartHeight)) {
                    <span class="hljs-keyword">this</span>.setSize(newWidth, newHeight);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    <span class="hljs-keyword">this</span>.redraw();
                }
            },
            <span class="hljs-attr">setSubtitle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">this</span>.setTitle(<span class="hljs-literal">undefined</span>, options);
            }
        });
        extend(Point.prototype, {
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, redraw, animation, runEvent</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    graphic = point.graphic,
                    i,
                    chart = series.chart,
                    seriesOptions = series.options;
                redraw = pick(redraw, <span class="hljs-literal">true</span>);

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params"></span>) </span>{
                    point.applyOptions(options);
                    <span class="hljs-keyword">if</span> (point.y === <span class="hljs-literal">null</span> &amp;&amp; graphic) {
                        point.graphic = graphic.destroy();
                    }
                    <span class="hljs-keyword">if</span> (isObject(options, <span class="hljs-literal">true</span>)) {
                        <span class="hljs-keyword">if</span> (graphic &amp;&amp; graphic.element) {
                            <span class="hljs-keyword">if</span> (options &amp;&amp; options.marker &amp;&amp; options.marker.symbol) {
                                point.graphic = graphic.destroy();
                            }
                        }
                        <span class="hljs-keyword">if</span> (options &amp;&amp; options.dataLabels &amp;&amp; point.dataLabel) {
                            point.dataLabel = point.dataLabel.destroy();
                        }
                    }
                    i = point.index;
                    series.updateParallelArrays(point, i);
                    seriesOptions.data[i] = isObject(seriesOptions.data[i], <span class="hljs-literal">true</span>) ? point.options : options;
                    series.isDirty = series.isDirtyData = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">if</span> (!series.fixedBox &amp;&amp; series.hasCartesianSeries) {
                        chart.isDirtyBox = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">if</span> (seriesOptions.legendType === <span class="hljs-string">'point'</span>) {
                        chart.isDirtyLegend = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">if</span> (redraw) {
                        chart.redraw(animation);
                    }
                }
                <span class="hljs-keyword">if</span> (runEvent === <span class="hljs-literal">false</span>) {
                    update();
                } <span class="hljs-keyword">else</span> {
                    point.firePointEvent(<span class="hljs-string">'update'</span>, {
                        <span class="hljs-attr">options</span>: options
                    }, update);
                }
            },
            <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">redraw, animation</span>) </span>{
                <span class="hljs-keyword">this</span>.series.removePoint(inArray(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.series.data), redraw, animation);
            }
        });
        extend(Series.prototype, {
            <span class="hljs-attr">addPoint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options, redraw, shift, animation</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    seriesOptions = series.options,
                    data = series.data,
                    chart = series.chart,
                    xAxis = series.xAxis,
                    names = xAxis &amp;&amp; xAxis.hasNames &amp;&amp; xAxis.names,
                    dataOptions = seriesOptions.data,
                    point,
                    isInTheMiddle,
                    xData = series.xData,
                    i,
                    x;
                redraw = pick(redraw, <span class="hljs-literal">true</span>);
                point = {
                    <span class="hljs-attr">series</span>: series
                };
                series.pointClass.prototype.applyOptions.apply(point, [options]);
                x = point.x;
                i = xData.length;
                <span class="hljs-keyword">if</span> (series.requireSorting &amp;&amp; x &lt; xData[i - <span class="hljs-number">1</span>]) {
                    isInTheMiddle = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">while</span> (i &amp;&amp; xData[i - <span class="hljs-number">1</span>] &gt; x) {
                        i--;
                    }
                }
                series.updateParallelArrays(point, <span class="hljs-string">'splice'</span>, i, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
                series.updateParallelArrays(point, i);
                <span class="hljs-keyword">if</span> (names &amp;&amp; point.name) {
                    names[x] = point.name;
                }
                dataOptions.splice(i, <span class="hljs-number">0</span>, options);
                <span class="hljs-keyword">if</span> (isInTheMiddle) {
                    series.data.splice(i, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>);
                    series.processData();
                }
                <span class="hljs-keyword">if</span> (seriesOptions.legendType === <span class="hljs-string">'point'</span>) {
                    series.generatePoints();
                }
                <span class="hljs-keyword">if</span> (shift) {
                    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] &amp;&amp; data[<span class="hljs-number">0</span>].remove) {
                        data[<span class="hljs-number">0</span>].remove(<span class="hljs-literal">false</span>);
                    } <span class="hljs-keyword">else</span> {
                        data.shift();
                        series.updateParallelArrays(point, <span class="hljs-string">'shift'</span>);
                        dataOptions.shift();
                    }
                }
                series.isDirty = <span class="hljs-literal">true</span>;
                series.isDirtyData = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (redraw) {
                    chart.redraw(animation);
                }
            },
            <span class="hljs-attr">removePoint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, redraw, animation</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    data = series.data,
                    point = data[i],
                    points = series.points,
                    chart = series.chart,
                    remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (points &amp;&amp; points.length === data.length) {
                            points.splice(i, <span class="hljs-number">1</span>);
                        }
                        data.splice(i, <span class="hljs-number">1</span>);
                        series.options.data.splice(i, <span class="hljs-number">1</span>);
                        series.updateParallelArrays(point || {
                            <span class="hljs-attr">series</span>: series
                        }, <span class="hljs-string">'splice'</span>, i, <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (point) {
                            point.destroy();
                        }
                        series.isDirty = <span class="hljs-literal">true</span>;
                        series.isDirtyData = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (redraw) {
                            chart.redraw();
                        }
                    };
                setAnimation(animation, chart);
                redraw = pick(redraw, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (point) {
                    point.firePointEvent(<span class="hljs-string">'remove'</span>, <span class="hljs-literal">null</span>, remove);
                } <span class="hljs-keyword">else</span> {
                    remove();
                }
            },
            <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">redraw, animation, withEvent</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span>(<span class="hljs-params"></span>) </span>{
                    series.destroy();
                    chart.isDirtyLegend = chart.isDirtyBox = <span class="hljs-literal">true</span>;
                    chart.linkSeries();
                    <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                        chart.redraw(animation);
                    }
                }
                <span class="hljs-keyword">if</span> (withEvent !== <span class="hljs-literal">false</span>) {
                    fireEvent(series, <span class="hljs-string">'remove'</span>, <span class="hljs-literal">null</span>, remove);
                } <span class="hljs-keyword">else</span> {
                    remove();
                }
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newOptions, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    oldOptions = <span class="hljs-keyword">this</span>.userOptions,
                    oldType = <span class="hljs-keyword">this</span>.type,
                    newType = newOptions.type || oldOptions.type || chart.options.chart.type,
                    proto = seriesTypes[oldType].prototype,
                    preserve = [<span class="hljs-string">'group'</span>, <span class="hljs-string">'markerGroup'</span>, <span class="hljs-string">'dataLabelsGroup'</span>],
                    n;
                <span class="hljs-keyword">if</span> ((newType &amp;&amp; newType !== oldType) || newOptions.zIndex !== <span class="hljs-literal">undefined</span>) {
                    preserve.length = <span class="hljs-number">0</span>;
                }
                each(preserve, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    preserve[prop] = series[prop];
                    <span class="hljs-keyword">delete</span> series[prop];
                });
                newOptions = merge(oldOptions, {
                    <span class="hljs-attr">animation</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">index</span>: <span class="hljs-keyword">this</span>.index,
                    <span class="hljs-attr">pointStart</span>: <span class="hljs-keyword">this</span>.xData[<span class="hljs-number">0</span>]
                }, {
                    <span class="hljs-attr">data</span>: <span class="hljs-keyword">this</span>.options.data
                }, newOptions);
                <span class="hljs-keyword">this</span>.remove(<span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);
                <span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> proto) {
                    <span class="hljs-keyword">this</span>[n] = <span class="hljs-literal">undefined</span>;
                }
                extend(<span class="hljs-keyword">this</span>, seriesTypes[newType || oldType].prototype);
                each(preserve, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    series[prop] = preserve[prop];
                });
                <span class="hljs-keyword">this</span>.init(chart, newOptions);
                chart.linkSeries();
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    chart.redraw(<span class="hljs-literal">false</span>);
                }
            }
        });
        extend(Axis.prototype, {
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newOptions, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                newOptions = chart.options[<span class="hljs-keyword">this</span>.coll][<span class="hljs-keyword">this</span>.options.index] = merge(<span class="hljs-keyword">this</span>.userOptions, newOptions);
                <span class="hljs-keyword">this</span>.destroy(<span class="hljs-literal">true</span>);
                <span class="hljs-keyword">this</span>.init(chart, extend(newOptions, {
                    <span class="hljs-attr">events</span>: <span class="hljs-literal">undefined</span>
                }));
                chart.isDirtyBox = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    chart.redraw();
                }
            },
            <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">redraw</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    key = <span class="hljs-keyword">this</span>.coll,
                    axisSeries = <span class="hljs-keyword">this</span>.series,
                    i = axisSeries.length;
                <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">if</span> (axisSeries[i]) {
                        axisSeries[i].remove(<span class="hljs-literal">false</span>);
                    }
                }
                erase(chart.axes, <span class="hljs-keyword">this</span>);
                erase(chart[key], <span class="hljs-keyword">this</span>);
                chart.options[key].splice(<span class="hljs-keyword">this</span>.options.index, <span class="hljs-number">1</span>);
                each(chart[key], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, i</span>) </span>{
                    axis.options.index = i;
                });
                <span class="hljs-keyword">this</span>.destroy();
                chart.isDirtyBox = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    chart.redraw();
                }
            },
            <span class="hljs-attr">setTitle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newTitleOptions, redraw</span>) </span>{
                <span class="hljs-keyword">this</span>.update({
                    <span class="hljs-attr">title</span>: newTitleOptions
                }, redraw);
            },
            <span class="hljs-attr">setCategories</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">categories, redraw</span>) </span>{
                <span class="hljs-keyword">this</span>.update({
                    <span class="hljs-attr">categories</span>: categories
                }, redraw);
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> color = H.color,
            each = H.each,
            LegendSymbolMixin = H.LegendSymbolMixin,
            map = H.map,
            pick = H.pick,
            Series = H.Series,
            seriesType = H.seriesType;
        seriesType(<span class="hljs-string">'area'</span>, <span class="hljs-string">'line'</span>, {
            <span class="hljs-attr">softThreshold</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>
        }, {
            <span class="hljs-attr">singleStacks</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">getStackPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    segment = [],
                    keys = [],
                    xAxis = <span class="hljs-keyword">this</span>.xAxis,
                    yAxis = <span class="hljs-keyword">this</span>.yAxis,
                    stack = yAxis.stacks[<span class="hljs-keyword">this</span>.stackKey],
                    pointMap = {},
                    points = <span class="hljs-keyword">this</span>.points,
                    seriesIndex = series.index,
                    yAxisSeries = yAxis.series,
                    seriesLength = yAxisSeries.length,
                    visibleSeries,
                    upOrDown = pick(yAxis.options.reversedStacks, <span class="hljs-literal">true</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>,
                    i,
                    x;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.stacking) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; points.length; i++) {
                        pointMap[points[i].x] = points[i];
                    }
                    <span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> stack) {
                        <span class="hljs-keyword">if</span> (stack[x].total !== <span class="hljs-literal">null</span>) {
                            keys.push(x);
                        }
                    }
                    keys.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                        <span class="hljs-keyword">return</span> a - b;
                    });
                    visibleSeries = map(yAxisSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.visible;
                    });
                    each(keys, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, idx</span>) </span>{
                        <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>,
                            stackPoint,
                            stackedValues;
                        <span class="hljs-keyword">if</span> (pointMap[x] &amp;&amp; !pointMap[x].isNull) {
                            segment.push(pointMap[x]);
                            each([<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">direction</span>) </span>{
                                <span class="hljs-keyword">var</span> nullName = direction === <span class="hljs-number">1</span> ? <span class="hljs-string">'rightNull'</span> : <span class="hljs-string">'leftNull'</span>,
                                    cliffName = direction === <span class="hljs-number">1</span> ? <span class="hljs-string">'rightCliff'</span> : <span class="hljs-string">'leftCliff'</span>,
                                    cliff = <span class="hljs-number">0</span>,
                                    otherStack = stack[keys[idx + direction]];
                                <span class="hljs-keyword">if</span> (otherStack) {
                                    i = seriesIndex;
                                    <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; seriesLength) {
                                        stackPoint = otherStack.points[i];
                                        <span class="hljs-keyword">if</span> (!stackPoint) {
                                            <span class="hljs-keyword">if</span> (i === seriesIndex) {
                                                pointMap[x][nullName] = <span class="hljs-literal">true</span>;
                                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visibleSeries[i]) {
                                                stackedValues = stack[x].points[i];
                                                <span class="hljs-keyword">if</span> (stackedValues) {
                                                    cliff -= stackedValues[<span class="hljs-number">1</span>] - stackedValues[<span class="hljs-number">0</span>];
                                                }
                                            }
                                        }
                                        i += upOrDown;
                                    }
                                }
                                pointMap[x][cliffName] = cliff;
                            });
                        } <span class="hljs-keyword">else</span> {
                            i = seriesIndex;
                            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; i &lt; seriesLength) {
                                stackPoint = stack[x].points[i];
                                <span class="hljs-keyword">if</span> (stackPoint) {
                                    y = stackPoint[<span class="hljs-number">1</span>];
                                    <span class="hljs-keyword">break</span>;
                                }
                                i += upOrDown;
                            }
                            y = yAxis.toPixels(y, <span class="hljs-literal">true</span>);
                            segment.push({
                                <span class="hljs-attr">isNull</span>: <span class="hljs-literal">true</span>,
                                <span class="hljs-attr">plotX</span>: xAxis.toPixels(x, <span class="hljs-literal">true</span>),
                                <span class="hljs-attr">plotY</span>: y,
                                <span class="hljs-attr">yBottom</span>: y
                            });
                        }
                    });
                }
                <span class="hljs-keyword">return</span> segment;
            },
            <span class="hljs-attr">getGraphPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points</span>) </span>{
                <span class="hljs-keyword">var</span> getGraphPath = Series.prototype.getGraphPath,
                    graphPath,
                    options = <span class="hljs-keyword">this</span>.options,
                    stacking = options.stacking,
                    yAxis = <span class="hljs-keyword">this</span>.yAxis,
                    topPath,
                    bottomPath,
                    bottomPoints = [],
                    graphPoints = [],
                    seriesIndex = <span class="hljs-keyword">this</span>.index,
                    i,
                    areaPath,
                    plotX,
                    stacks = yAxis.stacks[<span class="hljs-keyword">this</span>.stackKey],
                    threshold = options.threshold,
                    translatedThreshold = yAxis.getThreshold(options.threshold),
                    isNull,
                    yBottom,
                    connectNulls = options.connectNulls || stacking === <span class="hljs-string">'percent'</span>,
                    addDummyPoints = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, otherI, side</span>) </span>{
                        <span class="hljs-keyword">var</span> point = points[i],
                            stackedValues = stacking &amp;&amp; stacks[point.x].points[seriesIndex],
                            nullVal = point[side + <span class="hljs-string">'Null'</span>] || <span class="hljs-number">0</span>,
                            cliffVal = point[side + <span class="hljs-string">'Cliff'</span>] || <span class="hljs-number">0</span>,
                            top,
                            bottom,
                            isNull = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (cliffVal || nullVal) {
                            top = (nullVal ? stackedValues[<span class="hljs-number">0</span>] : stackedValues[<span class="hljs-number">1</span>]) + cliffVal;
                            bottom = stackedValues[<span class="hljs-number">0</span>] + cliffVal;
                            isNull = !!nullVal;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!stacking &amp;&amp; points[otherI] &amp;&amp; points[otherI].isNull) {
                            top = bottom = threshold;
                        }
                        <span class="hljs-keyword">if</span> (top !== <span class="hljs-literal">undefined</span>) {
                            graphPoints.push({
                                <span class="hljs-attr">plotX</span>: plotX,
                                <span class="hljs-attr">plotY</span>: top === <span class="hljs-literal">null</span> ? translatedThreshold : yAxis.getThreshold(top),
                                <span class="hljs-attr">isNull</span>: isNull
                            });
                            bottomPoints.push({
                                <span class="hljs-attr">plotX</span>: plotX,
                                <span class="hljs-attr">plotY</span>: bottom === <span class="hljs-literal">null</span> ? translatedThreshold : yAxis.getThreshold(bottom),
                                <span class="hljs-attr">doCurve</span>: <span class="hljs-literal">false</span>
                            });
                        }
                    };
                points = points || <span class="hljs-keyword">this</span>.points;
                <span class="hljs-keyword">if</span> (stacking) {
                    points = <span class="hljs-keyword">this</span>.getStackPoints();
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; points.length; i++) {
                    isNull = points[i].isNull;
                    plotX = pick(points[i].rectPlotX, points[i].plotX);
                    yBottom = pick(points[i].yBottom, translatedThreshold);
                    <span class="hljs-keyword">if</span> (!isNull || connectNulls) {
                        <span class="hljs-keyword">if</span> (!connectNulls) {
                            addDummyPoints(i, i - <span class="hljs-number">1</span>, <span class="hljs-string">'left'</span>);
                        }
                        <span class="hljs-keyword">if</span> (!(isNull &amp;&amp; !stacking &amp;&amp; connectNulls)) {
                            graphPoints.push(points[i]);
                            bottomPoints.push({
                                <span class="hljs-attr">x</span>: i,
                                <span class="hljs-attr">plotX</span>: plotX,
                                <span class="hljs-attr">plotY</span>: yBottom
                            });
                        }
                        <span class="hljs-keyword">if</span> (!connectNulls) {
                            addDummyPoints(i, i + <span class="hljs-number">1</span>, <span class="hljs-string">'right'</span>);
                        }
                    }
                }
                topPath = getGraphPath.call(<span class="hljs-keyword">this</span>, graphPoints, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
                bottomPoints.reversed = <span class="hljs-literal">true</span>;
                bottomPath = getGraphPath.call(<span class="hljs-keyword">this</span>, bottomPoints, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (bottomPath.length) {
                    bottomPath[<span class="hljs-number">0</span>] = <span class="hljs-string">'L'</span>;
                }
                areaPath = topPath.concat(bottomPath);
                graphPath = getGraphPath.call(<span class="hljs-keyword">this</span>, graphPoints, <span class="hljs-literal">false</span>, connectNulls);
                areaPath.xMap = topPath.xMap;
                <span class="hljs-keyword">this</span>.areaPath = areaPath;
                <span class="hljs-keyword">return</span> graphPath;
            },
            <span class="hljs-attr">drawGraph</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.areaPath = [];
                Series.prototype.drawGraph.apply(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    areaPath = <span class="hljs-keyword">this</span>.areaPath,
                    options = <span class="hljs-keyword">this</span>.options,
                    zones = <span class="hljs-keyword">this</span>.zones,
                    props = [
                        [
                            <span class="hljs-string">'area'</span>,
                            <span class="hljs-string">'highcharts-area'</span>,
                            <span class="hljs-keyword">this</span>.color,
                            options.fillColor
                        ]
                    ];
                each(zones, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">zone, i</span>) </span>{
                    props.push([
                        <span class="hljs-string">'zone-area-'</span> + i,
                        <span class="hljs-string">'highcharts-area highcharts-zone-area-'</span> + i + <span class="hljs-string">' '</span> + zone.className,
                        zone.color || series.color,
                        zone.fillColor || options.fillColor
                    ]);
                });
                each(props, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    <span class="hljs-keyword">var</span> areaKey = prop[<span class="hljs-number">0</span>],
                        area = series[areaKey];
                    <span class="hljs-keyword">if</span> (area) {
                        area.endX = areaPath.xMap;
                        area.animate({
                            <span class="hljs-attr">d</span>: areaPath
                        });
                    } <span class="hljs-keyword">else</span> {
                        area = series[areaKey] = series.chart.renderer.path(areaPath)
                            .addClass(prop[<span class="hljs-number">1</span>])
                            .attr({
                                <span class="hljs-attr">fill</span>: pick(
                                    prop[<span class="hljs-number">3</span>],
                                    color(prop[<span class="hljs-number">2</span>]).setOpacity(pick(options.fillOpacity, <span class="hljs-number">0.75</span>)).get()
                                ),
                                <span class="hljs-attr">zIndex</span>: <span class="hljs-number">0</span>
                            }).add(series.group);
                        area.isArea = <span class="hljs-literal">true</span>;
                    }
                    area.startX = areaPath.xMap;
                    area.shiftUnit = options.step ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;
                });
            },
            <span class="hljs-attr">drawLegendSymbol</span>: LegendSymbolMixin.drawRectangle
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> pick = H.pick,
            seriesType = H.seriesType;
        seriesType(<span class="hljs-string">'spline'</span>, <span class="hljs-string">'line'</span>, {}, {
            <span class="hljs-attr">getPointSpline</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, point, i</span>) </span>{
                <span class="hljs-keyword">var</span> smoothing = <span class="hljs-number">1.5</span>,
                    denom = smoothing + <span class="hljs-number">1</span>,
                    plotX = point.plotX,
                    plotY = point.plotY,
                    lastPoint = points[i - <span class="hljs-number">1</span>],
                    nextPoint = points[i + <span class="hljs-number">1</span>],
                    leftContX,
                    leftContY,
                    rightContX,
                    rightContY,
                    ret;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doCurve</span>(<span class="hljs-params">otherPoint</span>) </span>{
                    <span class="hljs-keyword">return</span> otherPoint &amp;&amp; !otherPoint.isNull &amp;&amp; otherPoint.doCurve !== <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">if</span> (doCurve(lastPoint) &amp;&amp; doCurve(nextPoint)) {
                    <span class="hljs-keyword">var</span> lastX = lastPoint.plotX,
                        lastY = lastPoint.plotY,
                        nextX = nextPoint.plotX,
                        nextY = nextPoint.plotY,
                        correction = <span class="hljs-number">0</span>;
                    leftContX = (smoothing * plotX + lastX) / denom;
                    leftContY = (smoothing * plotY + lastY) / denom;
                    rightContX = (smoothing * plotX + nextX) / denom;
                    rightContY = (smoothing * plotY + nextY) / denom;
                    <span class="hljs-keyword">if</span> (rightContX !== leftContX) {
                        correction = ((rightContY - leftContY) * (rightContX - plotX)) /
                            (rightContX - leftContX) + plotY - rightContY;
                    }
                    leftContY += correction;
                    rightContY += correction;
                    <span class="hljs-keyword">if</span> (leftContY &gt; lastY &amp;&amp; leftContY &gt; plotY) {
                        leftContY = <span class="hljs-built_in">Math</span>.max(lastY, plotY);
                        rightContY = <span class="hljs-number">2</span> * plotY - leftContY;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftContY &lt; lastY &amp;&amp; leftContY &lt; plotY) {
                        leftContY = <span class="hljs-built_in">Math</span>.min(lastY, plotY);
                        rightContY = <span class="hljs-number">2</span> * plotY - leftContY;
                    }
                    <span class="hljs-keyword">if</span> (rightContY &gt; nextY &amp;&amp; rightContY &gt; plotY) {
                        rightContY = <span class="hljs-built_in">Math</span>.max(nextY, plotY);
                        leftContY = <span class="hljs-number">2</span> * plotY - rightContY;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rightContY &lt; nextY &amp;&amp; rightContY &lt; plotY) {
                        rightContY = <span class="hljs-built_in">Math</span>.min(nextY, plotY);
                        leftContY = <span class="hljs-number">2</span> * plotY - rightContY;
                    }
                    point.rightContX = rightContX;
                    point.rightContY = rightContY;
                }
                ret = [
                    <span class="hljs-string">'C'</span>,
                    pick(lastPoint.rightContX, lastPoint.plotX),
                    pick(lastPoint.rightContY, lastPoint.plotY),
                    pick(leftContX, plotX),
                    pick(leftContY, plotY),
                    plotX,
                    plotY
                ];
                lastPoint.rightContX = lastPoint.rightContY = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">return</span> ret;
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> areaProto = H.seriesTypes.area.prototype,
            defaultPlotOptions = H.defaultPlotOptions,
            LegendSymbolMixin = H.LegendSymbolMixin,
            seriesType = H.seriesType;
        seriesType(<span class="hljs-string">'areaspline'</span>, <span class="hljs-string">'spline'</span>, defaultPlotOptions.area, {
            <span class="hljs-attr">getStackPoints</span>: areaProto.getStackPoints,
            <span class="hljs-attr">getGraphPath</span>: areaProto.getGraphPath,
            <span class="hljs-attr">setStackCliffs</span>: areaProto.setStackCliffs,
            <span class="hljs-attr">drawGraph</span>: areaProto.drawGraph,
            <span class="hljs-attr">drawLegendSymbol</span>: LegendSymbolMixin.drawRectangle
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> animObject = H.animObject,
            color = H.color,
            each = H.each,
            extend = H.extend,
            isNumber = H.isNumber,
            LegendSymbolMixin = H.LegendSymbolMixin,
            merge = H.merge,
            noop = H.noop,
            pick = H.pick,
            Series = H.Series,
            seriesType = H.seriesType,
            svg = H.svg;
        seriesType(<span class="hljs-string">'column'</span>, <span class="hljs-string">'line'</span>, {
            <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">groupPadding</span>: <span class="hljs-number">0.2</span>,
            <span class="hljs-attr">marker</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">pointPadding</span>: <span class="hljs-number">0.1</span>,
            <span class="hljs-attr">minPointLength</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">cropThreshold</span>: <span class="hljs-number">50</span>,
            <span class="hljs-attr">pointRange</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">halo</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">brightness</span>: <span class="hljs-number">0.1</span>,
                    <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>
                },
                <span class="hljs-attr">select</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#cccccc'</span>,
                    <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#000000'</span>,
                    <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>
                }
            },
            <span class="hljs-attr">dataLabels</span>: {
                <span class="hljs-attr">align</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">verticalAlign</span>: <span class="hljs-literal">null</span>,
                <span class="hljs-attr">y</span>: <span class="hljs-literal">null</span>
            },
            <span class="hljs-attr">softThreshold</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">startFromThreshold</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">stickyTracking</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">distance</span>: <span class="hljs-number">6</span>
            },
            <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#ffffff'</span>
        }, {
            <span class="hljs-attr">cropShoulder</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">directTouch</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">trackerGroups</span>: [<span class="hljs-string">'group'</span>, <span class="hljs-string">'dataLabelsGroup'</span>],
            <span class="hljs-attr">negStacks</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                Series.prototype.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart;
                <span class="hljs-keyword">if</span> (chart.hasRendered) {
                    each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSeries</span>) </span>{
                        <span class="hljs-keyword">if</span> (otherSeries.type === series.type) {
                            otherSeries.isDirty = <span class="hljs-literal">true</span>;
                        }
                    });
                }
            },
            <span class="hljs-attr">getColumnMetrics</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    xAxis = series.xAxis,
                    yAxis = series.yAxis,
                    reversedXAxis = xAxis.reversed,
                    stackKey,
                    stackGroups = {},
                    columnCount = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (options.grouping === <span class="hljs-literal">false</span>) {
                    columnCount = <span class="hljs-number">1</span>;
                } <span class="hljs-keyword">else</span> {
                    each(series.chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSeries</span>) </span>{
                        <span class="hljs-keyword">var</span> otherOptions = otherSeries.options,
                            otherYAxis = otherSeries.yAxis,
                            columnIndex;
                        <span class="hljs-keyword">if</span> (otherSeries.type === series.type &amp;&amp; otherSeries.visible &amp;&amp;
                            yAxis.len === otherYAxis.len &amp;&amp; yAxis.pos === otherYAxis.pos) {
                            <span class="hljs-keyword">if</span> (otherOptions.stacking) {
                                stackKey = otherSeries.stackKey;
                                <span class="hljs-keyword">if</span> (stackGroups[stackKey] === <span class="hljs-literal">undefined</span>) {
                                    stackGroups[stackKey] = columnCount++;
                                }
                                columnIndex = stackGroups[stackKey];
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherOptions.grouping !== <span class="hljs-literal">false</span>) {
                                columnIndex = columnCount++;
                            }
                            otherSeries.columnIndex = columnIndex;
                        }
                    });
                }
                <span class="hljs-keyword">var</span> categoryWidth = <span class="hljs-built_in">Math</span>.min(
                        <span class="hljs-built_in">Math</span>.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || <span class="hljs-number">1</span>),
                        xAxis.len
                    ),
                    groupPadding = categoryWidth * options.groupPadding,
                    groupWidth = categoryWidth - <span class="hljs-number">2</span> * groupPadding,
                    pointOffsetWidth = groupWidth / (columnCount || <span class="hljs-number">1</span>),
                    pointWidth = <span class="hljs-built_in">Math</span>.min(
                        options.maxPointWidth || xAxis.len,
                        pick(options.pointWidth, pointOffsetWidth * (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> * options.pointPadding))
                    ),
                    pointPadding = (pointOffsetWidth - pointWidth) / <span class="hljs-number">2</span>,
                    colIndex = (series.columnIndex || <span class="hljs-number">0</span>) + (reversedXAxis ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>),
                    pointXOffset = pointPadding + (groupPadding + colIndex *
                        pointOffsetWidth - (categoryWidth / <span class="hljs-number">2</span>)) *
                    (reversedXAxis ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>);
                series.columnMetrics = {
                    <span class="hljs-attr">width</span>: pointWidth,
                    <span class="hljs-attr">offset</span>: pointXOffset
                };
                <span class="hljs-keyword">return</span> series.columnMetrics;
            },
            <span class="hljs-attr">crispCol</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    borderWidth = <span class="hljs-keyword">this</span>.borderWidth,
                    xCrisp = -(borderWidth % <span class="hljs-number">2</span> ? <span class="hljs-number">0.5</span> : <span class="hljs-number">0</span>),
                    yCrisp = borderWidth % <span class="hljs-number">2</span> ? <span class="hljs-number">0.5</span> : <span class="hljs-number">1</span>,
                    right,
                    bottom,
                    fromTop;
                <span class="hljs-keyword">if</span> (chart.inverted &amp;&amp; chart.renderer.isVML) {
                    yCrisp += <span class="hljs-number">1</span>;
                }
                right = <span class="hljs-built_in">Math</span>.round(x + w) + xCrisp;
                x = <span class="hljs-built_in">Math</span>.round(x) + xCrisp;
                w = right - x;
                bottom = <span class="hljs-built_in">Math</span>.round(y + h) + yCrisp;
                fromTop = <span class="hljs-built_in">Math</span>.abs(y) &lt;= <span class="hljs-number">0.5</span> &amp;&amp; bottom &gt; <span class="hljs-number">0.5</span>;
                y = <span class="hljs-built_in">Math</span>.round(y) + yCrisp;
                h = bottom - y;
                <span class="hljs-keyword">if</span> (fromTop &amp;&amp; h) {
                    y -= <span class="hljs-number">1</span>;
                    h += <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">x</span>: x,
                    <span class="hljs-attr">y</span>: y,
                    <span class="hljs-attr">width</span>: w,
                    <span class="hljs-attr">height</span>: h
                };
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    options = series.options,
                    dense = series.dense = series.closestPointRange * series.xAxis.transA &lt; <span class="hljs-number">2</span>,
                    borderWidth = series.borderWidth = pick(
                        options.borderWidth,
                        dense ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>
                    ),
                    yAxis = series.yAxis,
                    threshold = options.threshold,
                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),
                    minPointLength = pick(options.minPointLength, <span class="hljs-number">5</span>),
                    metrics = series.getColumnMetrics(),
                    pointWidth = metrics.width,
                    seriesBarW = series.barW = <span class="hljs-built_in">Math</span>.max(pointWidth, <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * borderWidth),
                    pointXOffset = series.pointXOffset = metrics.offset;
                <span class="hljs-keyword">if</span> (chart.inverted) {
                    translatedThreshold -= <span class="hljs-number">0.5</span>;
                }
                <span class="hljs-keyword">if</span> (options.pointPadding) {
                    seriesBarW = <span class="hljs-built_in">Math</span>.ceil(seriesBarW);
                }
                Series.prototype.translate.apply(series);
                each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> yBottom = pick(point.yBottom, translatedThreshold),
                        safeDistance = <span class="hljs-number">999</span> + <span class="hljs-built_in">Math</span>.abs(yBottom),
                        plotY = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(-safeDistance, point.plotY), yAxis.len + safeDistance),
                        barX = point.plotX + pointXOffset,
                        barW = seriesBarW,
                        barY = <span class="hljs-built_in">Math</span>.min(plotY, yBottom),
                        up,
                        barH = <span class="hljs-built_in">Math</span>.max(plotY, yBottom) - barY;
                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(barH) &lt; minPointLength) {
                        <span class="hljs-keyword">if</span> (minPointLength) {
                            barH = minPointLength;
                            up = (!yAxis.reversed &amp;&amp; !point.negative) || (yAxis.reversed &amp;&amp; point.negative);
                            barY = <span class="hljs-built_in">Math</span>.abs(barY - translatedThreshold) &gt; minPointLength ?
                                yBottom - minPointLength :
                                translatedThreshold - (up ? minPointLength : <span class="hljs-number">0</span>);
                        }
                    }
                    point.barX = barX;
                    point.pointWidth = pointWidth;
                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / <span class="hljs-number">2</span>, barH] : [barX + barW / <span class="hljs-number">2</span>, plotY + yAxis.pos - chart.plotTop, barH];
                    point.shapeType = <span class="hljs-string">'rect'</span>;
                    point.shapeArgs = series.crispCol.apply(
                        series,
                        point.isNull ? [point.plotX, yAxis.len / <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>] : [barX, barY, barW, barH]
                    );
                });
            },
            <span class="hljs-attr">getSymbol</span>: noop,
            <span class="hljs-attr">drawLegendSymbol</span>: LegendSymbolMixin.drawRectangle,
            <span class="hljs-attr">drawGraph</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.group[<span class="hljs-keyword">this</span>.dense ? <span class="hljs-string">'addClass'</span> : <span class="hljs-string">'removeClass'</span>](<span class="hljs-string">'highcharts-dense-data'</span>);
            },
            <span class="hljs-attr">pointAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    stateOptions,
                    ret,
                    p2o = <span class="hljs-keyword">this</span>.pointAttrToOptions || {},
                    strokeOption = p2o.stroke || <span class="hljs-string">'borderColor'</span>,
                    strokeWidthOption = p2o[<span class="hljs-string">'stroke-width'</span>] || <span class="hljs-string">'borderWidth'</span>,
                    fill = (point &amp;&amp; point.color) || <span class="hljs-keyword">this</span>.color,
                    stroke = point[strokeOption] || options[strokeOption] ||
                    <span class="hljs-keyword">this</span>.color || fill,
                    strokeWidth = point[strokeWidthOption] ||
                    options[strokeWidthOption] || <span class="hljs-keyword">this</span>[strokeWidthOption] || <span class="hljs-number">0</span>,
                    dashstyle = options.dashStyle,
                    zone,
                    brightness;
                <span class="hljs-keyword">if</span> (point &amp;&amp; <span class="hljs-keyword">this</span>.zones.length) {
                    zone = point.getZone();
                    fill = (zone &amp;&amp; zone.color) || point.options.color || <span class="hljs-keyword">this</span>.color;
                }
                <span class="hljs-keyword">if</span> (state) {
                    stateOptions = options.states[state];
                    brightness = stateOptions.brightness;
                    fill = stateOptions.color ||
                        (brightness !== <span class="hljs-literal">undefined</span> &amp;&amp; color(fill).brighten(stateOptions.brightness).get()) ||
                        fill;
                    stroke = stateOptions[strokeOption] || stroke;
                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
                    dashstyle = stateOptions.dashStyle || dashstyle;
                }
                ret = {
                    <span class="hljs-string">'fill'</span>: fill,
                    <span class="hljs-string">'stroke'</span>: stroke,
                    <span class="hljs-string">'stroke-width'</span>: strokeWidth
                };
                <span class="hljs-keyword">if</span> (options.borderRadius) {
                    ret.r = options.borderRadius;
                }
                <span class="hljs-keyword">if</span> (dashstyle) {
                    ret.dashstyle = dashstyle;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    options = series.options,
                    renderer = chart.renderer,
                    animationLimit = options.animationLimit || <span class="hljs-number">250</span>,
                    shapeArgs;
                each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> plotY = point.plotY,
                        graphic = point.graphic;
                    <span class="hljs-keyword">if</span> (isNumber(plotY) &amp;&amp; point.y !== <span class="hljs-literal">null</span>) {
                        shapeArgs = point.shapeArgs;
                        <span class="hljs-keyword">if</span> (graphic) {
                            graphic[chart.pointCount &lt; animationLimit ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>](
                                merge(shapeArgs)
                            );
                        } <span class="hljs-keyword">else</span> {
                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                .attr({
                                    <span class="hljs-string">'class'</span>: point.getClassName()
                                })
                                .add(point.group || series.group);
                        }
                        graphic
                            .attr(series.pointAttribs(point, point.selected &amp;&amp; <span class="hljs-string">'select'</span>))
                            .shadow(options.shadow, <span class="hljs-literal">null</span>, options.stacking &amp;&amp; !options.borderRadius);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (graphic) {
                        point.graphic = graphic.destroy();
                    }
                });
            },
            <span class="hljs-attr">animate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">init</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    yAxis = <span class="hljs-keyword">this</span>.yAxis,
                    options = series.options,
                    inverted = <span class="hljs-keyword">this</span>.chart.inverted,
                    attr = {},
                    translatedThreshold;
                <span class="hljs-keyword">if</span> (svg) {
                    <span class="hljs-keyword">if</span> (init) {
                        attr.scaleY = <span class="hljs-number">0.001</span>;
                        translatedThreshold = <span class="hljs-built_in">Math</span>.min(yAxis.pos + yAxis.len, <span class="hljs-built_in">Math</span>.max(yAxis.pos, yAxis.toPixels(options.threshold)));
                        <span class="hljs-keyword">if</span> (inverted) {
                            attr.translateX = translatedThreshold - yAxis.len;
                        } <span class="hljs-keyword">else</span> {
                            attr.translateY = translatedThreshold;
                        }
                        series.group.attr(attr);
                    } <span class="hljs-keyword">else</span> {
                        attr[inverted ? <span class="hljs-string">'translateX'</span> : <span class="hljs-string">'translateY'</span>] = yAxis.pos;
                        series.group.animate(attr, extend(animObject(series.options.animation), {
                            <span class="hljs-attr">step</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, fx</span>) </span>{
                                series.group.attr({
                                    <span class="hljs-attr">scaleY</span>: <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0.001</span>, fx.pos)
                                });
                            }
                        }));
                        series.animate = <span class="hljs-literal">null</span>;
                    }
                }
            },
            <span class="hljs-attr">remove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart;
                <span class="hljs-keyword">if</span> (chart.hasRendered) {
                    each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSeries</span>) </span>{
                        <span class="hljs-keyword">if</span> (otherSeries.type === series.type) {
                            otherSeries.isDirty = <span class="hljs-literal">true</span>;
                        }
                    });
                }
                Series.prototype.remove.apply(series, <span class="hljs-built_in">arguments</span>);
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> seriesType = H.seriesType;
        seriesType(<span class="hljs-string">'bar'</span>, <span class="hljs-string">'column'</span>, <span class="hljs-literal">null</span>, {
            <span class="hljs-attr">inverted</span>: <span class="hljs-literal">true</span>
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Series = H.Series,
            seriesType = H.seriesType;
        seriesType(<span class="hljs-string">'scatter'</span>, <span class="hljs-string">'line'</span>, {
            <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">marker</span>: {
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>
            },
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">headerFormat</span>: <span class="hljs-string">'&lt;span style="color:{point.color}"&gt;\u25CF&lt;/span&gt; '</span> +
                    <span class="hljs-string">'&lt;span style="font-size: 0.85em"&gt; {series.name}&lt;/span&gt;&lt;br/&gt;'</span>,
                <span class="hljs-attr">pointFormat</span>: <span class="hljs-string">'x: &lt;b&gt;{point.x}&lt;/b&gt;&lt;br/&gt;y: &lt;b&gt;{point.y}&lt;/b&gt;&lt;br/&gt;'</span>
            }
        }, {
            <span class="hljs-attr">sorted</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">requireSorting</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">noSharedTooltip</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">trackerGroups</span>: [<span class="hljs-string">'group'</span>, <span class="hljs-string">'markerGroup'</span>, <span class="hljs-string">'dataLabelsGroup'</span>],
            <span class="hljs-attr">takeOrdinalPosition</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">kdDimensions</span>: <span class="hljs-number">2</span>,
            <span class="hljs-attr">drawGraph</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.lineWidth) {
                    Series.prototype.drawGraph.call(<span class="hljs-keyword">this</span>);
                }
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> pick = H.pick,
            relativeLength = H.relativeLength;
        H.CenteredSeriesMixin = {
            <span class="hljs-attr">getCenter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    slicingRoom = <span class="hljs-number">2</span> * (options.slicedOffset || <span class="hljs-number">0</span>),
                    handleSlicingRoom,
                    plotWidth = chart.plotWidth - <span class="hljs-number">2</span> * slicingRoom,
                    plotHeight = chart.plotHeight - <span class="hljs-number">2</span> * slicingRoom,
                    centerOption = options.center,
                    positions = [pick(centerOption[<span class="hljs-number">0</span>], <span class="hljs-string">'50%'</span>), pick(centerOption[<span class="hljs-number">1</span>], <span class="hljs-string">'50%'</span>), options.size || <span class="hljs-string">'100%'</span>, options.innerSize || <span class="hljs-number">0</span>],
                    smallestSize = <span class="hljs-built_in">Math</span>.min(plotWidth, plotHeight),
                    i,
                    value;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) {
                    value = positions[i];
                    handleSlicingRoom = i &lt; <span class="hljs-number">2</span> || (i === <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-regexp">/%$/</span>.test(value));
                    positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[<span class="hljs-number">2</span>]][i]) +
                        (handleSlicingRoom ? slicingRoom : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (positions[<span class="hljs-number">3</span>] &gt; positions[<span class="hljs-number">2</span>]) {
                    positions[<span class="hljs-number">3</span>] = positions[<span class="hljs-number">2</span>];
                }
                <span class="hljs-keyword">return</span> positions;
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            CenteredSeriesMixin = H.CenteredSeriesMixin,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            inArray = H.inArray,
            LegendSymbolMixin = H.LegendSymbolMixin,
            noop = H.noop,
            pick = H.pick,
            Point = H.Point,
            Series = H.Series,
            seriesType = H.seriesType,
            seriesTypes = H.seriesTypes,
            setAnimation = H.setAnimation;
        seriesType(<span class="hljs-string">'pie'</span>, <span class="hljs-string">'line'</span>, {
            <span class="hljs-attr">center</span>: [<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>],
            <span class="hljs-attr">clip</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">colorByPoint</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">dataLabels</span>: {
                <span class="hljs-attr">distance</span>: <span class="hljs-number">30</span>,
                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">formatter</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.y === <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-keyword">this</span>.point.name;
                },
                <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>
            },
            <span class="hljs-attr">ignoreHiddenPoint</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">legendType</span>: <span class="hljs-string">'point'</span>,
            <span class="hljs-attr">marker</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">size</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">showInLegend</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">slicedOffset</span>: <span class="hljs-number">10</span>,
            <span class="hljs-attr">stickyTracking</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">followPointer</span>: <span class="hljs-literal">true</span>
            },
            <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#ffffff'</span>,
            <span class="hljs-attr">borderWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">brightness</span>: <span class="hljs-number">0.1</span>,
                    <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>
                }
            }
        }, {
            <span class="hljs-attr">isCartesian</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">requireSorting</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">directTouch</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">noSharedTooltip</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">trackerGroups</span>: [<span class="hljs-string">'group'</span>, <span class="hljs-string">'dataLabelsGroup'</span>],
            <span class="hljs-attr">axisTypes</span>: [],
            <span class="hljs-attr">pointAttribs</span>: seriesTypes.column.prototype.pointAttribs,
            <span class="hljs-attr">animate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">init</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points,
                    startAngleRad = series.startAngleRad;
                <span class="hljs-keyword">if</span> (!init) {
                    each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                        <span class="hljs-keyword">var</span> graphic = point.graphic,
                            args = point.shapeArgs;
                        <span class="hljs-keyword">if</span> (graphic) {
                            graphic.attr({
                                <span class="hljs-attr">r</span>: point.startR || (series.center[<span class="hljs-number">3</span>] / <span class="hljs-number">2</span>),
                                <span class="hljs-attr">start</span>: startAngleRad,
                                <span class="hljs-attr">end</span>: startAngleRad
                            });
                            graphic.animate({
                                <span class="hljs-attr">r</span>: args.r,
                                <span class="hljs-attr">start</span>: args.start,
                                <span class="hljs-attr">end</span>: args.end
                            }, series.options.animation);
                        }
                    });
                    series.animate = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">updateTotals</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    total = <span class="hljs-number">0</span>,
                    points = <span class="hljs-keyword">this</span>.points,
                    len = points.length,
                    point,
                    ignoreHiddenPoint = <span class="hljs-keyword">this</span>.options.ignoreHiddenPoint;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    point = points[i];
                    <span class="hljs-keyword">if</span> (point.y &lt; <span class="hljs-number">0</span>) {
                        point.y = <span class="hljs-literal">null</span>;
                    }
                    total += (ignoreHiddenPoint &amp;&amp; !point.visible) ? <span class="hljs-number">0</span> : point.y;
                }
                <span class="hljs-keyword">this</span>.total = total;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    point = points[i];
                    point.percentage = (total &gt; <span class="hljs-number">0</span> &amp;&amp; (point.visible || !ignoreHiddenPoint)) ? point.y / total * <span class="hljs-number">100</span> : <span class="hljs-number">0</span>;
                    point.total = total;
                }
            },
            <span class="hljs-attr">generatePoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                Series.prototype.generatePoints.call(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">this</span>.updateTotals();
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">positions</span>) </span>{
                <span class="hljs-keyword">this</span>.generatePoints();
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    cumulative = <span class="hljs-number">0</span>,
                    precision = <span class="hljs-number">1000</span>,
                    options = series.options,
                    slicedOffset = options.slicedOffset,
                    connectorOffset = slicedOffset + (options.borderWidth || <span class="hljs-number">0</span>),
                    start,
                    end,
                    angle,
                    startAngle = options.startAngle || <span class="hljs-number">0</span>,
                    startAngleRad = series.startAngleRad = <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span> * (startAngle - <span class="hljs-number">90</span>),
                    endAngleRad = series.endAngleRad = <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span> * ((pick(options.endAngle, startAngle + <span class="hljs-number">360</span>)) - <span class="hljs-number">90</span>),
                    circ = endAngleRad - startAngleRad,
                    points = series.points,
                    radiusX,
                    radiusY,
                    labelDistance = options.dataLabels.distance,
                    ignoreHiddenPoint = options.ignoreHiddenPoint,
                    i,
                    len = points.length,
                    point;
                <span class="hljs-keyword">if</span> (!positions) {
                    series.center = positions = series.getCenter();
                }
                series.getX = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">y, left</span>) </span>{
                    angle = <span class="hljs-built_in">Math</span>.asin(<span class="hljs-built_in">Math</span>.min((y - positions[<span class="hljs-number">1</span>]) / (positions[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span> + labelDistance), <span class="hljs-number">1</span>));
                    <span class="hljs-keyword">return</span> positions[<span class="hljs-number">0</span>] +
                        (left ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) *
                        (<span class="hljs-built_in">Math</span>.cos(angle) * (positions[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span> + labelDistance));
                };
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                    point = points[i];
                    start = startAngleRad + (cumulative * circ);
                    <span class="hljs-keyword">if</span> (!ignoreHiddenPoint || point.visible) {
                        cumulative += point.percentage / <span class="hljs-number">100</span>;
                    }
                    end = startAngleRad + (cumulative * circ);
                    point.shapeType = <span class="hljs-string">'arc'</span>;
                    point.shapeArgs = {
                        <span class="hljs-attr">x</span>: positions[<span class="hljs-number">0</span>],
                        <span class="hljs-attr">y</span>: positions[<span class="hljs-number">1</span>],
                        <span class="hljs-attr">r</span>: positions[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>,
                        <span class="hljs-attr">innerR</span>: positions[<span class="hljs-number">3</span>] / <span class="hljs-number">2</span>,
                        <span class="hljs-attr">start</span>: <span class="hljs-built_in">Math</span>.round(start * precision) / precision,
                        <span class="hljs-attr">end</span>: <span class="hljs-built_in">Math</span>.round(end * precision) / precision
                    };
                    angle = (end + start) / <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">if</span> (angle &gt; <span class="hljs-number">1.5</span> * <span class="hljs-built_in">Math</span>.PI) {
                        angle -= <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (angle &lt; -<span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) {
                        angle += <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI;
                    }
                    point.slicedTranslation = {
                        <span class="hljs-attr">translateX</span>: <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.cos(angle) * slicedOffset),
                        <span class="hljs-attr">translateY</span>: <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.sin(angle) * slicedOffset)
                    };
                    radiusX = <span class="hljs-built_in">Math</span>.cos(angle) * positions[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>;
                    radiusY = <span class="hljs-built_in">Math</span>.sin(angle) * positions[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>;
                    point.tooltipPos = [
                        positions[<span class="hljs-number">0</span>] + radiusX * <span class="hljs-number">0.7</span>,
                        positions[<span class="hljs-number">1</span>] + radiusY * <span class="hljs-number">0.7</span>
                    ];
                    point.half = angle &lt; -<span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span> || angle &gt; <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
                    point.angle = angle;
                    connectorOffset = <span class="hljs-built_in">Math</span>.min(connectorOffset, labelDistance / <span class="hljs-number">5</span>);
                    point.labelPos = [
                        positions[<span class="hljs-number">0</span>] + radiusX + <span class="hljs-built_in">Math</span>.cos(angle) * labelDistance,
                        positions[<span class="hljs-number">1</span>] + radiusY + <span class="hljs-built_in">Math</span>.sin(angle) * labelDistance,
                        positions[<span class="hljs-number">0</span>] + radiusX + <span class="hljs-built_in">Math</span>.cos(angle) * connectorOffset,
                        positions[<span class="hljs-number">1</span>] + radiusY + <span class="hljs-built_in">Math</span>.sin(angle) * connectorOffset,
                        positions[<span class="hljs-number">0</span>] + radiusX,
                        positions[<span class="hljs-number">1</span>] + radiusY,
                        labelDistance &lt; <span class="hljs-number">0</span> ?
                        <span class="hljs-string">'center'</span> :
                        point.half ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>,
                        angle
                    ];
                }
            },
            <span class="hljs-attr">drawGraph</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    renderer = chart.renderer,
                    groupTranslation,
                    graphic,
                    pointAttr,
                    shapeArgs;
                <span class="hljs-keyword">var</span> shadow = series.options.shadow;
                <span class="hljs-keyword">if</span> (shadow &amp;&amp; !series.shadowGroup) {
                    series.shadowGroup = renderer.g(<span class="hljs-string">'shadow'</span>)
                        .add(series.group);
                }
                each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">if</span> (point.y !== <span class="hljs-literal">null</span>) {
                        graphic = point.graphic;
                        shapeArgs = point.shapeArgs;
                        groupTranslation = point.sliced ? point.slicedTranslation : {};
                        <span class="hljs-keyword">var</span> shadowGroup = point.shadowGroup;
                        <span class="hljs-keyword">if</span> (shadow &amp;&amp; !shadowGroup) {
                            shadowGroup = point.shadowGroup = renderer.g(<span class="hljs-string">'shadow'</span>)
                                .add(series.shadowGroup);
                        }
                        <span class="hljs-keyword">if</span> (shadowGroup) {
                            shadowGroup.attr(groupTranslation);
                        }
                        pointAttr = series.pointAttribs(point, point.selected &amp;&amp; <span class="hljs-string">'select'</span>);
                        <span class="hljs-keyword">if</span> (graphic) {
                            graphic
                                .setRadialReference(series.center)
                                .attr(pointAttr)
                                .animate(extend(shapeArgs, groupTranslation));
                        } <span class="hljs-keyword">else</span> {
                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)
                                .addClass(point.getClassName())
                                .setRadialReference(series.center)
                                .attr(groupTranslation)
                                .add(series.group);
                            <span class="hljs-keyword">if</span> (!point.visible) {
                                graphic.attr({
                                    <span class="hljs-attr">visibility</span>: <span class="hljs-string">'hidden'</span>
                                });
                            }
                            graphic
                                .attr(pointAttr)
                                .attr({
                                    <span class="hljs-string">'stroke-linejoin'</span>: <span class="hljs-string">'round'</span>
                                })
                                .shadow(shadow, shadowGroup);
                        }
                    }
                });
            },
            <span class="hljs-attr">searchPoint</span>: noop,
            <span class="hljs-attr">sortByAngle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, sign</span>) </span>{
                points.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                    <span class="hljs-keyword">return</span> a.angle !== <span class="hljs-literal">undefined</span> &amp;&amp; (b.angle - a.angle) * sign;
                });
            },
            <span class="hljs-attr">drawLegendSymbol</span>: LegendSymbolMixin.drawRectangle,
            <span class="hljs-attr">getCenter</span>: CenteredSeriesMixin.getCenter,
            <span class="hljs-attr">getSymbol</span>: noop
        }, {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                Point.prototype.init.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    toggleSlice;
                point.name = pick(point.name, <span class="hljs-string">'Slice'</span>);
                toggleSlice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    point.slice(e.type === <span class="hljs-string">'select'</span>);
                };
                addEvent(point, <span class="hljs-string">'select'</span>, toggleSlice);
                addEvent(point, <span class="hljs-string">'unselect'</span>, toggleSlice);
                <span class="hljs-keyword">return</span> point;
            },
            <span class="hljs-attr">setVisible</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">vis, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    chart = series.chart,
                    ignoreHiddenPoint = series.options.ignoreHiddenPoint;
                redraw = pick(redraw, ignoreHiddenPoint);
                <span class="hljs-keyword">if</span> (vis !== point.visible) {
                    point.visible = point.options.visible = vis = vis === <span class="hljs-literal">undefined</span> ? !point.visible : vis;
                    series.options.data[inArray(point, series.data)] = point.options;
                    each([<span class="hljs-string">'graphic'</span>, <span class="hljs-string">'dataLabel'</span>, <span class="hljs-string">'connector'</span>, <span class="hljs-string">'shadowGroup'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        <span class="hljs-keyword">if</span> (point[key]) {
                            point[key][vis ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>](<span class="hljs-literal">true</span>);
                        }
                    });
                    <span class="hljs-keyword">if</span> (point.legendItem) {
                        chart.legend.colorizeItem(point, vis);
                    }
                    <span class="hljs-keyword">if</span> (!vis &amp;&amp; point.state === <span class="hljs-string">'hover'</span>) {
                        point.setState(<span class="hljs-string">''</span>);
                    }
                    <span class="hljs-keyword">if</span> (ignoreHiddenPoint) {
                        series.isDirty = <span class="hljs-literal">true</span>;
                    }
                    <span class="hljs-keyword">if</span> (redraw) {
                        chart.redraw();
                    }
                }
            },
            <span class="hljs-attr">slice</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sliced, redraw, animation</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    chart = series.chart,
                    translation;
                setAnimation(animation, chart);
                redraw = pick(redraw, <span class="hljs-literal">true</span>);
                point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;
                series.options.data[inArray(point, series.data)] = point.options;
                translation = sliced ? point.slicedTranslation : {
                    <span class="hljs-attr">translateX</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">translateY</span>: <span class="hljs-number">0</span>
                };
                point.graphic.animate(translation);
                <span class="hljs-keyword">if</span> (point.shadowGroup) {
                    point.shadowGroup.animate(translation);
                }
            },
            <span class="hljs-attr">haloPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
                <span class="hljs-keyword">var</span> shapeArgs = <span class="hljs-keyword">this</span>.shapeArgs;
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sliced || !<span class="hljs-keyword">this</span>.visible ? [] :
                    <span class="hljs-keyword">this</span>.series.chart.renderer.symbols.arc(
                        shapeArgs.x,
                        shapeArgs.y,
                        shapeArgs.r + size,
                        shapeArgs.r + size, {
                            <span class="hljs-attr">innerR</span>: <span class="hljs-keyword">this</span>.shapeArgs.r,
                            <span class="hljs-attr">start</span>: shapeArgs.start,
                            <span class="hljs-attr">end</span>: shapeArgs.end
                        }
                    );
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            arrayMax = H.arrayMax,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            format = H.format,
            map = H.map,
            merge = H.merge,
            noop = H.noop,
            pick = H.pick,
            relativeLength = H.relativeLength,
            Series = H.Series,
            seriesTypes = H.seriesTypes,
            stableSort = H.stableSort;
        H.distribute = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">boxes, len</span>) </span>{
            <span class="hljs-keyword">var</span> i,
                overlapping = <span class="hljs-literal">true</span>,
                origBoxes = boxes,
                restBoxes = [],
                box,
                target,
                total = <span class="hljs-number">0</span>;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sortByTarget</span>(<span class="hljs-params">a, b</span>) </span>{
                <span class="hljs-keyword">return</span> a.target - b.target;
            }
            i = boxes.length;
            <span class="hljs-keyword">while</span> (i--) {
                total += boxes[i].size;
            }
            <span class="hljs-keyword">if</span> (total &gt; len) {
                stableSort(boxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                    <span class="hljs-keyword">return</span> (b.rank || <span class="hljs-number">0</span>) - (a.rank || <span class="hljs-number">0</span>);
                });
                i = <span class="hljs-number">0</span>;
                total = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (total &lt;= len) {
                    total += boxes[i].size;
                    i++;
                }
                restBoxes = boxes.splice(i - <span class="hljs-number">1</span>, boxes.length);
            }
            stableSort(boxes, sortByTarget);
            boxes = map(boxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>{
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">size</span>: box.size,
                    <span class="hljs-attr">targets</span>: [box.target]
                };
            });
            <span class="hljs-keyword">while</span> (overlapping) {
                i = boxes.length;
                <span class="hljs-keyword">while</span> (i--) {
                    box = boxes[i];
                    target = (<span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-number">0</span>, box.targets) + <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-number">0</span>, box.targets)) / <span class="hljs-number">2</span>;
                    box.pos = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, target - box.size / <span class="hljs-number">2</span>), len - box.size);
                }
                i = boxes.length;
                overlapping = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; boxes[i - <span class="hljs-number">1</span>].pos + boxes[i - <span class="hljs-number">1</span>].size &gt; boxes[i].pos) {
                        boxes[i - <span class="hljs-number">1</span>].size += boxes[i].size;
                        boxes[i - <span class="hljs-number">1</span>].targets = boxes[i - <span class="hljs-number">1</span>].targets.concat(boxes[i].targets);
                        <span class="hljs-keyword">if</span> (boxes[i - <span class="hljs-number">1</span>].pos + boxes[i - <span class="hljs-number">1</span>].size &gt; len) {
                            boxes[i - <span class="hljs-number">1</span>].pos = len - boxes[i - <span class="hljs-number">1</span>].size;
                        }
                        boxes.splice(i, <span class="hljs-number">1</span>);
                        overlapping = <span class="hljs-literal">true</span>;
                    }
                }
            }
            i = <span class="hljs-number">0</span>;
            each(boxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box</span>) </span>{
                <span class="hljs-keyword">var</span> posInCompositeBox = <span class="hljs-number">0</span>;
                each(box.targets, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    origBoxes[i].pos = box.pos + posInCompositeBox;
                    posInCompositeBox += origBoxes[i].size;
                    i++;
                });
            });
            origBoxes.push.apply(origBoxes, restBoxes);
            stableSort(origBoxes, sortByTarget);
        };
        Series.prototype.drawDataLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                seriesOptions = series.options,
                options = seriesOptions.dataLabels,
                points = series.points,
                pointOptions,
                generalOptions,
                hasRendered = series.hasRendered || <span class="hljs-number">0</span>,
                str,
                dataLabelsGroup,
                defer = pick(options.defer, <span class="hljs-literal">true</span>),
                renderer = series.chart.renderer;
            <span class="hljs-keyword">if</span> (options.enabled || series._hasPointLabels) {
                <span class="hljs-keyword">if</span> (series.dlProcessOptions) {
                    series.dlProcessOptions(options);
                }
                dataLabelsGroup = series.plotGroup(
                    <span class="hljs-string">'dataLabelsGroup'</span>,
                    <span class="hljs-string">'data-labels'</span>,
                    defer &amp;&amp; !hasRendered ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'visible'</span>,
                    options.zIndex || <span class="hljs-number">6</span>
                );
                <span class="hljs-keyword">if</span> (defer) {
                    dataLabelsGroup.attr({
                        <span class="hljs-attr">opacity</span>: +hasRendered
                    });
                    <span class="hljs-keyword">if</span> (!hasRendered) {
                        addEvent(series, <span class="hljs-string">'afterAnimate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (series.visible) {
                                dataLabelsGroup.show(<span class="hljs-literal">true</span>);
                            }
                            dataLabelsGroup[seriesOptions.animation ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>]({
                                <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>
                            }, {
                                <span class="hljs-attr">duration</span>: <span class="hljs-number">200</span>
                            });
                        });
                    }
                }
                generalOptions = options;
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> enabled,
                        dataLabel = point.dataLabel,
                        labelConfig,
                        attr,
                        name,
                        rotation,
                        connector = point.connector,
                        isNew = !dataLabel,
                        style;
                    pointOptions = point.dlOptions || (point.options &amp;&amp; point.options.dataLabels);
                    enabled = pick(pointOptions &amp;&amp; pointOptions.enabled, generalOptions.enabled) &amp;&amp; point.y !== <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">if</span> (enabled) {
                        options = merge(generalOptions, pointOptions);
                        labelConfig = point.getLabelConfig();
                        str = options.format ?
                            format(options.format, labelConfig) :
                            options.formatter.call(labelConfig, options);
                        style = options.style;
                        rotation = options.rotation;
                        style.color = pick(options.color, style.color, series.color, <span class="hljs-string">'#000000'</span>);
                        <span class="hljs-keyword">if</span> (style.color === <span class="hljs-string">'contrast'</span>) {
                            style.color = options.inside || options.distance &lt; <span class="hljs-number">0</span> || !!seriesOptions.stacking ?
                                renderer.getContrast(point.color || series.color) :
                                <span class="hljs-string">'#000000'</span>;
                        }
                        <span class="hljs-keyword">if</span> (seriesOptions.cursor) {
                            style.cursor = seriesOptions.cursor;
                        }
                        attr = {
                            <span class="hljs-attr">fill</span>: options.backgroundColor,
                            <span class="hljs-attr">stroke</span>: options.borderColor,
                            <span class="hljs-string">'stroke-width'</span>: options.borderWidth,
                            <span class="hljs-attr">r</span>: options.borderRadius || <span class="hljs-number">0</span>,
                            <span class="hljs-attr">rotation</span>: rotation,
                            <span class="hljs-attr">padding</span>: options.padding,
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        };
                        <span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> attr) {
                            <span class="hljs-keyword">if</span> (attr[name] === <span class="hljs-literal">undefined</span>) {
                                <span class="hljs-keyword">delete</span> attr[name];
                            }
                        }
                    }
                    <span class="hljs-keyword">if</span> (dataLabel &amp;&amp; (!enabled || !defined(str))) {
                        point.dataLabel = dataLabel = dataLabel.destroy();
                        <span class="hljs-keyword">if</span> (connector) {
                            point.connector = connector.destroy();
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (enabled &amp;&amp; defined(str)) {
                        <span class="hljs-keyword">if</span> (!dataLabel) {
                            dataLabel = point.dataLabel = renderer[rotation ? <span class="hljs-string">'text'</span> : <span class="hljs-string">'label'</span>](
                                str,
                                <span class="hljs-number">0</span>, <span class="hljs-number">-9999</span>,
                                options.shape,
                                <span class="hljs-literal">null</span>,
                                <span class="hljs-literal">null</span>,
                                options.useHTML,
                                <span class="hljs-literal">null</span>,
                                <span class="hljs-string">'data-label'</span>
                            );
                            dataLabel.addClass(
                                <span class="hljs-string">'highcharts-data-label-color-'</span> + point.colorIndex +
                                <span class="hljs-string">' '</span> + (options.className || <span class="hljs-string">''</span>) +
                                (options.useHTML ? <span class="hljs-string">'highcharts-tracker'</span> : <span class="hljs-string">''</span>)
                            );
                        } <span class="hljs-keyword">else</span> {
                            attr.text = str;
                        }
                        dataLabel.attr(attr);
                        dataLabel.css(style).shadow(options.shadow);
                        <span class="hljs-keyword">if</span> (!dataLabel.added) {
                            dataLabel.add(dataLabelsGroup);
                        }
                        series.alignDataLabel(point, dataLabel, options, <span class="hljs-literal">null</span>, isNew);
                    }
                });
            }
        };
        Series.prototype.alignDataLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, dataLabel, options, alignTo, isNew</span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                inverted = chart.inverted,
                plotX = pick(point.plotX, <span class="hljs-number">-9999</span>),
                plotY = pick(point.plotY, <span class="hljs-number">-9999</span>),
                bBox = dataLabel.getBBox(),
                fontSize,
                baseline,
                rotation = options.rotation,
                normRotation,
                negRotation,
                align = options.align,
                rotCorr,
                visible =
                <span class="hljs-keyword">this</span>.visible &amp;&amp;
                (
                    point.series.forceDL ||
                    chart.isInsidePlot(plotX, <span class="hljs-built_in">Math</span>.round(plotY), inverted) ||
                    (
                        alignTo &amp;&amp; chart.isInsidePlot(
                            plotX,
                            inverted ? alignTo.x + <span class="hljs-number">1</span> : alignTo.y + alignTo.height - <span class="hljs-number">1</span>,
                            inverted
                        )
                    )
                ),
                alignAttr,
                justify = pick(options.overflow, <span class="hljs-string">'justify'</span>) === <span class="hljs-string">'justify'</span>;
            <span class="hljs-keyword">if</span> (visible) {
                fontSize = options.style.fontSize;
                baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;
                alignTo = extend({
                    <span class="hljs-attr">x</span>: inverted ? chart.plotWidth - plotY : plotX,
                    <span class="hljs-attr">y</span>: <span class="hljs-built_in">Math</span>.round(inverted ? chart.plotHeight - plotX : plotY),
                    <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>
                }, alignTo);
                extend(options, {
                    <span class="hljs-attr">width</span>: bBox.width,
                    <span class="hljs-attr">height</span>: bBox.height
                });
                <span class="hljs-keyword">if</span> (rotation) {
                    justify = <span class="hljs-literal">false</span>;
                    rotCorr = chart.renderer.rotCorr(baseline, rotation);
                    alignAttr = {
                        <span class="hljs-attr">x</span>: alignTo.x + options.x + alignTo.width / <span class="hljs-number">2</span> + rotCorr.x,
                        <span class="hljs-attr">y</span>: alignTo.y + options.y + {
                            <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">middle</span>: <span class="hljs-number">0.5</span>,
                            <span class="hljs-attr">bottom</span>: <span class="hljs-number">1</span>
                        }[options.verticalAlign] * alignTo.height
                    };
                    dataLabel[isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>](alignAttr)
                        .attr({
                            <span class="hljs-attr">align</span>: align
                        });
                    normRotation = (rotation + <span class="hljs-number">720</span>) % <span class="hljs-number">360</span>;
                    negRotation = normRotation &gt; <span class="hljs-number">180</span> &amp;&amp; normRotation &lt; <span class="hljs-number">360</span>;
                    <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'left'</span>) {
                        alignAttr.y -= negRotation ? bBox.height : <span class="hljs-number">0</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'center'</span>) {
                        alignAttr.x -= bBox.width / <span class="hljs-number">2</span>;
                        alignAttr.y -= bBox.height / <span class="hljs-number">2</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'right'</span>) {
                        alignAttr.x -= bBox.width;
                        alignAttr.y -= negRotation ? <span class="hljs-number">0</span> : bBox.height;
                    }
                } <span class="hljs-keyword">else</span> {
                    dataLabel.align(options, <span class="hljs-literal">null</span>, alignTo);
                    alignAttr = dataLabel.alignAttr;
                }
                <span class="hljs-keyword">if</span> (justify) {
                    <span class="hljs-keyword">this</span>.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pick(options.crop, <span class="hljs-literal">true</span>)) {
                    visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) &amp;&amp; chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);
                }
                <span class="hljs-keyword">if</span> (options.shape &amp;&amp; !rotation) {
                    dataLabel.attr({
                        <span class="hljs-attr">anchorX</span>: point.plotX,
                        <span class="hljs-attr">anchorY</span>: point.plotY
                    });
                }
            }
            <span class="hljs-keyword">if</span> (!visible) {
                dataLabel.attr({
                    <span class="hljs-attr">y</span>: <span class="hljs-number">-9999</span>
                });
                dataLabel.placed = <span class="hljs-literal">false</span>;
            }
        };
        Series.prototype.justifyDataLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dataLabel, options, alignAttr, bBox, alignTo, isNew</span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                align = options.align,
                verticalAlign = options.verticalAlign,
                off,
                justified,
                padding = dataLabel.box ? <span class="hljs-number">0</span> : (dataLabel.padding || <span class="hljs-number">0</span>);
            off = alignAttr.x + padding;
            <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'right'</span>) {
                    options.align = <span class="hljs-string">'left'</span>;
                } <span class="hljs-keyword">else</span> {
                    options.x = -off;
                }
                justified = <span class="hljs-literal">true</span>;
            }
            off = alignAttr.x + bBox.width - padding;
            <span class="hljs-keyword">if</span> (off &gt; chart.plotWidth) {
                <span class="hljs-keyword">if</span> (align === <span class="hljs-string">'left'</span>) {
                    options.align = <span class="hljs-string">'right'</span>;
                } <span class="hljs-keyword">else</span> {
                    options.x = chart.plotWidth - off;
                }
                justified = <span class="hljs-literal">true</span>;
            }
            off = alignAttr.y + padding;
            <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (verticalAlign === <span class="hljs-string">'bottom'</span>) {
                    options.verticalAlign = <span class="hljs-string">'top'</span>;
                } <span class="hljs-keyword">else</span> {
                    options.y = -off;
                }
                justified = <span class="hljs-literal">true</span>;
            }
            off = alignAttr.y + bBox.height - padding;
            <span class="hljs-keyword">if</span> (off &gt; chart.plotHeight) {
                <span class="hljs-keyword">if</span> (verticalAlign === <span class="hljs-string">'top'</span>) {
                    options.verticalAlign = <span class="hljs-string">'bottom'</span>;
                } <span class="hljs-keyword">else</span> {
                    options.y = chart.plotHeight - off;
                }
                justified = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">if</span> (justified) {
                dataLabel.placed = !isNew;
                dataLabel.align(options, <span class="hljs-literal">null</span>, alignTo);
            }
        };
        <span class="hljs-keyword">if</span> (seriesTypes.pie) {
            seriesTypes.pie.prototype.drawDataLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    data = series.data,
                    point,
                    chart = series.chart,
                    options = series.options.dataLabels,
                    connectorPadding = pick(options.connectorPadding, <span class="hljs-number">10</span>),
                    connectorWidth = pick(options.connectorWidth, <span class="hljs-number">1</span>),
                    plotWidth = chart.plotWidth,
                    plotHeight = chart.plotHeight,
                    connector,
                    distanceOption = options.distance,
                    seriesCenter = series.center,
                    radius = seriesCenter[<span class="hljs-number">2</span>] / <span class="hljs-number">2</span>,
                    centerY = seriesCenter[<span class="hljs-number">1</span>],
                    outside = distanceOption &gt; <span class="hljs-number">0</span>,
                    dataLabel,
                    dataLabelWidth,
                    labelPos,
                    labelHeight,
                    halves = [
                        [],
                        []
                    ],
                    x,
                    y,
                    visibility,
                    j,
                    overflow = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
                <span class="hljs-keyword">if</span> (!series.visible || (!options.enabled &amp;&amp; !series._hasPointLabels)) {
                    <span class="hljs-keyword">return</span>;
                }
                Series.prototype.drawDataLabels.apply(series);
                each(data, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">if</span> (point.dataLabel &amp;&amp; point.visible) {
                        halves[point.half].push(point);
                        point.dataLabel._pos = <span class="hljs-literal">null</span>;
                    }
                });
                each(halves, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, i</span>) </span>{
                    <span class="hljs-keyword">var</span> top,
                        bottom,
                        length = points.length,
                        positions,
                        naturalY,
                        size;
                    <span class="hljs-keyword">if</span> (!length) {
                        <span class="hljs-keyword">return</span>;
                    }
                    series.sortByAngle(points, i - <span class="hljs-number">0.5</span>);
                    <span class="hljs-keyword">if</span> (distanceOption &gt; <span class="hljs-number">0</span>) {
                        top = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, centerY - radius - distanceOption);
                        bottom = <span class="hljs-built_in">Math</span>.min(centerY + radius + distanceOption, chart.plotHeight);
                        positions = map(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                            <span class="hljs-keyword">if</span> (point.dataLabel) {
                                size = point.dataLabel.getBBox().height || <span class="hljs-number">21</span>;
                                <span class="hljs-keyword">return</span> {
                                    <span class="hljs-attr">target</span>: point.labelPos[<span class="hljs-number">1</span>] - top + size / <span class="hljs-number">2</span>,
                                    <span class="hljs-attr">size</span>: size,
                                    <span class="hljs-attr">rank</span>: point.y
                                };
                            }
                        });
                        H.distribute(positions, bottom + size - top);
                    }
                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; length; j++) {
                        point = points[j];
                        labelPos = point.labelPos;
                        dataLabel = point.dataLabel;
                        visibility = point.visible === <span class="hljs-literal">false</span> ? <span class="hljs-string">'hidden'</span> : <span class="hljs-string">'inherit'</span>;
                        naturalY = labelPos[<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">if</span> (positions) {
                            <span class="hljs-keyword">if</span> (positions[j].pos === <span class="hljs-literal">undefined</span>) {
                                visibility = <span class="hljs-string">'hidden'</span>;
                            } <span class="hljs-keyword">else</span> {
                                labelHeight = positions[j].size;
                                y = top + positions[j].pos;
                            }
                        } <span class="hljs-keyword">else</span> {
                            y = naturalY;
                        }
                        <span class="hljs-keyword">if</span> (options.justify) {
                            x = seriesCenter[<span class="hljs-number">0</span>] + (i ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>) * (radius + distanceOption);
                        } <span class="hljs-keyword">else</span> {
                            x = series.getX(y &lt; top + <span class="hljs-number">2</span> || y &gt; bottom - <span class="hljs-number">2</span> ? naturalY : y, i);
                        }
                        dataLabel._attr = {
                            <span class="hljs-attr">visibility</span>: visibility,
                            <span class="hljs-attr">align</span>: labelPos[<span class="hljs-number">6</span>]
                        };
                        dataLabel._pos = {
                            <span class="hljs-attr">x</span>: x + options.x +
                                ({
                                    <span class="hljs-attr">left</span>: connectorPadding,
                                    <span class="hljs-attr">right</span>: -connectorPadding
                                }[labelPos[<span class="hljs-number">6</span>]] || <span class="hljs-number">0</span>),
                            <span class="hljs-attr">y</span>: y + options.y - <span class="hljs-number">10</span>
                        };
                        labelPos.x = x;
                        labelPos.y = y;
                        <span class="hljs-keyword">if</span> (series.options.size === <span class="hljs-literal">null</span>) {
                            dataLabelWidth = dataLabel.width;
                            <span class="hljs-keyword">if</span> (x - dataLabelWidth &lt; connectorPadding) {
                                overflow[<span class="hljs-number">3</span>] = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.round(dataLabelWidth - x + connectorPadding), overflow[<span class="hljs-number">3</span>]);
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x + dataLabelWidth &gt; plotWidth - connectorPadding) {
                                overflow[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.round(x + dataLabelWidth - plotWidth + connectorPadding), overflow[<span class="hljs-number">1</span>]);
                            }
                            <span class="hljs-keyword">if</span> (y - labelHeight / <span class="hljs-number">2</span> &lt; <span class="hljs-number">0</span>) {
                                overflow[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.round(-y + labelHeight / <span class="hljs-number">2</span>), overflow[<span class="hljs-number">0</span>]);
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (y + labelHeight / <span class="hljs-number">2</span> &gt; plotHeight) {
                                overflow[<span class="hljs-number">2</span>] = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.round(y + labelHeight / <span class="hljs-number">2</span> - plotHeight), overflow[<span class="hljs-number">2</span>]);
                            }
                        }
                    }
                });
                <span class="hljs-keyword">if</span> (arrayMax(overflow) === <span class="hljs-number">0</span> || <span class="hljs-keyword">this</span>.verifyDataLabelOverflow(overflow)) {
                    <span class="hljs-keyword">this</span>.placeDataLabels();
                    <span class="hljs-keyword">if</span> (outside &amp;&amp; connectorWidth) {
                        each(<span class="hljs-keyword">this</span>.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                            <span class="hljs-keyword">var</span> isNew;
                            connector = point.connector;
                            dataLabel = point.dataLabel;
                            <span class="hljs-keyword">if</span> (dataLabel &amp;&amp; dataLabel._pos &amp;&amp; point.visible) {
                                visibility = dataLabel._attr.visibility;
                                isNew = !connector;
                                <span class="hljs-keyword">if</span> (isNew) {
                                    point.connector = connector = chart.renderer.path()
                                        .addClass(<span class="hljs-string">'highcharts-data-label-connector highcharts-color-'</span> + point.colorIndex)
                                        .add(series.dataLabelsGroup);
                                    connector.attr({
                                        <span class="hljs-string">'stroke-width'</span>: connectorWidth,
                                        <span class="hljs-string">'stroke'</span>: options.connectorColor || point.color || <span class="hljs-string">'#666666'</span>
                                    });
                                }
                                connector[isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>]({
                                    <span class="hljs-attr">d</span>: series.connectorPath(point.labelPos)
                                });
                                connector.attr(<span class="hljs-string">'visibility'</span>, visibility);
                            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (connector) {
                                point.connector = connector.destroy();
                            }
                        });
                    }
                }
            };
            seriesTypes.pie.prototype.connectorPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">labelPos</span>) </span>{
                <span class="hljs-keyword">var</span> x = labelPos.x,
                    y = labelPos.y;
                <span class="hljs-keyword">return</span> pick(<span class="hljs-keyword">this</span>.options.dataLabels.softConnector, <span class="hljs-literal">true</span>) ? [
                    <span class="hljs-string">'M'</span>,
                    x + (labelPos[<span class="hljs-number">6</span>] === <span class="hljs-string">'left'</span> ? <span class="hljs-number">5</span> : <span class="hljs-number">-5</span>), y,
                    <span class="hljs-string">'C'</span>,
                    x, y,
                    <span class="hljs-number">2</span> * labelPos[<span class="hljs-number">2</span>] - labelPos[<span class="hljs-number">4</span>], <span class="hljs-number">2</span> * labelPos[<span class="hljs-number">3</span>] - labelPos[<span class="hljs-number">5</span>],
                    labelPos[<span class="hljs-number">2</span>], labelPos[<span class="hljs-number">3</span>],
                    <span class="hljs-string">'L'</span>,
                    labelPos[<span class="hljs-number">4</span>], labelPos[<span class="hljs-number">5</span>]
                ] : [
                    <span class="hljs-string">'M'</span>,
                    x + (labelPos[<span class="hljs-number">6</span>] === <span class="hljs-string">'left'</span> ? <span class="hljs-number">5</span> : <span class="hljs-number">-5</span>), y,
                    <span class="hljs-string">'L'</span>,
                    labelPos[<span class="hljs-number">2</span>], labelPos[<span class="hljs-number">3</span>],
                    <span class="hljs-string">'L'</span>,
                    labelPos[<span class="hljs-number">4</span>], labelPos[<span class="hljs-number">5</span>]
                ];
            };
            seriesTypes.pie.prototype.placeDataLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                each(<span class="hljs-keyword">this</span>.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> dataLabel = point.dataLabel,
                        _pos;
                    <span class="hljs-keyword">if</span> (dataLabel &amp;&amp; point.visible) {
                        _pos = dataLabel._pos;
                        <span class="hljs-keyword">if</span> (_pos) {
                            dataLabel.attr(dataLabel._attr);
                            dataLabel[dataLabel.moved ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>](_pos);
                            dataLabel.moved = <span class="hljs-literal">true</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dataLabel) {
                            dataLabel.attr({
                                <span class="hljs-attr">y</span>: <span class="hljs-number">-9999</span>
                            });
                        }
                    }
                });
            };
            seriesTypes.pie.prototype.alignDataLabel = noop;
            seriesTypes.pie.prototype.verifyDataLabelOverflow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">overflow</span>) </span>{
                <span class="hljs-keyword">var</span> center = <span class="hljs-keyword">this</span>.center,
                    options = <span class="hljs-keyword">this</span>.options,
                    centerOption = options.center,
                    minSize = options.minSize || <span class="hljs-number">80</span>,
                    newSize = minSize,
                    ret;
                <span class="hljs-keyword">if</span> (centerOption[<span class="hljs-number">0</span>] !== <span class="hljs-literal">null</span>) {
                    newSize = <span class="hljs-built_in">Math</span>.max(center[<span class="hljs-number">2</span>] - <span class="hljs-built_in">Math</span>.max(overflow[<span class="hljs-number">1</span>], overflow[<span class="hljs-number">3</span>]), minSize);
                } <span class="hljs-keyword">else</span> {
                    newSize = <span class="hljs-built_in">Math</span>.max(
                        center[<span class="hljs-number">2</span>] - overflow[<span class="hljs-number">1</span>] - overflow[<span class="hljs-number">3</span>],
                        minSize
                    );
                    center[<span class="hljs-number">0</span>] += (overflow[<span class="hljs-number">3</span>] - overflow[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (centerOption[<span class="hljs-number">1</span>] !== <span class="hljs-literal">null</span>) {
                    newSize = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.min(newSize, center[<span class="hljs-number">2</span>] - <span class="hljs-built_in">Math</span>.max(overflow[<span class="hljs-number">0</span>], overflow[<span class="hljs-number">2</span>])), minSize);
                } <span class="hljs-keyword">else</span> {
                    newSize = <span class="hljs-built_in">Math</span>.max(
                        <span class="hljs-built_in">Math</span>.min(
                            newSize,
                            center[<span class="hljs-number">2</span>] - overflow[<span class="hljs-number">0</span>] - overflow[<span class="hljs-number">2</span>]
                        ),
                        minSize
                    );
                    center[<span class="hljs-number">1</span>] += (overflow[<span class="hljs-number">0</span>] - overflow[<span class="hljs-number">2</span>]) / <span class="hljs-number">2</span>;
                }
                <span class="hljs-keyword">if</span> (newSize &lt; center[<span class="hljs-number">2</span>]) {
                    center[<span class="hljs-number">2</span>] = newSize;
                    center[<span class="hljs-number">3</span>] = <span class="hljs-built_in">Math</span>.min(relativeLength(options.innerSize || <span class="hljs-number">0</span>, newSize), newSize);
                    <span class="hljs-keyword">this</span>.translate(center);
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.drawDataLabels) {
                        <span class="hljs-keyword">this</span>.drawDataLabels();
                    }
                } <span class="hljs-keyword">else</span> {
                    ret = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">return</span> ret;
            };
        }
        <span class="hljs-keyword">if</span> (seriesTypes.column) {
            seriesTypes.column.prototype.alignDataLabel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, dataLabel, options, alignTo, isNew</span>) </span>{
                <span class="hljs-keyword">var</span> inverted = <span class="hljs-keyword">this</span>.chart.inverted,
                    series = point.series,
                    dlBox = point.dlBox || point.shapeArgs,
                    below = pick(point.below, point.plotY &gt; pick(<span class="hljs-keyword">this</span>.translatedThreshold, series.yAxis.len)),
                    inside = pick(options.inside, !!<span class="hljs-keyword">this</span>.options.stacking),
                    overshoot;
                <span class="hljs-keyword">if</span> (dlBox) {
                    alignTo = merge(dlBox);
                    <span class="hljs-keyword">if</span> (alignTo.y &lt; <span class="hljs-number">0</span>) {
                        alignTo.height += alignTo.y;
                        alignTo.y = <span class="hljs-number">0</span>;
                    }
                    overshoot = alignTo.y + alignTo.height - series.yAxis.len;
                    <span class="hljs-keyword">if</span> (overshoot &gt; <span class="hljs-number">0</span>) {
                        alignTo.height -= overshoot;
                    }
                    <span class="hljs-keyword">if</span> (inverted) {
                        alignTo = {
                            <span class="hljs-attr">x</span>: series.yAxis.len - alignTo.y - alignTo.height,
                            <span class="hljs-attr">y</span>: series.xAxis.len - alignTo.x - alignTo.width,
                            <span class="hljs-attr">width</span>: alignTo.height,
                            <span class="hljs-attr">height</span>: alignTo.width
                        };
                    }
                    <span class="hljs-keyword">if</span> (!inside) {
                        <span class="hljs-keyword">if</span> (inverted) {
                            alignTo.x += below ? <span class="hljs-number">0</span> : alignTo.width;
                            alignTo.width = <span class="hljs-number">0</span>;
                        } <span class="hljs-keyword">else</span> {
                            alignTo.y += below ? alignTo.height : <span class="hljs-number">0</span>;
                            alignTo.height = <span class="hljs-number">0</span>;
                        }
                    }
                }
                options.align = pick(
                    options.align, !inverted || inside ? <span class="hljs-string">'center'</span> : below ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>
                );
                options.verticalAlign = pick(
                    options.verticalAlign,
                    inverted || inside ? <span class="hljs-string">'middle'</span> : below ? <span class="hljs-string">'top'</span> : <span class="hljs-string">'bottom'</span>
                );
                Series.prototype.alignDataLabel.call(<span class="hljs-keyword">this</span>, point, dataLabel, options, alignTo, isNew);
            };
        }
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Chart = H.Chart,
            each = H.each,
            pick = H.pick,
            addEvent = H.addEvent;
        Chart.prototype.callbacks.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart</span>) </span>{
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">collectAndHide</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> labels = [];
                each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    <span class="hljs-keyword">var</span> dlOptions = series.options.dataLabels,
                        collections = series.dataLabelCollections || [<span class="hljs-string">'dataLabel'</span>];
                    <span class="hljs-keyword">if</span> ((dlOptions.enabled || series._hasPointLabels) &amp;&amp; !dlOptions.allowOverlap &amp;&amp; series.visible) {
                        each(collections, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                            each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                                <span class="hljs-keyword">if</span> (point[coll]) {
                                    point[coll].labelrank = pick(point.labelrank, point.shapeArgs &amp;&amp; point.shapeArgs.height);
                                    labels.push(point[coll]);
                                }
                            });
                        });
                    }
                });
                chart.hideOverlappingLabels(labels);
            }
            collectAndHide();
            addEvent(chart, <span class="hljs-string">'redraw'</span>, collectAndHide);
        });
        Chart.prototype.hideOverlappingLabels = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">labels</span>) </span>{
            <span class="hljs-keyword">var</span> len = labels.length,
                label,
                i,
                j,
                label1,
                label2,
                isIntersecting,
                pos1,
                pos2,
                parent1,
                parent2,
                padding,
                intersectRect = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x1, y1, w1, h1, x2, y2, w2, h2</span>) </span>{
                    <span class="hljs-keyword">return</span> !(
                        x2 &gt; x1 + w1 ||
                        x2 + w2 &lt; x1 ||
                        y2 &gt; y1 + h1 ||
                        y2 + h2 &lt; y1
                    );
                };
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                label = labels[i];
                <span class="hljs-keyword">if</span> (label) {
                    label.oldOpacity = label.opacity;
                    label.newOpacity = <span class="hljs-number">1</span>;
                }
            }
            labels.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                <span class="hljs-keyword">return</span> (b.labelrank || <span class="hljs-number">0</span>) - (a.labelrank || <span class="hljs-number">0</span>);
            });
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) {
                label1 = labels[i];
                <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; len; ++j) {
                    label2 = labels[j];
                    <span class="hljs-keyword">if</span> (label1 &amp;&amp; label2 &amp;&amp; label1.placed &amp;&amp; label2.placed &amp;&amp; label1.newOpacity !== <span class="hljs-number">0</span> &amp;&amp; label2.newOpacity !== <span class="hljs-number">0</span>) {
                        pos1 = label1.alignAttr;
                        pos2 = label2.alignAttr;
                        parent1 = label1.parentGroup;
                        parent2 = label2.parentGroup;
                        padding = <span class="hljs-number">2</span> * (label1.box ? <span class="hljs-number">0</span> : label1.padding);
                        isIntersecting = intersectRect(
                            pos1.x + parent1.translateX,
                            pos1.y + parent1.translateY,
                            label1.width - padding,
                            label1.height - padding,
                            pos2.x + parent2.translateX,
                            pos2.y + parent2.translateY,
                            label2.width - padding,
                            label2.height - padding
                        );
                        <span class="hljs-keyword">if</span> (isIntersecting) {
                            (label1.labelrank &lt; label2.labelrank ? label1 : label2).newOpacity = <span class="hljs-number">0</span>;
                        }
                    }
                }
            }
            each(labels, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">label</span>) </span>{
                <span class="hljs-keyword">var</span> complete,
                    newOpacity;
                <span class="hljs-keyword">if</span> (label) {
                    newOpacity = label.newOpacity;
                    <span class="hljs-keyword">if</span> (label.oldOpacity !== newOpacity &amp;&amp; label.placed) {
                        <span class="hljs-keyword">if</span> (newOpacity) {
                            label.show(<span class="hljs-literal">true</span>);
                        } <span class="hljs-keyword">else</span> {
                            complete = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                label.hide();
                            };
                        }
                        label.alignAttr.opacity = newOpacity;
                        label[label.isOld ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>](label.alignAttr, <span class="hljs-literal">null</span>, complete);
                    }
                    label.isOld = <span class="hljs-literal">true</span>;
                }
            });
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            Chart = H.Chart,
            createElement = H.createElement,
            css = H.css,
            defaultOptions = H.defaultOptions,
            defaultPlotOptions = H.defaultPlotOptions,
            each = H.each,
            extend = H.extend,
            fireEvent = H.fireEvent,
            hasTouch = H.hasTouch,
            inArray = H.inArray,
            isObject = H.isObject,
            Legend = H.Legend,
            merge = H.merge,
            pick = H.pick,
            Point = H.Point,
            Series = H.Series,
            seriesTypes = H.seriesTypes,
            svg = H.svg,
            TrackerMixin;
        TrackerMixin = H.TrackerMixin = {
            <span class="hljs-attr">drawTrackerPoint</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    pointer = chart.pointer,
                    onMouseOver = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">var</span> target = e.target,
                            point;
                        <span class="hljs-keyword">while</span> (target &amp;&amp; !point) {
                            point = target.point;
                            target = target.parentNode;
                        }
                        <span class="hljs-keyword">if</span> (point !== <span class="hljs-literal">undefined</span> &amp;&amp; point !== chart.hoverPoint) {
                            point.onMouseOver(e);
                        }
                    };
                each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">if</span> (point.graphic) {
                        point.graphic.element.point = point;
                    }
                    <span class="hljs-keyword">if</span> (point.dataLabel) {
                        <span class="hljs-keyword">if</span> (point.dataLabel.div) {
                            point.dataLabel.div.point = point;
                        } <span class="hljs-keyword">else</span> {
                            point.dataLabel.element.point = point;
                        }
                    }
                });
                <span class="hljs-keyword">if</span> (!series._hasTracking) {
                    each(series.trackerGroups, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                        <span class="hljs-keyword">if</span> (series[key]) {
                            series[key]
                                .addClass(<span class="hljs-string">'highcharts-tracker'</span>)
                                .on(<span class="hljs-string">'mouseover'</span>, onMouseOver)
                                .on(<span class="hljs-string">'mouseout'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                                    pointer.onTrackerMouseOut(e);
                                });
                            <span class="hljs-keyword">if</span> (hasTouch) {
                                series[key].on(<span class="hljs-string">'touchstart'</span>, onMouseOver);
                            }
                            <span class="hljs-keyword">if</span> (series.options.cursor) {
                                series[key]
                                    .css(css)
                                    .css({
                                        <span class="hljs-attr">cursor</span>: series.options.cursor
                                    });
                            }
                        }
                    });
                    series._hasTracking = <span class="hljs-literal">true</span>;
                }
            },
            <span class="hljs-attr">drawTrackerGraph</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    trackByArea = options.trackByArea,
                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),
                    trackerPathLength = trackerPath.length,
                    chart = series.chart,
                    pointer = chart.pointer,
                    renderer = chart.renderer,
                    snap = chart.options.tooltip.snap,
                    tracker = series.tracker,
                    i,
                    onMouseOver = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">if</span> (chart.hoverSeries !== series) {
                            series.onMouseOver();
                        }
                    },
                    TRACKER_FILL = <span class="hljs-string">'rgba(192,192,192,'</span> + (svg ? <span class="hljs-number">0.0001</span> : <span class="hljs-number">0.002</span>) + <span class="hljs-string">')'</span>;
                <span class="hljs-keyword">if</span> (trackerPathLength &amp;&amp; !trackByArea) {
                    i = trackerPathLength + <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (trackerPath[i] === <span class="hljs-string">'M'</span>) {
                            trackerPath.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, trackerPath[i + <span class="hljs-number">1</span>] - snap, trackerPath[i + <span class="hljs-number">2</span>], <span class="hljs-string">'L'</span>);
                        }
                        <span class="hljs-keyword">if</span> ((i &amp;&amp; trackerPath[i] === <span class="hljs-string">'M'</span>) || i === trackerPathLength) {
                            trackerPath.splice(i, <span class="hljs-number">0</span>, <span class="hljs-string">'L'</span>, trackerPath[i - <span class="hljs-number">2</span>] + snap, trackerPath[i - <span class="hljs-number">1</span>]);
                        }
                    }
                }
                <span class="hljs-keyword">if</span> (tracker) {
                    tracker.attr({
                        <span class="hljs-attr">d</span>: trackerPath
                    });
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (series.graph) {
                    series.tracker = renderer.path(trackerPath)
                        .attr({
                            <span class="hljs-string">'stroke-linejoin'</span>: <span class="hljs-string">'round'</span>,
                            <span class="hljs-attr">visibility</span>: series.visible ? <span class="hljs-string">'visible'</span> : <span class="hljs-string">'hidden'</span>,
                            <span class="hljs-attr">stroke</span>: TRACKER_FILL,
                            <span class="hljs-attr">fill</span>: trackByArea ? TRACKER_FILL : <span class="hljs-string">'none'</span>,
                            <span class="hljs-string">'stroke-width'</span>: series.graph.strokeWidth() + (trackByArea ? <span class="hljs-number">0</span> : <span class="hljs-number">2</span> * snap),
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>
                        })
                        .add(series.group);
                    each([series.tracker, series.markerGroup], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tracker</span>) </span>{
                        tracker.addClass(<span class="hljs-string">'highcharts-tracker'</span>)
                            .on(<span class="hljs-string">'mouseover'</span>, onMouseOver)
                            .on(<span class="hljs-string">'mouseout'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                                pointer.onTrackerMouseOut(e);
                            });
                        <span class="hljs-keyword">if</span> (options.cursor) {
                            tracker.css({
                                <span class="hljs-attr">cursor</span>: options.cursor
                            });
                        }
                        <span class="hljs-keyword">if</span> (hasTouch) {
                            tracker.on(<span class="hljs-string">'touchstart'</span>, onMouseOver);
                        }
                    });
                }
            }
        };
        <span class="hljs-keyword">if</span> (seriesTypes.column) {
            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        <span class="hljs-keyword">if</span> (seriesTypes.pie) {
            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        <span class="hljs-keyword">if</span> (seriesTypes.scatter) {
            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;
        }
        extend(Legend.prototype, {
            <span class="hljs-attr">setItemEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, legendItem, useHTML</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>,
                    chart = legend.chart,
                    activeClass = <span class="hljs-string">'highcharts-legend-'</span> + (item.series ? <span class="hljs-string">'point'</span> : <span class="hljs-string">'series'</span>) + <span class="hljs-string">'-active'</span>;
                (useHTML ? legendItem : item.legendGroup).on(<span class="hljs-string">'mouseover'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        item.setState(<span class="hljs-string">'hover'</span>);
                        chart.seriesGroup.addClass(activeClass);
                        legendItem.css(legend.options.itemHoverStyle);
                    })
                    .on(<span class="hljs-string">'mouseout'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        legendItem.css(item.visible ? legend.itemStyle : legend.itemHiddenStyle);
                        chart.seriesGroup.removeClass(activeClass);
                        item.setState();
                    })
                    .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                        <span class="hljs-keyword">var</span> strLegendItemClick = <span class="hljs-string">'legendItemClick'</span>,
                            fnLegendItemClick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                <span class="hljs-keyword">if</span> (item.setVisible) {
                                    item.setVisible();
                                }
                            };
                        event = {
                            <span class="hljs-attr">browserEvent</span>: event
                        };
                        <span class="hljs-keyword">if</span> (item.firePointEvent) {
                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                        } <span class="hljs-keyword">else</span> {
                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                        }
                    });
            },
            <span class="hljs-attr">createCheckboxForItem</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
                <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>;
                item.checkbox = createElement(<span class="hljs-string">'input'</span>, {
                    <span class="hljs-attr">type</span>: <span class="hljs-string">'checkbox'</span>,
                    <span class="hljs-attr">checked</span>: item.selected,
                    <span class="hljs-attr">defaultChecked</span>: item.selected
                }, legend.options.itemCheckboxStyle, legend.chart.container);
                addEvent(item.checkbox, <span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                    <span class="hljs-keyword">var</span> target = event.target;
                    fireEvent(
                        item.series || item,
                        <span class="hljs-string">'checkboxClick'</span>, {
                            <span class="hljs-attr">checked</span>: target.checked,
                            <span class="hljs-attr">item</span>: item
                        },
                        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            item.select();
                        }
                    );
                });
            }
        });
        defaultOptions.legend.itemStyle.cursor = <span class="hljs-string">'pointer'</span>;
        extend(Chart.prototype, {
            <span class="hljs-attr">showResetZoom</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    lang = defaultOptions.lang,
                    btnOptions = chart.options.chart.resetZoomButton,
                    theme = btnOptions.theme,
                    states = theme.states,
                    alignTo = btnOptions.relativeTo === <span class="hljs-string">'chart'</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">'plotBox'</span>;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zoomOut</span>(<span class="hljs-params"></span>) </span>{
                    chart.zoomOut();
                }
                <span class="hljs-keyword">this</span>.resetZoomButton = chart.renderer.button(lang.resetZoom, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, zoomOut, theme, states &amp;&amp; states.hover)
                    .attr({
                        <span class="hljs-attr">align</span>: btnOptions.position.align,
                        <span class="hljs-attr">title</span>: lang.resetZoomTitle
                    })
                    .addClass(<span class="hljs-string">'highcharts-reset-zoom'</span>)
                    .add()
                    .align(btnOptions.position, <span class="hljs-literal">false</span>, alignTo);
            },
            <span class="hljs-attr">zoomOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>;
                fireEvent(chart, <span class="hljs-string">'selection'</span>, {
                    <span class="hljs-attr">resetSelection</span>: <span class="hljs-literal">true</span>
                }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    chart.zoom();
                });
            },
            <span class="hljs-attr">zoom</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    hasZoomed,
                    pointer = chart.pointer,
                    displayButton = <span class="hljs-literal">false</span>,
                    resetZoomButton;
                <span class="hljs-keyword">if</span> (!event || event.resetSelection) {
                    each(chart.axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis</span>) </span>{
                        hasZoomed = axis.zoom();
                    });
                } <span class="hljs-keyword">else</span> {
                    each(event.xAxis.concat(event.yAxis), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axisData</span>) </span>{
                        <span class="hljs-keyword">var</span> axis = axisData.axis,
                            isXAxis = axis.isXAxis;
                        <span class="hljs-keyword">if</span> (pointer[isXAxis ? <span class="hljs-string">'zoomX'</span> : <span class="hljs-string">'zoomY'</span>]) {
                            hasZoomed = axis.zoom(axisData.min, axisData.max);
                            <span class="hljs-keyword">if</span> (axis.displayBtn) {
                                displayButton = <span class="hljs-literal">true</span>;
                            }
                        }
                    });
                }
                resetZoomButton = chart.resetZoomButton;
                <span class="hljs-keyword">if</span> (displayButton &amp;&amp; !resetZoomButton) {
                    chart.showResetZoom();
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!displayButton &amp;&amp; isObject(resetZoomButton)) {
                    chart.resetZoomButton = resetZoomButton.destroy();
                }
                <span class="hljs-keyword">if</span> (hasZoomed) {
                    chart.redraw(
                        pick(chart.options.chart.animation, event &amp;&amp; event.animation, chart.pointCount &lt; <span class="hljs-number">100</span>)
                    );
                }
            },
            <span class="hljs-attr">pan</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, panning</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                    hoverPoints = chart.hoverPoints,
                    doRedraw;
                <span class="hljs-keyword">if</span> (hoverPoints) {
                    each(hoverPoints, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                        point.setState();
                    });
                }
                each(panning === <span class="hljs-string">'xy'</span> ? [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] : [<span class="hljs-number">1</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isX</span>) </span>{
                    <span class="hljs-keyword">var</span> axis = chart[isX ? <span class="hljs-string">'xAxis'</span> : <span class="hljs-string">'yAxis'</span>][<span class="hljs-number">0</span>],
                        horiz = axis.horiz,
                        mousePos = e[horiz ? <span class="hljs-string">'chartX'</span> : <span class="hljs-string">'chartY'</span>],
                        mouseDown = horiz ? <span class="hljs-string">'mouseDownX'</span> : <span class="hljs-string">'mouseDownY'</span>,
                        startPos = chart[mouseDown],
                        halfPointRange = (axis.pointRange || <span class="hljs-number">0</span>) / <span class="hljs-number">2</span>,
                        extremes = axis.getExtremes(),
                        panMin = axis.toValue(startPos - mousePos, <span class="hljs-literal">true</span>) +
                        halfPointRange,
                        panMax = axis.toValue(startPos + axis.len - mousePos, <span class="hljs-literal">true</span>) -
                        halfPointRange,
                        flipped = panMax &lt; panMin,
                        newMin = flipped ? panMax : panMin,
                        newMax = flipped ? panMin : panMax,
                        distMin = <span class="hljs-built_in">Math</span>.min(extremes.dataMin, extremes.min) - newMin,
                        distMax = newMax - <span class="hljs-built_in">Math</span>.max(extremes.dataMax, extremes.max);
                    <span class="hljs-keyword">if</span> (axis.series.length &amp;&amp; distMin &lt; <span class="hljs-number">0</span> &amp;&amp; distMax &lt; <span class="hljs-number">0</span>) {
                        axis.setExtremes(
                            newMin,
                            newMax,
                            <span class="hljs-literal">false</span>,
                            <span class="hljs-literal">false</span>, {
                                <span class="hljs-attr">trigger</span>: <span class="hljs-string">'pan'</span>
                            }
                        );
                        doRedraw = <span class="hljs-literal">true</span>;
                    }
                    chart[mouseDown] = mousePos;
                });
                <span class="hljs-keyword">if</span> (doRedraw) {
                    chart.redraw(<span class="hljs-literal">false</span>);
                }
                css(chart.container, {
                    <span class="hljs-attr">cursor</span>: <span class="hljs-string">'move'</span>
                });
            }
        });
        extend(Point.prototype, {
            <span class="hljs-attr">select</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selected, accumulate</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    chart = series.chart;
                selected = pick(selected, !point.selected);
                point.firePointEvent(selected ? <span class="hljs-string">'select'</span> : <span class="hljs-string">'unselect'</span>, {
                    <span class="hljs-attr">accumulate</span>: accumulate
                }, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    point.selected = point.options.selected = selected;
                    series.options.data[inArray(point, series.data)] = point.options;
                    point.setState(selected &amp;&amp; <span class="hljs-string">'select'</span>);
                    <span class="hljs-keyword">if</span> (!accumulate) {
                        each(chart.getSelectedPoints(), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">loopPoint</span>) </span>{
                            <span class="hljs-keyword">if</span> (loopPoint.selected &amp;&amp; loopPoint !== point) {
                                loopPoint.selected = loopPoint.options.selected = <span class="hljs-literal">false</span>;
                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;
                                loopPoint.setState(<span class="hljs-string">''</span>);
                                loopPoint.firePointEvent(<span class="hljs-string">'unselect'</span>);
                            }
                        });
                    }
                });
            },
            <span class="hljs-attr">onMouseOver</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, byProximity</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    series = point.series,
                    chart = series.chart,
                    tooltip = chart.tooltip,
                    hoverPoint = chart.hoverPoint;
                <span class="hljs-keyword">if</span> (point.series) {
                    <span class="hljs-keyword">if</span> (!byProximity) {
                        <span class="hljs-keyword">if</span> (hoverPoint &amp;&amp; hoverPoint !== point) {
                            hoverPoint.onMouseOut();
                        }
                        <span class="hljs-keyword">if</span> (chart.hoverSeries !== series) {
                            series.onMouseOver();
                        }
                        chart.hoverPoint = point;
                    }
                    <span class="hljs-keyword">if</span> (tooltip &amp;&amp; (!tooltip.shared || series.noSharedTooltip)) {
                        point.setState(<span class="hljs-string">'hover'</span>);
                        tooltip.refresh(point, e);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!tooltip) {
                        point.setState(<span class="hljs-string">'hover'</span>);
                    }
                    point.firePointEvent(<span class="hljs-string">'mouseOver'</span>);
                }
            },
            <span class="hljs-attr">onMouseOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.series.chart,
                    hoverPoints = chart.hoverPoints;
                <span class="hljs-keyword">this</span>.firePointEvent(<span class="hljs-string">'mouseOut'</span>);
                <span class="hljs-keyword">if</span> (!hoverPoints || inArray(<span class="hljs-keyword">this</span>, hoverPoints) === <span class="hljs-number">-1</span>) {
                    <span class="hljs-keyword">this</span>.setState();
                    chart.hoverPoint = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">importEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasImportedEvents) {
                    <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                        options = merge(point.series.options.point, point.options),
                        events = options.events,
                        eventType;
                    point.events = events;
                    <span class="hljs-keyword">for</span> (eventType <span class="hljs-keyword">in</span> events) {
                        addEvent(point, eventType, events[eventType]);
                    }
                    <span class="hljs-keyword">this</span>.hasImportedEvents = <span class="hljs-literal">true</span>;
                }
            },
            <span class="hljs-attr">setState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state, move</span>) </span>{
                <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>,
                    plotX = <span class="hljs-built_in">Math</span>.floor(point.plotX),
                    plotY = point.plotY,
                    series = point.series,
                    stateOptions = series.options.states[state] || {},
                    markerOptions = defaultPlotOptions[series.type].marker &amp;&amp;
                    series.options.marker,
                    normalDisabled = markerOptions &amp;&amp; markerOptions.enabled === <span class="hljs-literal">false</span>,
                    markerStateOptions = (markerOptions &amp;&amp; markerOptions.states &amp;&amp;
                        markerOptions.states[state]) || {},
                    stateDisabled = markerStateOptions.enabled === <span class="hljs-literal">false</span>,
                    stateMarkerGraphic = series.stateMarkerGraphic,
                    pointMarker = point.marker || {},
                    chart = series.chart,
                    halo = series.halo,
                    haloOptions,
                    markerAttribs,
                    hasMarkers = markerOptions &amp;&amp; series.markerAttribs,
                    newSymbol;
                state = state || <span class="hljs-string">''</span>;
                <span class="hljs-keyword">if</span> (
                    (state === point.state &amp;&amp; !move) ||
                    (point.selected &amp;&amp; state !== <span class="hljs-string">'select'</span>) ||
                    (stateOptions.enabled === <span class="hljs-literal">false</span>) ||
                    (state &amp;&amp; (stateDisabled || (normalDisabled &amp;&amp; markerStateOptions.enabled === <span class="hljs-literal">false</span>))) ||
                    (state &amp;&amp; pointMarker.states &amp;&amp; pointMarker.states[state] &amp;&amp; pointMarker.states[state].enabled === <span class="hljs-literal">false</span>)
                ) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (hasMarkers) {
                    markerAttribs = series.markerAttribs(point, state);
                }
                <span class="hljs-keyword">if</span> (point.graphic) {
                    <span class="hljs-keyword">if</span> (point.state) {
                        point.graphic.removeClass(<span class="hljs-string">'highcharts-point-'</span> + point.state);
                    }
                    <span class="hljs-keyword">if</span> (state) {
                        point.graphic.addClass(<span class="hljs-string">'highcharts-point-'</span> + state);
                    }
                    point.graphic.attr(series.pointAttribs(point, state));
                    <span class="hljs-keyword">if</span> (markerAttribs) {
                        point.graphic.animate(
                            markerAttribs,
                            pick(
                                chart.options.chart.animation,
                                markerStateOptions.animation,
                                markerOptions.animation
                            )
                        );
                    }
                    <span class="hljs-keyword">if</span> (stateMarkerGraphic) {
                        stateMarkerGraphic.hide();
                    }
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (state &amp;&amp; markerStateOptions) {
                        newSymbol = pointMarker.symbol || series.symbol;
                        <span class="hljs-keyword">if</span> (stateMarkerGraphic &amp;&amp; stateMarkerGraphic.currentSymbol !== newSymbol) {
                            stateMarkerGraphic = stateMarkerGraphic.destroy();
                        }
                        <span class="hljs-keyword">if</span> (!stateMarkerGraphic) {
                            <span class="hljs-keyword">if</span> (newSymbol) {
                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(
                                        newSymbol,
                                        markerAttribs.x,
                                        markerAttribs.y,
                                        markerAttribs.width,
                                        markerAttribs.height
                                    )
                                    .add(series.markerGroup);
                                stateMarkerGraphic.currentSymbol = newSymbol;
                            }
                        } <span class="hljs-keyword">else</span> {
                            stateMarkerGraphic[move ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>]({
                                <span class="hljs-attr">x</span>: markerAttribs.x,
                                <span class="hljs-attr">y</span>: markerAttribs.y
                            });
                        }
                        <span class="hljs-keyword">if</span> (stateMarkerGraphic) {
                            stateMarkerGraphic.attr(series.pointAttribs(point, state));
                        }
                    }
                    <span class="hljs-keyword">if</span> (stateMarkerGraphic) {
                        stateMarkerGraphic[state &amp;&amp; chart.isInsidePlot(plotX, plotY, chart.inverted) ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>]();
                        stateMarkerGraphic.element.point = point;
                    }
                }
                haloOptions = stateOptions.halo;
                <span class="hljs-keyword">if</span> (haloOptions &amp;&amp; haloOptions.size) {
                    <span class="hljs-keyword">if</span> (!halo) {
                        series.halo = halo = chart.renderer.path()
                            .add(hasMarkers ? series.markerGroup : series.group);
                    }
                    halo[move ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>]({
                        <span class="hljs-attr">d</span>: point.haloPath(haloOptions.size)
                    });
                    halo.attr({
                        <span class="hljs-string">'class'</span>: <span class="hljs-string">'highcharts-halo highcharts-color-'</span> +
                            pick(point.colorIndex, series.colorIndex)
                    });
                    halo.point = point;
                    halo.attr(extend({
                        <span class="hljs-string">'fill'</span>: point.color || series.color,
                        <span class="hljs-string">'fill-opacity'</span>: haloOptions.opacity,
                        <span class="hljs-string">'zIndex'</span>: <span class="hljs-number">-1</span>
                    }, haloOptions.attributes));
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (halo &amp;&amp; halo.point &amp;&amp; halo.point.haloPath) {
                    halo.animate({
                        <span class="hljs-attr">d</span>: halo.point.haloPath(<span class="hljs-number">0</span>)
                    });
                }
                point.state = state;
            },
            <span class="hljs-attr">haloPath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">size</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.series,
                    chart = series.chart;
                <span class="hljs-keyword">return</span> chart.renderer.symbols.circle(
                    <span class="hljs-built_in">Math</span>.floor(<span class="hljs-keyword">this</span>.plotX) - size,
                    <span class="hljs-keyword">this</span>.plotY - size,
                    size * <span class="hljs-number">2</span>,
                    size * <span class="hljs-number">2</span>
                );
            }
        });
        extend(Series.prototype, {
            <span class="hljs-attr">onMouseOver</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    hoverSeries = chart.hoverSeries;
                <span class="hljs-keyword">if</span> (hoverSeries &amp;&amp; hoverSeries !== series) {
                    hoverSeries.onMouseOut();
                }
                <span class="hljs-keyword">if</span> (series.options.events.mouseOver) {
                    fireEvent(series, <span class="hljs-string">'mouseOver'</span>);
                }
                series.setState(<span class="hljs-string">'hover'</span>);
                chart.hoverSeries = series;
            },
            <span class="hljs-attr">onMouseOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    chart = series.chart,
                    tooltip = chart.tooltip,
                    hoverPoint = chart.hoverPoint;
                chart.hoverSeries = <span class="hljs-literal">null</span>;
                <span class="hljs-keyword">if</span> (hoverPoint) {
                    hoverPoint.onMouseOut();
                }
                <span class="hljs-keyword">if</span> (series &amp;&amp; options.events.mouseOut) {
                    fireEvent(series, <span class="hljs-string">'mouseOut'</span>);
                }
                <span class="hljs-keyword">if</span> (tooltip &amp;&amp; !options.stickyTracking &amp;&amp; (!tooltip.shared || series.noSharedTooltip)) {
                    tooltip.hide();
                }
                series.setState();
            },
            <span class="hljs-attr">setState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">state</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    graph = series.graph,
                    stateOptions = options.states,
                    lineWidth = options.lineWidth,
                    attribs,
                    i = <span class="hljs-number">0</span>;
                state = state || <span class="hljs-string">''</span>;
                <span class="hljs-keyword">if</span> (series.state !== state) {
                    each([series.group, series.markerGroup], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">group</span>) </span>{
                        <span class="hljs-keyword">if</span> (group) {
                            <span class="hljs-keyword">if</span> (series.state) {
                                group.removeClass(<span class="hljs-string">'highcharts-series-'</span> + series.state);
                            }
                            <span class="hljs-keyword">if</span> (state) {
                                group.addClass(<span class="hljs-string">'highcharts-series-'</span> + state);
                            }
                        }
                    });
                    series.state = state;
                    <span class="hljs-keyword">if</span> (stateOptions[state] &amp;&amp; stateOptions[state].enabled === <span class="hljs-literal">false</span>) {
                        <span class="hljs-keyword">return</span>;
                    }
                    <span class="hljs-keyword">if</span> (state) {
                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || <span class="hljs-number">0</span>);
                    }
                    <span class="hljs-keyword">if</span> (graph &amp;&amp; !graph.dashstyle) {
                        attribs = {
                            <span class="hljs-string">'stroke-width'</span>: lineWidth
                        };
                        graph.attr(attribs);
                        <span class="hljs-keyword">while</span> (series[<span class="hljs-string">'zone-graph-'</span> + i]) {
                            series[<span class="hljs-string">'zone-graph-'</span> + i].attr(attribs);
                            i = i + <span class="hljs-number">1</span>;
                        }
                    }
                }
            },
            <span class="hljs-attr">setVisible</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">vis, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    chart = series.chart,
                    legendItem = series.legendItem,
                    showOrHide,
                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
                    oldVisibility = series.visible;
                series.visible = vis = series.options.visible = series.userOptions.visible = vis === <span class="hljs-literal">undefined</span> ? !oldVisibility : vis;
                showOrHide = vis ? <span class="hljs-string">'show'</span> : <span class="hljs-string">'hide'</span>;
                each([<span class="hljs-string">'group'</span>, <span class="hljs-string">'dataLabelsGroup'</span>, <span class="hljs-string">'markerGroup'</span>, <span class="hljs-string">'tracker'</span>, <span class="hljs-string">'tt'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                    <span class="hljs-keyword">if</span> (series[key]) {
                        series[key][showOrHide]();
                    }
                });
                <span class="hljs-keyword">if</span> (chart.hoverSeries === series || (chart.hoverPoint &amp;&amp; chart.hoverPoint.series) === series) {
                    series.onMouseOut();
                }
                <span class="hljs-keyword">if</span> (legendItem) {
                    chart.legend.colorizeItem(series, vis);
                }
                series.isDirty = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (series.options.stacking) {
                    each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSeries</span>) </span>{
                        <span class="hljs-keyword">if</span> (otherSeries.options.stacking &amp;&amp; otherSeries.visible) {
                            otherSeries.isDirty = <span class="hljs-literal">true</span>;
                        }
                    });
                }
                each(series.linkedSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherSeries</span>) </span>{
                    otherSeries.setVisible(vis, <span class="hljs-literal">false</span>);
                });
                <span class="hljs-keyword">if</span> (ignoreHiddenSeries) {
                    chart.isDirtyBox = <span class="hljs-literal">true</span>;
                }
                <span class="hljs-keyword">if</span> (redraw !== <span class="hljs-literal">false</span>) {
                    chart.redraw();
                }
                fireEvent(series, showOrHide);
            },
            <span class="hljs-attr">show</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.setVisible(<span class="hljs-literal">true</span>);
            },
            <span class="hljs-attr">hide</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.setVisible(<span class="hljs-literal">false</span>);
            },
            <span class="hljs-attr">select</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selected</span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>;
                series.selected = selected = (selected === <span class="hljs-literal">undefined</span>) ? !series.selected : selected;
                <span class="hljs-keyword">if</span> (series.checkbox) {
                    series.checkbox.checked = selected;
                }
                fireEvent(series, selected ? <span class="hljs-string">'select'</span> : <span class="hljs-string">'unselect'</span>);
            },
            <span class="hljs-attr">drawTracker</span>: TrackerMixin.drawTrackerGraph
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> Chart = H.Chart,
            each = H.each,
            inArray = H.inArray,
            isObject = H.isObject,
            pick = H.pick,
            splat = H.splat;
        Chart.prototype.setResponsive = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">redraw</span>) </span>{
            <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options.responsive;
            <span class="hljs-keyword">if</span> (options &amp;&amp; options.rules) {
                each(options.rules, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rule</span>) </span>{
                    <span class="hljs-keyword">this</span>.matchResponsiveRule(rule, redraw);
                }, <span class="hljs-keyword">this</span>);
            }
        };
        Chart.prototype.matchResponsiveRule = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rule, redraw</span>) </span>{
            <span class="hljs-keyword">var</span> respRules = <span class="hljs-keyword">this</span>.respRules,
                condition = rule.condition,
                matches,
                fn = condition.callback || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.chartWidth &lt;= pick(condition.maxWidth, <span class="hljs-built_in">Number</span>.MAX_VALUE) &amp;&amp;
                        <span class="hljs-keyword">this</span>.chartHeight &lt;= pick(condition.maxHeight, <span class="hljs-built_in">Number</span>.MAX_VALUE) &amp;&amp;
                        <span class="hljs-keyword">this</span>.chartWidth &gt;= pick(condition.minWidth, <span class="hljs-number">0</span>) &amp;&amp;
                        <span class="hljs-keyword">this</span>.chartHeight &gt;= pick(condition.minHeight, <span class="hljs-number">0</span>);
                };
            <span class="hljs-keyword">if</span> (rule._id === <span class="hljs-literal">undefined</span>) {
                rule._id = H.uniqueKey();
            }
            matches = fn.call(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">if</span> (!respRules[rule._id] &amp;&amp; matches) {
                <span class="hljs-keyword">if</span> (rule.chartOptions) {
                    respRules[rule._id] = <span class="hljs-keyword">this</span>.currentOptions(rule.chartOptions);
                    <span class="hljs-keyword">this</span>.update(rule.chartOptions, redraw);
                }
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (respRules[rule._id] &amp;&amp; !matches) {
                <span class="hljs-keyword">this</span>.update(respRules[rule._id], redraw);
                <span class="hljs-keyword">delete</span> respRules[rule._id];
            }
        };
        Chart.prototype.currentOptions = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
            <span class="hljs-keyword">var</span> ret = {};

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCurrent</span>(<span class="hljs-params">options, curr, ret, depth</span>) </span>{
                <span class="hljs-keyword">var</span> key, i;
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> options) {
                    <span class="hljs-keyword">if</span> (!depth &amp;&amp; inArray(key, [<span class="hljs-string">'series'</span>, <span class="hljs-string">'xAxis'</span>, <span class="hljs-string">'yAxis'</span>]) &gt; <span class="hljs-number">-1</span>) {
                        options[key] = splat(options[key]);
                        ret[key] = [];
                        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; options[key].length; i++) {
                            ret[key][i] = {};
                            getCurrent(
                                options[key][i],
                                curr[key][i],
                                ret[key][i],
                                depth + <span class="hljs-number">1</span>
                            );
                        }
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isObject(options[key])) {
                        ret[key] = {};
                        getCurrent(
                            options[key],
                            curr[key] || {},
                            ret[key],
                            depth + <span class="hljs-number">1</span>
                        );
                    } <span class="hljs-keyword">else</span> {
                        ret[key] = curr[key] || <span class="hljs-literal">null</span>;
                    }
                }
            }
            getCurrent(options, <span class="hljs-keyword">this</span>.options, ret, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">return</span> ret;
        };
    }(Highcharts));
    <span class="hljs-keyword">var</span> Highcharts = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Highcharts</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">return</span> Highcharts;
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            Axis = H.Axis,
            Chart = H.Chart,
            css = H.css,
            dateFormat = H.dateFormat,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            noop = H.noop,
            Series = H.Series,
            timeUnits = H.timeUnits,
            wrap = H.wrap;
        wrap(Series.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                xAxis;
            proceed.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            xAxis = series.xAxis;
            <span class="hljs-keyword">if</span> (xAxis &amp;&amp; xAxis.options.ordinal) {
                addEvent(series, <span class="hljs-string">'updatedData'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">delete</span> xAxis.ordinalIndex;
                });
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'getTimeTicks'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, normalizedInterval, min, max, startOfWeek, positions, closestDistance, findHigherRanks</span>) </span>{
            <span class="hljs-keyword">var</span> start = <span class="hljs-number">0</span>,
                end,
                segmentPositions,
                higherRanks = {},
                hasCrossedHigherRank,
                info,
                posLength,
                outsideMax,
                groupPositions = [],
                lastGroupPosition = -<span class="hljs-built_in">Number</span>.MAX_VALUE,
                tickPixelIntervalOption = <span class="hljs-keyword">this</span>.options.tickPixelInterval;
            <span class="hljs-keyword">if</span> ((!<span class="hljs-keyword">this</span>.options.ordinal &amp;&amp; !<span class="hljs-keyword">this</span>.options.breaks) || !positions || positions.length &lt; <span class="hljs-number">3</span> || min === <span class="hljs-literal">undefined</span>) {
                <span class="hljs-keyword">return</span> proceed.call(<span class="hljs-keyword">this</span>, normalizedInterval, min, max, startOfWeek);
            }
            posLength = positions.length;
            <span class="hljs-keyword">for</span> (end = <span class="hljs-number">0</span>; end &lt; posLength; end++) {
                outsideMax = end &amp;&amp; positions[end - <span class="hljs-number">1</span>] &gt; max;
                <span class="hljs-keyword">if</span> (positions[end] &lt; min) {
                    start = end;
                }
                <span class="hljs-keyword">if</span> (end === posLength - <span class="hljs-number">1</span> || positions[end + <span class="hljs-number">1</span>] - positions[end] &gt; closestDistance * <span class="hljs-number">5</span> || outsideMax) {
                    <span class="hljs-keyword">if</span> (positions[end] &gt; lastGroupPosition) {
                        segmentPositions = proceed.call(<span class="hljs-keyword">this</span>, normalizedInterval, positions[start], positions[end], startOfWeek);
                        <span class="hljs-keyword">while</span> (segmentPositions.length &amp;&amp; segmentPositions[<span class="hljs-number">0</span>] &lt;= lastGroupPosition) {
                            segmentPositions.shift();
                        }
                        <span class="hljs-keyword">if</span> (segmentPositions.length) {
                            lastGroupPosition = segmentPositions[segmentPositions.length - <span class="hljs-number">1</span>];
                        }
                        groupPositions = groupPositions.concat(segmentPositions);
                    }
                    start = end + <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">if</span> (outsideMax) {
                    <span class="hljs-keyword">break</span>;
                }
            }
            info = segmentPositions.info;
            <span class="hljs-keyword">if</span> (findHigherRanks &amp;&amp; info.unitRange &lt;= timeUnits.hour) {
                end = groupPositions.length - <span class="hljs-number">1</span>;
                <span class="hljs-keyword">for</span> (start = <span class="hljs-number">1</span>; start &lt; end; start++) {
                    <span class="hljs-keyword">if</span> (dateFormat(<span class="hljs-string">'%d'</span>, groupPositions[start]) !== dateFormat(<span class="hljs-string">'%d'</span>, groupPositions[start - <span class="hljs-number">1</span>])) {
                        higherRanks[groupPositions[start]] = <span class="hljs-string">'day'</span>;
                        hasCrossedHigherRank = <span class="hljs-literal">true</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (hasCrossedHigherRank) {
                    higherRanks[groupPositions[<span class="hljs-number">0</span>]] = <span class="hljs-string">'day'</span>;
                }
                info.higherRanks = higherRanks;
            }
            groupPositions.info = info;
            <span class="hljs-keyword">if</span> (findHigherRanks &amp;&amp; defined(tickPixelIntervalOption)) {
                <span class="hljs-keyword">var</span> length = groupPositions.length,
                    i = length,
                    itemToRemove,
                    translated,
                    translatedArr = [],
                    lastTranslated,
                    medianDistance,
                    distance,
                    distances = [];
                <span class="hljs-keyword">while</span> (i--) {
                    translated = <span class="hljs-keyword">this</span>.translate(groupPositions[i]);
                    <span class="hljs-keyword">if</span> (lastTranslated) {
                        distances[i] = lastTranslated - translated;
                    }
                    translatedArr[i] = lastTranslated = translated;
                }
                distances.sort();
                medianDistance = distances[<span class="hljs-built_in">Math</span>.floor(distances.length / <span class="hljs-number">2</span>)];
                <span class="hljs-keyword">if</span> (medianDistance &lt; tickPixelIntervalOption * <span class="hljs-number">0.6</span>) {
                    medianDistance = <span class="hljs-literal">null</span>;
                }
                i = groupPositions[length - <span class="hljs-number">1</span>] &gt; max ? length - <span class="hljs-number">1</span> : length;
                lastTranslated = <span class="hljs-literal">undefined</span>;
                <span class="hljs-keyword">while</span> (i--) {
                    translated = translatedArr[i];
                    distance = <span class="hljs-built_in">Math</span>.abs(lastTranslated - translated);
                    <span class="hljs-keyword">if</span> (lastTranslated &amp;&amp; distance &lt; tickPixelIntervalOption * <span class="hljs-number">0.8</span> &amp;&amp;
                        (medianDistance === <span class="hljs-literal">null</span> || distance &lt; medianDistance * <span class="hljs-number">0.8</span>)) {
                        <span class="hljs-keyword">if</span> (higherRanks[groupPositions[i]] &amp;&amp; !higherRanks[groupPositions[i + <span class="hljs-number">1</span>]]) {
                            itemToRemove = i + <span class="hljs-number">1</span>;
                            lastTranslated = translated;
                        } <span class="hljs-keyword">else</span> {
                            itemToRemove = i;
                        }
                        groupPositions.splice(itemToRemove, <span class="hljs-number">1</span>);
                    } <span class="hljs-keyword">else</span> {
                        lastTranslated = translated;
                    }
                }
            }
            <span class="hljs-keyword">return</span> groupPositions;
        });
        extend(Axis.prototype, {
            <span class="hljs-attr">beforeSetTickPositions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    len,
                    ordinalPositions = [],
                    useOrdinal = <span class="hljs-literal">false</span>,
                    dist,
                    extremes = axis.getExtremes(),
                    min = extremes.min,
                    max = extremes.max,
                    minIndex,
                    maxIndex,
                    slope,
                    hasBreaks = axis.isXAxis &amp;&amp; !!axis.options.breaks,
                    isOrdinal = axis.options.ordinal,
                    ignoreHiddenSeries = axis.chart.options.chart.ignoreHiddenSeries,
                    i;
                <span class="hljs-keyword">if</span> (isOrdinal || hasBreaks) {
                    each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series, i</span>) </span>{
                        <span class="hljs-keyword">if</span> ((!ignoreHiddenSeries || series.visible !== <span class="hljs-literal">false</span>) &amp;&amp; (series.takeOrdinalPosition !== <span class="hljs-literal">false</span> || hasBreaks)) {
                            ordinalPositions = ordinalPositions.concat(series.processedXData);
                            len = ordinalPositions.length;
                            ordinalPositions.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                                <span class="hljs-keyword">return</span> a - b;
                            });
                            <span class="hljs-keyword">if</span> (len) {
                                i = len - <span class="hljs-number">1</span>;
                                <span class="hljs-keyword">while</span> (i--) {
                                    <span class="hljs-keyword">if</span> (ordinalPositions[i] === ordinalPositions[i + <span class="hljs-number">1</span>]) {
                                        ordinalPositions.splice(i, <span class="hljs-number">1</span>);
                                    }
                                }
                            }
                        }
                    });
                    len = ordinalPositions.length;
                    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">2</span>) {
                        dist = ordinalPositions[<span class="hljs-number">1</span>] - ordinalPositions[<span class="hljs-number">0</span>];
                        i = len - <span class="hljs-number">1</span>;
                        <span class="hljs-keyword">while</span> (i-- &amp;&amp; !useOrdinal) {
                            <span class="hljs-keyword">if</span> (ordinalPositions[i + <span class="hljs-number">1</span>] - ordinalPositions[i] !== dist) {
                                useOrdinal = <span class="hljs-literal">true</span>;
                            }
                        }
                        <span class="hljs-keyword">if</span> (!axis.options.keepOrdinalPadding &amp;&amp; (ordinalPositions[<span class="hljs-number">0</span>] - min &gt; dist || max - ordinalPositions[ordinalPositions.length - <span class="hljs-number">1</span>] &gt; dist)) {
                            useOrdinal = <span class="hljs-literal">true</span>;
                        }
                    }
                    <span class="hljs-keyword">if</span> (useOrdinal) {
                        axis.ordinalPositions = ordinalPositions;
                        minIndex = axis.ordinal2lin(
                            <span class="hljs-built_in">Math</span>.max(
                                min,
                                ordinalPositions[<span class="hljs-number">0</span>]
                            ),
                            <span class="hljs-literal">true</span>
                        );
                        maxIndex = <span class="hljs-built_in">Math</span>.max(axis.ordinal2lin(
                            <span class="hljs-built_in">Math</span>.min(
                                max,
                                ordinalPositions[ordinalPositions.length - <span class="hljs-number">1</span>]
                            ),
                            <span class="hljs-literal">true</span>
                        ), <span class="hljs-number">1</span>);
                        axis.ordinalSlope = slope = (max - min) / (maxIndex - minIndex);
                        axis.ordinalOffset = min - (minIndex * slope);
                    } <span class="hljs-keyword">else</span> {
                        axis.ordinalPositions = axis.ordinalSlope = axis.ordinalOffset = <span class="hljs-literal">undefined</span>;
                    }
                }
                axis.isOrdinal = isOrdinal &amp;&amp; useOrdinal;
                axis.groupIntervalFactor = <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">val2lin</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, toIndex</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    ordinalPositions = axis.ordinalPositions,
                    ret;
                <span class="hljs-keyword">if</span> (!ordinalPositions) {
                    ret = val;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">var</span> ordinalLength = ordinalPositions.length,
                        i,
                        distance,
                        ordinalIndex;
                    i = ordinalLength;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (ordinalPositions[i] === val) {
                            ordinalIndex = i;
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    i = ordinalLength - <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (val &gt; ordinalPositions[i] || i === <span class="hljs-number">0</span>) {
                            distance = (val - ordinalPositions[i]) / (ordinalPositions[i + <span class="hljs-number">1</span>] - ordinalPositions[i]);
                            ordinalIndex = i + distance;
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    ret = toIndex ?
                        ordinalIndex :
                        axis.ordinalSlope * (ordinalIndex || <span class="hljs-number">0</span>) + axis.ordinalOffset;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">lin2val</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, fromIndex</span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    ordinalPositions = axis.ordinalPositions,
                    ret;
                <span class="hljs-keyword">if</span> (!ordinalPositions) {
                    ret = val;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">var</span> ordinalSlope = axis.ordinalSlope,
                        ordinalOffset = axis.ordinalOffset,
                        i = ordinalPositions.length - <span class="hljs-number">1</span>,
                        linearEquivalentLeft,
                        linearEquivalentRight,
                        distance;
                    <span class="hljs-keyword">if</span> (fromIndex) {
                        <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span>) {
                            val = ordinalPositions[<span class="hljs-number">0</span>];
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; i) {
                            val = ordinalPositions[i];
                        } <span class="hljs-keyword">else</span> {
                            i = <span class="hljs-built_in">Math</span>.floor(val);
                            distance = val - i;
                        }
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">while</span> (i--) {
                            linearEquivalentLeft = (ordinalSlope * i) + ordinalOffset;
                            <span class="hljs-keyword">if</span> (val &gt;= linearEquivalentLeft) {
                                linearEquivalentRight = (ordinalSlope * (i + <span class="hljs-number">1</span>)) + ordinalOffset;
                                distance = (val - linearEquivalentLeft) / (linearEquivalentRight - linearEquivalentLeft);
                                <span class="hljs-keyword">break</span>;
                            }
                        }
                    }
                    <span class="hljs-keyword">return</span> distance !== <span class="hljs-literal">undefined</span> &amp;&amp; ordinalPositions[i] !== <span class="hljs-literal">undefined</span> ?
                        ordinalPositions[i] + (distance ? distance * (ordinalPositions[i + <span class="hljs-number">1</span>] - ordinalPositions[i]) : <span class="hljs-number">0</span>) :
                        val;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">getExtendedPositions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    chart = axis.chart,
                    grouping = axis.series[<span class="hljs-number">0</span>].currentDataGrouping,
                    ordinalIndex = axis.ordinalIndex,
                    key = grouping ? grouping.count + grouping.unitName : <span class="hljs-string">'raw'</span>,
                    extremes = axis.getExtremes(),
                    fakeAxis,
                    fakeSeries;
                <span class="hljs-keyword">if</span> (!ordinalIndex) {
                    ordinalIndex = axis.ordinalIndex = {};
                }
                <span class="hljs-keyword">if</span> (!ordinalIndex[key]) {
                    fakeAxis = {
                        <span class="hljs-attr">series</span>: [],
                        <span class="hljs-attr">chart</span>: chart,
                        <span class="hljs-attr">getExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">return</span> {
                                <span class="hljs-attr">min</span>: extremes.dataMin,
                                <span class="hljs-attr">max</span>: extremes.dataMax
                            };
                        },
                        <span class="hljs-attr">options</span>: {
                            <span class="hljs-attr">ordinal</span>: <span class="hljs-literal">true</span>
                        },
                        <span class="hljs-attr">val2lin</span>: Axis.prototype.val2lin
                    };
                    each(axis.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        fakeSeries = {
                            <span class="hljs-attr">xAxis</span>: fakeAxis,
                            <span class="hljs-attr">xData</span>: series.xData,
                            <span class="hljs-attr">chart</span>: chart,
                            <span class="hljs-attr">destroyGroupedData</span>: noop
                        };
                        fakeSeries.options = {
                            <span class="hljs-attr">dataGrouping</span>: grouping ? {
                                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                                <span class="hljs-attr">forced</span>: <span class="hljs-literal">true</span>,
                                <span class="hljs-attr">approximation</span>: <span class="hljs-string">'open'</span>,
                                <span class="hljs-attr">units</span>: [
                                    [grouping.unitName, [grouping.count]]
                                ]
                            } : {
                                <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>
                            }
                        };
                        series.processData.apply(fakeSeries);
                        fakeAxis.series.push(fakeSeries);
                    });
                    axis.beforeSetTickPositions.apply(fakeAxis);
                    ordinalIndex[key] = fakeAxis.ordinalPositions;
                }
                <span class="hljs-keyword">return</span> ordinalIndex[key];
            },
            <span class="hljs-attr">getGroupIntervalFactor</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xMin, xMax, series</span>) </span>{
                <span class="hljs-keyword">var</span> i,
                    processedXData = series.processedXData,
                    len = processedXData.length,
                    distances = [],
                    median,
                    groupIntervalFactor = <span class="hljs-keyword">this</span>.groupIntervalFactor;
                <span class="hljs-keyword">if</span> (!groupIntervalFactor) {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) {
                        distances[i] = processedXData[i + <span class="hljs-number">1</span>] - processedXData[i];
                    }
                    distances.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                        <span class="hljs-keyword">return</span> a - b;
                    });
                    median = distances[<span class="hljs-built_in">Math</span>.floor(len / <span class="hljs-number">2</span>)];
                    xMin = <span class="hljs-built_in">Math</span>.max(xMin, processedXData[<span class="hljs-number">0</span>]);
                    xMax = <span class="hljs-built_in">Math</span>.min(xMax, processedXData[len - <span class="hljs-number">1</span>]);
                    <span class="hljs-keyword">this</span>.groupIntervalFactor = groupIntervalFactor = (len * median) / (xMax - xMin);
                }
                <span class="hljs-keyword">return</span> groupIntervalFactor;
            },
            <span class="hljs-attr">postProcessTickInterval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tickInterval</span>) </span>{
                <span class="hljs-keyword">var</span> ordinalSlope = <span class="hljs-keyword">this</span>.ordinalSlope,
                    ret;
                <span class="hljs-keyword">if</span> (ordinalSlope) {
                    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.options.breaks) {
                        ret = tickInterval / (ordinalSlope / <span class="hljs-keyword">this</span>.closestPointRange);
                    } <span class="hljs-keyword">else</span> {
                        ret = <span class="hljs-keyword">this</span>.closestPointRange;
                    }
                } <span class="hljs-keyword">else</span> {
                    ret = tickInterval;
                }
                <span class="hljs-keyword">return</span> ret;
            }
        });
        Axis.prototype.ordinal2lin = Axis.prototype.val2lin;
        wrap(Chart.prototype, <span class="hljs-string">'pan'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, e</span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>,
                xAxis = chart.xAxis[<span class="hljs-number">0</span>],
                chartX = e.chartX,
                runBase = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (xAxis.options.ordinal &amp;&amp; xAxis.series.length) {
                <span class="hljs-keyword">var</span> mouseDownX = chart.mouseDownX,
                    extremes = xAxis.getExtremes(),
                    dataMax = extremes.dataMax,
                    min = extremes.min,
                    max = extremes.max,
                    trimmedRange,
                    hoverPoints = chart.hoverPoints,
                    closestPointRange = xAxis.closestPointRange,
                    pointPixelWidth = xAxis.translationSlope * (xAxis.ordinalSlope || closestPointRange),
                    movedUnits = (mouseDownX - chartX) / pointPixelWidth,
                    extendedAxis = {
                        <span class="hljs-attr">ordinalPositions</span>: xAxis.getExtendedPositions()
                    },
                    ordinalPositions,
                    searchAxisLeft,
                    lin2val = xAxis.lin2val,
                    val2lin = xAxis.val2lin,
                    searchAxisRight;
                <span class="hljs-keyword">if</span> (!extendedAxis.ordinalPositions) {
                    runBase = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(movedUnits) &gt; <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">if</span> (hoverPoints) {
                        each(hoverPoints, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                            point.setState();
                        });
                    }
                    <span class="hljs-keyword">if</span> (movedUnits &lt; <span class="hljs-number">0</span>) {
                        searchAxisLeft = extendedAxis;
                        searchAxisRight = xAxis.ordinalPositions ? xAxis : extendedAxis;
                    } <span class="hljs-keyword">else</span> {
                        searchAxisLeft = xAxis.ordinalPositions ? xAxis : extendedAxis;
                        searchAxisRight = extendedAxis;
                    }
                    ordinalPositions = searchAxisRight.ordinalPositions;
                    <span class="hljs-keyword">if</span> (dataMax &gt; ordinalPositions[ordinalPositions.length - <span class="hljs-number">1</span>]) {
                        ordinalPositions.push(dataMax);
                    }
                    chart.fixedRange = max - min;
                    trimmedRange = xAxis.toFixedRange(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,
                        lin2val.apply(searchAxisLeft, [
                            val2lin.apply(searchAxisLeft, [min, <span class="hljs-literal">true</span>]) + movedUnits,
                            <span class="hljs-literal">true</span>
                        ]),
                        lin2val.apply(searchAxisRight, [
                            val2lin.apply(searchAxisRight, [max, <span class="hljs-literal">true</span>]) + movedUnits,
                            <span class="hljs-literal">true</span>
                        ])
                    );
                    <span class="hljs-keyword">if</span> (trimmedRange.min &gt;= <span class="hljs-built_in">Math</span>.min(extremes.dataMin, min) &amp;&amp; trimmedRange.max &lt;= <span class="hljs-built_in">Math</span>.max(dataMax, max)) {
                        xAxis.setExtremes(trimmedRange.min, trimmedRange.max, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, {
                            <span class="hljs-attr">trigger</span>: <span class="hljs-string">'pan'</span>
                        });
                    }
                    chart.mouseDownX = chartX;
                    css(chart.container, {
                        <span class="hljs-attr">cursor</span>: <span class="hljs-string">'move'</span>
                    });
                }
            } <span class="hljs-keyword">else</span> {
                runBase = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">if</span> (runBase) {
                proceed.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            }
        });
        Series.prototype.gappedPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> gapSize = <span class="hljs-keyword">this</span>.options.gapSize,
                points = <span class="hljs-keyword">this</span>.points.slice(),
                i = points.length - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (gapSize &amp;&amp; i &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">if</span> (points[i + <span class="hljs-number">1</span>].x - points[i].x &gt; <span class="hljs-keyword">this</span>.closestPointRange * gapSize) {
                        points.splice(
                            i + <span class="hljs-number">1</span>,
                            <span class="hljs-number">0</span>, {
                                <span class="hljs-attr">isNull</span>: <span class="hljs-literal">true</span>
                            }
                        );
                    }
                }
            }
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getGraphPath(points);
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> pick = H.pick,
            wrap = H.wrap,
            each = H.each,
            extend = H.extend,
            isArray = H.isArray,
            fireEvent = H.fireEvent,
            Axis = H.Axis,
            Series = H.Series;

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stripArguments</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);
        }
        extend(Axis.prototype, {
            <span class="hljs-attr">isInBreak</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">brk, val</span>) </span>{
                <span class="hljs-keyword">var</span> ret,
                    repeat = brk.repeat || <span class="hljs-literal">Infinity</span>,
                    <span class="hljs-keyword">from</span> = brk.from,
                    length = brk.to - brk.from,
                    test = (val &gt;= <span class="hljs-keyword">from</span> ? (val - <span class="hljs-keyword">from</span>) % repeat : repeat - ((<span class="hljs-keyword">from</span> - val) % repeat));
                <span class="hljs-keyword">if</span> (!brk.inclusive) {
                    ret = test &lt; length &amp;&amp; test !== <span class="hljs-number">0</span>;
                } <span class="hljs-keyword">else</span> {
                    ret = test &lt;= length;
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">isInAnyBreak</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val, testKeep</span>) </span>{
                <span class="hljs-keyword">var</span> breaks = <span class="hljs-keyword">this</span>.options.breaks,
                    i = breaks &amp;&amp; breaks.length,
                    inbrk,
                    keep,
                    ret;
                <span class="hljs-keyword">if</span> (i) {
                    <span class="hljs-keyword">while</span> (i--) {
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isInBreak(breaks[i], val)) {
                            inbrk = <span class="hljs-literal">true</span>;
                            <span class="hljs-keyword">if</span> (!keep) {
                                keep = pick(breaks[i].showPoints, <span class="hljs-keyword">this</span>.isXAxis ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>);
                            }
                        }
                    }
                    <span class="hljs-keyword">if</span> (inbrk &amp;&amp; testKeep) {
                        ret = inbrk &amp;&amp; !keep;
                    } <span class="hljs-keyword">else</span> {
                        ret = inbrk;
                    }
                }
                <span class="hljs-keyword">return</span> ret;
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'setTickPositions'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            proceed.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.breaks) {
                <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                    tickPositions = <span class="hljs-keyword">this</span>.tickPositions,
                    info = <span class="hljs-keyword">this</span>.tickPositions.info,
                    newPositions = [],
                    i;
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tickPositions.length; i++) {
                    <span class="hljs-keyword">if</span> (!axis.isInAnyBreak(tickPositions[i])) {
                        newPositions.push(tickPositions[i]);
                    }
                }
                <span class="hljs-keyword">this</span>.tickPositions = newPositions;
                <span class="hljs-keyword">this</span>.tickPositions.info = info;
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, chart, userOptions</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                breaks;
            <span class="hljs-keyword">if</span> (userOptions.breaks &amp;&amp; userOptions.breaks.length) {
                userOptions.ordinal = <span class="hljs-literal">false</span>;
            }
            proceed.call(<span class="hljs-keyword">this</span>, chart, userOptions);
            breaks = <span class="hljs-keyword">this</span>.options.breaks;
            axis.isBroken = (isArray(breaks) &amp;&amp; !!breaks.length);
            <span class="hljs-keyword">if</span> (axis.isBroken) {
                axis.val2lin = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
                    <span class="hljs-keyword">var</span> nval = val,
                        brk,
                        i;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; axis.breakArray.length; i++) {
                        brk = axis.breakArray[i];
                        <span class="hljs-keyword">if</span> (brk.to &lt;= val) {
                            nval -= brk.len;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (brk.from &gt;= val) {
                            <span class="hljs-keyword">break</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.isInBreak(brk, val)) {
                            nval -= (val - brk.from);
                            <span class="hljs-keyword">break</span>;
                        }
                    }
                    <span class="hljs-keyword">return</span> nval;
                };
                axis.lin2val = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
                    <span class="hljs-keyword">var</span> nval = val,
                        brk,
                        i;
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; axis.breakArray.length; i++) {
                        brk = axis.breakArray[i];
                        <span class="hljs-keyword">if</span> (brk.from &gt;= nval) {
                            <span class="hljs-keyword">break</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (brk.to &lt; nval) {
                            nval += brk.len;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (axis.isInBreak(brk, nval)) {
                            nval += brk.len;
                        }
                    }
                    <span class="hljs-keyword">return</span> nval;
                };
                axis.setExtremes = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newMin, newMax, redraw, animation, eventArguments</span>) </span>{
                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.isInAnyBreak(newMin)) {
                        newMin -= <span class="hljs-keyword">this</span>.closestPointRange;
                    }
                    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.isInAnyBreak(newMax)) {
                        newMax -= <span class="hljs-keyword">this</span>.closestPointRange;
                    }
                    Axis.prototype.setExtremes.call(<span class="hljs-keyword">this</span>, newMin, newMax, redraw, animation, eventArguments);
                };
                axis.setAxisTranslation = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">saveOld</span>) </span>{
                    Axis.prototype.setAxisTranslation.call(<span class="hljs-keyword">this</span>, saveOld);
                    <span class="hljs-keyword">var</span> breaks = axis.options.breaks,
                        breakArrayT = [],
                        breakArray = [],
                        length = <span class="hljs-number">0</span>,
                        inBrk,
                        repeat,
                        brk,
                        min = axis.userMin || axis.min,
                        max = axis.userMax || axis.max,
                        start,
                        i,
                        j;
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> breaks) {
                        brk = breaks[i];
                        repeat = brk.repeat || <span class="hljs-literal">Infinity</span>;
                        <span class="hljs-keyword">if</span> (axis.isInBreak(brk, min)) {
                            min += (brk.to % repeat) - (min % repeat);
                        }
                        <span class="hljs-keyword">if</span> (axis.isInBreak(brk, max)) {
                            max -= (max % repeat) - (brk.from % repeat);
                        }
                    }
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> breaks) {
                        brk = breaks[i];
                        start = brk.from;
                        repeat = brk.repeat || <span class="hljs-literal">Infinity</span>;
                        <span class="hljs-keyword">while</span> (start - repeat &gt; min) {
                            start -= repeat;
                        }
                        <span class="hljs-keyword">while</span> (start &lt; min) {
                            start += repeat;
                        }
                        <span class="hljs-keyword">for</span> (j = start; j &lt; max; j += repeat) {
                            breakArrayT.push({
                                <span class="hljs-attr">value</span>: j,
                                <span class="hljs-attr">move</span>: <span class="hljs-string">'in'</span>
                            });
                            breakArrayT.push({
                                <span class="hljs-attr">value</span>: j + (brk.to - brk.from),
                                <span class="hljs-attr">move</span>: <span class="hljs-string">'out'</span>,
                                <span class="hljs-attr">size</span>: brk.breakSize
                            });
                        }
                    }
                    breakArrayT.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                        <span class="hljs-keyword">var</span> ret;
                        <span class="hljs-keyword">if</span> (a.value === b.value) {
                            ret = (a.move === <span class="hljs-string">'in'</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) - (b.move === <span class="hljs-string">'in'</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);
                        } <span class="hljs-keyword">else</span> {
                            ret = a.value - b.value;
                        }
                        <span class="hljs-keyword">return</span> ret;
                    });
                    inBrk = <span class="hljs-number">0</span>;
                    start = min;
                    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> breakArrayT) {
                        brk = breakArrayT[i];
                        inBrk += (brk.move === <span class="hljs-string">'in'</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);
                        <span class="hljs-keyword">if</span> (inBrk === <span class="hljs-number">1</span> &amp;&amp; brk.move === <span class="hljs-string">'in'</span>) {
                            start = brk.value;
                        }
                        <span class="hljs-keyword">if</span> (inBrk === <span class="hljs-number">0</span>) {
                            breakArray.push({
                                <span class="hljs-attr">from</span>: start,
                                <span class="hljs-attr">to</span>: brk.value,
                                <span class="hljs-attr">len</span>: brk.value - start - (brk.size || <span class="hljs-number">0</span>)
                            });
                            length += brk.value - start - (brk.size || <span class="hljs-number">0</span>);
                        }
                    }
                    axis.breakArray = breakArray;
                    fireEvent(axis, <span class="hljs-string">'afterBreaks'</span>);
                    axis.transA *= ((max - axis.min) / (max - min - length));
                    axis.min = min;
                    axis.max = max;
                };
            }
        });
        wrap(Series.prototype, <span class="hljs-string">'generatePoints'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            proceed.apply(<span class="hljs-keyword">this</span>, stripArguments(<span class="hljs-built_in">arguments</span>));
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                xAxis = series.xAxis,
                yAxis = series.yAxis,
                points = series.points,
                point,
                i = points.length,
                connectNulls = series.options.connectNulls,
                nullGap;
            <span class="hljs-keyword">if</span> (xAxis &amp;&amp; yAxis &amp;&amp; (xAxis.options.breaks || yAxis.options.breaks)) {
                <span class="hljs-keyword">while</span> (i--) {
                    point = points[i];
                    nullGap = point.y === <span class="hljs-literal">null</span> &amp;&amp; connectNulls === <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">if</span> (!nullGap &amp;&amp; (xAxis.isInAnyBreak(point.x, <span class="hljs-literal">true</span>) || yAxis.isInAnyBreak(point.y, <span class="hljs-literal">true</span>))) {
                        points.splice(i, <span class="hljs-number">1</span>);
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.data[i]) {
                            <span class="hljs-keyword">this</span>.data[i].destroyElements();
                        }
                    }
                }
            }
        });

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawPointsWrapped</span>(<span class="hljs-params">proceed</span>) </span>{
            proceed.apply(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">this</span>.drawBreaks(<span class="hljs-keyword">this</span>.xAxis, [<span class="hljs-string">'x'</span>]);
            <span class="hljs-keyword">this</span>.drawBreaks(<span class="hljs-keyword">this</span>.yAxis, pick(<span class="hljs-keyword">this</span>.pointArrayMap, [<span class="hljs-string">'y'</span>]));
        }
        H.Series.prototype.drawBreaks = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis, keys</span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                points = series.points,
                breaks,
                threshold,
                eventName,
                y;
            <span class="hljs-keyword">if</span> (!axis) {
                <span class="hljs-keyword">return</span>;
            }
            each(keys, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key</span>) </span>{
                breaks = axis.breakArray || [];
                threshold = axis.isXAxis ? axis.min : pick(series.options.threshold, axis.min);
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    y = pick(point[<span class="hljs-string">'stack'</span> + key.toUpperCase()], point[key]);
                    each(breaks, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">brk</span>) </span>{
                        eventName = <span class="hljs-literal">false</span>;
                        <span class="hljs-keyword">if</span> ((threshold &lt; brk.from &amp;&amp; y &gt; brk.to) || (threshold &gt; brk.from &amp;&amp; y &lt; brk.from)) {
                            eventName = <span class="hljs-string">'pointBreak'</span>;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((threshold &lt; brk.from &amp;&amp; y &gt; brk.from &amp;&amp; y &lt; brk.to) || (threshold &gt; brk.from &amp;&amp; y &gt; brk.to &amp;&amp; y &lt; brk.from)) {
                            eventName = <span class="hljs-string">'pointInBreak'</span>;
                        }
                        <span class="hljs-keyword">if</span> (eventName) {
                            fireEvent(axis, eventName, {
                                <span class="hljs-attr">point</span>: point,
                                <span class="hljs-attr">brk</span>: brk
                            });
                        }
                    });
                });
            });
        };
        wrap(H.seriesTypes.column.prototype, <span class="hljs-string">'drawPoints'</span>, drawPointsWrapped);
        wrap(H.Series.prototype, <span class="hljs-string">'drawPoints'</span>, drawPointsWrapped);
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
    }());
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> arrayMax = H.arrayMax,
            arrayMin = H.arrayMin,
            Axis = H.Axis,
            defaultPlotOptions = H.defaultPlotOptions,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            format = H.format,
            isNumber = H.isNumber,
            merge = H.merge,
            pick = H.pick,
            Point = H.Point,
            Series = H.Series,
            Tooltip = H.Tooltip,
            wrap = H.wrap;
        <span class="hljs-keyword">var</span> seriesProto = Series.prototype,
            baseProcessData = seriesProto.processData,
            baseGeneratePoints = seriesProto.generatePoints,
            baseDestroy = seriesProto.destroy,
            commonOptions = {
                <span class="hljs-attr">approximation</span>: <span class="hljs-string">'average'</span>,
                <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">2</span>,
                <span class="hljs-attr">dateTimeLabelFormats</span>: {
                    <span class="hljs-attr">millisecond</span>: [<span class="hljs-string">'%A, %b %e, %H:%M:%S.%L'</span>, <span class="hljs-string">'%A, %b %e, %H:%M:%S.%L'</span>, <span class="hljs-string">'-%H:%M:%S.%L'</span>],
                    <span class="hljs-attr">second</span>: [<span class="hljs-string">'%A, %b %e, %H:%M:%S'</span>, <span class="hljs-string">'%A, %b %e, %H:%M:%S'</span>, <span class="hljs-string">'-%H:%M:%S'</span>],
                    <span class="hljs-attr">minute</span>: [<span class="hljs-string">'%A, %b %e, %H:%M'</span>, <span class="hljs-string">'%A, %b %e, %H:%M'</span>, <span class="hljs-string">'-%H:%M'</span>],
                    <span class="hljs-attr">hour</span>: [<span class="hljs-string">'%A, %b %e, %H:%M'</span>, <span class="hljs-string">'%A, %b %e, %H:%M'</span>, <span class="hljs-string">'-%H:%M'</span>],
                    <span class="hljs-attr">day</span>: [<span class="hljs-string">'%A, %b %e, %Y'</span>, <span class="hljs-string">'%A, %b %e'</span>, <span class="hljs-string">'-%A, %b %e, %Y'</span>],
                    <span class="hljs-attr">week</span>: [<span class="hljs-string">'Week from %A, %b %e, %Y'</span>, <span class="hljs-string">'%A, %b %e'</span>, <span class="hljs-string">'-%A, %b %e, %Y'</span>],
                    <span class="hljs-attr">month</span>: [<span class="hljs-string">'%B %Y'</span>, <span class="hljs-string">'%B'</span>, <span class="hljs-string">'-%B %Y'</span>],
                    <span class="hljs-attr">year</span>: [<span class="hljs-string">'%Y'</span>, <span class="hljs-string">'%Y'</span>, <span class="hljs-string">'-%Y'</span>]
                }
            },
            specificOptions = {
                <span class="hljs-attr">line</span>: {},
                <span class="hljs-attr">spline</span>: {},
                <span class="hljs-attr">area</span>: {},
                <span class="hljs-attr">areaspline</span>: {},
                <span class="hljs-attr">column</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'sum'</span>,
                    <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">10</span>
                },
                <span class="hljs-attr">arearange</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'range'</span>
                },
                <span class="hljs-attr">areasplinerange</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'range'</span>
                },
                <span class="hljs-attr">columnrange</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'range'</span>,
                    <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">10</span>
                },
                <span class="hljs-attr">candlestick</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'ohlc'</span>,
                    <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">10</span>
                },
                <span class="hljs-attr">ohlc</span>: {
                    <span class="hljs-attr">approximation</span>: <span class="hljs-string">'ohlc'</span>,
                    <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">5</span>
                }
            },
            defaultDataGroupingUnits = H.defaultDataGroupingUnits = [
                [
                    <span class="hljs-string">'millisecond'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">500</span>]
                ],
                [
                    <span class="hljs-string">'second'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>]
                ],
                [
                    <span class="hljs-string">'minute'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>]
                ],
                [
                    <span class="hljs-string">'hour'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]
                ],
                [
                    <span class="hljs-string">'day'</span>, [<span class="hljs-number">1</span>]
                ],
                [
                    <span class="hljs-string">'week'</span>, [<span class="hljs-number">1</span>]
                ],
                [
                    <span class="hljs-string">'month'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>]
                ],
                [
                    <span class="hljs-string">'year'</span>,
                    <span class="hljs-literal">null</span>
                ]
            ],
            approximations = {
                <span class="hljs-attr">sum</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">var</span> len = arr.length,
                        ret;
                    <span class="hljs-keyword">if</span> (!len &amp;&amp; arr.hasNulls) {
                        ret = <span class="hljs-literal">null</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len) {
                        ret = <span class="hljs-number">0</span>;
                        <span class="hljs-keyword">while</span> (len--) {
                            ret += arr[len];
                        }
                    }
                    <span class="hljs-keyword">return</span> ret;
                },
                <span class="hljs-attr">average</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">var</span> len = arr.length,
                        ret = approximations.sum(arr);
                    <span class="hljs-keyword">if</span> (isNumber(ret) &amp;&amp; len) {
                        ret = ret / len;
                    }
                    <span class="hljs-keyword">return</span> ret;
                },
                <span class="hljs-attr">open</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">return</span> arr.length ? arr[<span class="hljs-number">0</span>] : (arr.hasNulls ? <span class="hljs-literal">null</span> : <span class="hljs-literal">undefined</span>);
                },
                <span class="hljs-attr">high</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">return</span> arr.length ? arrayMax(arr) : (arr.hasNulls ? <span class="hljs-literal">null</span> : <span class="hljs-literal">undefined</span>);
                },
                <span class="hljs-attr">low</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">return</span> arr.length ? arrayMin(arr) : (arr.hasNulls ? <span class="hljs-literal">null</span> : <span class="hljs-literal">undefined</span>);
                },
                <span class="hljs-attr">close</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>{
                    <span class="hljs-keyword">return</span> arr.length ? arr[arr.length - <span class="hljs-number">1</span>] : (arr.hasNulls ? <span class="hljs-literal">null</span> : <span class="hljs-literal">undefined</span>);
                },
                <span class="hljs-attr">ohlc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">open, high, low, close</span>) </span>{
                    open = approximations.open(open);
                    high = approximations.high(high);
                    low = approximations.low(low);
                    close = approximations.close(close);
                    <span class="hljs-keyword">if</span> (isNumber(open) || isNumber(high) || isNumber(low) || isNumber(close)) {
                        <span class="hljs-keyword">return</span> [open, high, low, close];
                    }
                },
                <span class="hljs-attr">range</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">low, high</span>) </span>{
                    low = approximations.low(low);
                    high = approximations.high(high);
                    <span class="hljs-keyword">if</span> (isNumber(low) || isNumber(high)) {
                        <span class="hljs-keyword">return</span> [low, high];
                    }
                }
            };
        seriesProto.groupData = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xData, yData, groupPositions, approximation</span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                data = series.data,
                dataOptions = series.options.data,
                groupedXData = [],
                groupedYData = [],
                groupMap = [],
                dataLength = xData.length,
                pointX,
                pointY,
                groupedY,
                handleYData = !!yData,
                values = [
                    [],
                    [],
                    [],
                    []
                ],
                approximationFn = <span class="hljs-keyword">typeof</span> approximation === <span class="hljs-string">'function'</span> ? approximation : approximations[approximation],
                pointArrayMap = series.pointArrayMap,
                pointArrayMapLength = pointArrayMap &amp;&amp; pointArrayMap.length,
                i,
                pos = <span class="hljs-number">0</span>,
                start = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= dataLength; i++) {
                <span class="hljs-keyword">if</span> (xData[i] &gt;= groupPositions[<span class="hljs-number">0</span>]) {
                    <span class="hljs-keyword">break</span>;
                }
            }
            <span class="hljs-keyword">for</span> (i; i &lt;= dataLength; i++) {
                <span class="hljs-keyword">while</span> ((groupPositions[pos + <span class="hljs-number">1</span>] !== <span class="hljs-literal">undefined</span> &amp;&amp; xData[i] &gt;= groupPositions[pos + <span class="hljs-number">1</span>]) ||
                    i === dataLength) {
                    pointX = groupPositions[pos];
                    series.dataGroupInfo = {
                        <span class="hljs-attr">start</span>: start,
                        <span class="hljs-attr">length</span>: values[<span class="hljs-number">0</span>].length
                    };
                    groupedY = approximationFn.apply(series, values);
                    <span class="hljs-keyword">if</span> (groupedY !== <span class="hljs-literal">undefined</span>) {
                        groupedXData.push(pointX);
                        groupedYData.push(groupedY);
                        groupMap.push(series.dataGroupInfo);
                    }
                    start = i;
                    values[<span class="hljs-number">0</span>] = [];
                    values[<span class="hljs-number">1</span>] = [];
                    values[<span class="hljs-number">2</span>] = [];
                    values[<span class="hljs-number">3</span>] = [];
                    pos += <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">if</span> (i === dataLength) {
                        <span class="hljs-keyword">break</span>;
                    }
                }
                <span class="hljs-keyword">if</span> (i === dataLength) {
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">if</span> (pointArrayMap) {
                    <span class="hljs-keyword">var</span> index = series.cropStart + i,
                        point = (data &amp;&amp; data[index]) || series.pointClass.prototype.applyOptions.apply({
                            <span class="hljs-attr">series</span>: series
                        }, [dataOptions[index]]),
                        j,
                        val;
                    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; pointArrayMapLength; j++) {
                        val = point[pointArrayMap[j]];
                        <span class="hljs-keyword">if</span> (isNumber(val)) {
                            values[j].push(val);
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === <span class="hljs-literal">null</span>) {
                            values[j].hasNulls = <span class="hljs-literal">true</span>;
                        }
                    }
                } <span class="hljs-keyword">else</span> {
                    pointY = handleYData ? yData[i] : <span class="hljs-literal">null</span>;
                    <span class="hljs-keyword">if</span> (isNumber(pointY)) {
                        values[<span class="hljs-number">0</span>].push(pointY);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pointY === <span class="hljs-literal">null</span>) {
                        values[<span class="hljs-number">0</span>].hasNulls = <span class="hljs-literal">true</span>;
                    }
                }
            }
            <span class="hljs-keyword">return</span> [groupedXData, groupedYData, groupMap];
        };
        seriesProto.processData = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                chart = series.chart,
                options = series.options,
                dataGroupingOptions = options.dataGrouping,
                groupingEnabled = series.allowDG !== <span class="hljs-literal">false</span> &amp;&amp; dataGroupingOptions &amp;&amp;
                pick(dataGroupingOptions.enabled, chart.options.isStock),
                visible = series.visible || !chart.options.chart.ignoreHiddenSeries,
                hasGroupedData,
                skip;
            series.forceCrop = groupingEnabled;
            series.groupPixelWidth = <span class="hljs-literal">null</span>;
            series.hasProcessed = <span class="hljs-literal">true</span>;
            skip = baseProcessData.apply(series, <span class="hljs-built_in">arguments</span>) === <span class="hljs-literal">false</span> ||
                !groupingEnabled || !visible;
            <span class="hljs-keyword">if</span> (!skip) {
                series.destroyGroupedData();
                <span class="hljs-keyword">var</span> i,
                    processedXData = series.processedXData,
                    processedYData = series.processedYData,
                    plotSizeX = chart.plotSizeX,
                    xAxis = series.xAxis,
                    ordinal = xAxis.options.ordinal,
                    groupPixelWidth = series.groupPixelWidth = xAxis.getGroupPixelWidth &amp;&amp; xAxis.getGroupPixelWidth();
                <span class="hljs-keyword">if</span> (groupPixelWidth) {
                    hasGroupedData = <span class="hljs-literal">true</span>;
                    series.isDirty = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">var</span> extremes = xAxis.getExtremes(),
                        xMin = extremes.min,
                        xMax = extremes.max,
                        groupIntervalFactor = (ordinal &amp;&amp; xAxis.getGroupIntervalFactor(xMin, xMax, series)) || <span class="hljs-number">1</span>,
                        interval = (groupPixelWidth * (xMax - xMin) / plotSizeX) * groupIntervalFactor,
                        groupPositions = xAxis.getTimeTicks(
                            xAxis.normalizeTimeTickInterval(interval, dataGroupingOptions.units || defaultDataGroupingUnits),
                            <span class="hljs-built_in">Math</span>.min(xMin, processedXData[<span class="hljs-number">0</span>]),
                            <span class="hljs-built_in">Math</span>.max(xMax, processedXData[processedXData.length - <span class="hljs-number">1</span>]),
                            xAxis.options.startOfWeek,
                            processedXData,
                            series.closestPointRange
                        ),
                        groupedData = seriesProto.groupData.apply(series, [processedXData, processedYData, groupPositions, dataGroupingOptions.approximation]),
                        groupedXData = groupedData[<span class="hljs-number">0</span>],
                        groupedYData = groupedData[<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span> (dataGroupingOptions.smoothed) {
                        i = groupedXData.length - <span class="hljs-number">1</span>;
                        groupedXData[i] = <span class="hljs-built_in">Math</span>.min(groupedXData[i], xMax);
                        <span class="hljs-keyword">while</span> (i-- &amp;&amp; i &gt; <span class="hljs-number">0</span>) {
                            groupedXData[i] += interval / <span class="hljs-number">2</span>;
                        }
                        groupedXData[<span class="hljs-number">0</span>] = <span class="hljs-built_in">Math</span>.max(groupedXData[<span class="hljs-number">0</span>], xMin);
                    }
                    series.currentDataGrouping = groupPositions.info;
                    series.closestPointRange = groupPositions.info.totalRange;
                    series.groupMap = groupedData[<span class="hljs-number">2</span>];
                    <span class="hljs-keyword">if</span> (defined(groupedXData[<span class="hljs-number">0</span>]) &amp;&amp; groupedXData[<span class="hljs-number">0</span>] &lt; xAxis.dataMin) {
                        <span class="hljs-keyword">if</span> (xAxis.min === xAxis.dataMin) {
                            xAxis.min = groupedXData[<span class="hljs-number">0</span>];
                        }
                        xAxis.dataMin = groupedXData[<span class="hljs-number">0</span>];
                    }
                    series.processedXData = groupedXData;
                    series.processedYData = groupedYData;
                } <span class="hljs-keyword">else</span> {
                    series.currentDataGrouping = series.groupMap = <span class="hljs-literal">null</span>;
                }
                series.hasGroupedData = hasGroupedData;
            }
        };
        seriesProto.destroyGroupedData = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> groupedData = <span class="hljs-keyword">this</span>.groupedData;
            each(groupedData || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                <span class="hljs-keyword">if</span> (point) {
                    groupedData[i] = point.destroy ? point.destroy() : <span class="hljs-literal">null</span>;
                }
            });
            <span class="hljs-keyword">this</span>.groupedData = <span class="hljs-literal">null</span>;
        };
        seriesProto.generatePoints = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            baseGeneratePoints.apply(<span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">this</span>.destroyGroupedData();
            <span class="hljs-keyword">this</span>.groupedData = <span class="hljs-keyword">this</span>.hasGroupedData ? <span class="hljs-keyword">this</span>.points : <span class="hljs-literal">null</span>;
        };
        wrap(Point.prototype, <span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dataGroup) {
                H.error(<span class="hljs-number">24</span>);
            } <span class="hljs-keyword">else</span> {
                proceed.apply(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            }
        });
        wrap(Tooltip.prototype, <span class="hljs-string">'tooltipFooterHeaderFormatter'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, labelConfig, isFooter</span>) </span>{
            <span class="hljs-keyword">var</span> tooltip = <span class="hljs-keyword">this</span>,
                series = labelConfig.series,
                options = series.options,
                tooltipOptions = series.tooltipOptions,
                dataGroupingOptions = options.dataGrouping,
                xDateFormat = tooltipOptions.xDateFormat,
                xDateFormatEnd,
                xAxis = series.xAxis,
                dateFormat = H.dateFormat,
                currentDataGrouping,
                dateTimeLabelFormats,
                labelFormats,
                formattedKey;
            <span class="hljs-keyword">if</span> (xAxis &amp;&amp; xAxis.options.type === <span class="hljs-string">'datetime'</span> &amp;&amp; dataGroupingOptions &amp;&amp; isNumber(labelConfig.key)) {
                currentDataGrouping = series.currentDataGrouping;
                dateTimeLabelFormats = dataGroupingOptions.dateTimeLabelFormats;
                <span class="hljs-keyword">if</span> (currentDataGrouping) {
                    labelFormats = dateTimeLabelFormats[currentDataGrouping.unitName];
                    <span class="hljs-keyword">if</span> (currentDataGrouping.count === <span class="hljs-number">1</span>) {
                        xDateFormat = labelFormats[<span class="hljs-number">0</span>];
                    } <span class="hljs-keyword">else</span> {
                        xDateFormat = labelFormats[<span class="hljs-number">1</span>];
                        xDateFormatEnd = labelFormats[<span class="hljs-number">2</span>];
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!xDateFormat &amp;&amp; dateTimeLabelFormats) {
                    xDateFormat = tooltip.getXDateFormat(labelConfig, tooltipOptions, xAxis);
                }
                formattedKey = dateFormat(xDateFormat, labelConfig.key);
                <span class="hljs-keyword">if</span> (xDateFormatEnd) {
                    formattedKey += dateFormat(xDateFormatEnd, labelConfig.key + currentDataGrouping.totalRange - <span class="hljs-number">1</span>);
                }
                <span class="hljs-keyword">return</span> format(tooltipOptions[(isFooter ? <span class="hljs-string">'footer'</span> : <span class="hljs-string">'header'</span>) + <span class="hljs-string">'Format'</span>], {
                    <span class="hljs-attr">point</span>: extend(labelConfig.point, {
                        <span class="hljs-attr">key</span>: formattedKey
                    }),
                    <span class="hljs-attr">series</span>: series
                });
            }
            <span class="hljs-keyword">return</span> proceed.call(tooltip, labelConfig, isFooter);
        });
        seriesProto.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                groupedData = series.groupedData || [],
                i = groupedData.length;
            <span class="hljs-keyword">while</span> (i--) {
                <span class="hljs-keyword">if</span> (groupedData[i]) {
                    groupedData[i].destroy();
                }
            }
            baseDestroy.apply(series);
        };
        wrap(seriesProto, <span class="hljs-string">'setOptions'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, itemOptions</span>) </span>{
            <span class="hljs-keyword">var</span> options = proceed.call(<span class="hljs-keyword">this</span>, itemOptions),
                type = <span class="hljs-keyword">this</span>.type,
                plotOptions = <span class="hljs-keyword">this</span>.chart.options.plotOptions,
                defaultOptions = defaultPlotOptions[type].dataGrouping;
            <span class="hljs-keyword">if</span> (specificOptions[type]) {
                <span class="hljs-keyword">if</span> (!defaultOptions) {
                    defaultOptions = merge(commonOptions, specificOptions[type]);
                }
                options.dataGrouping = merge(
                    defaultOptions,
                    plotOptions.series &amp;&amp; plotOptions.series.dataGrouping,
                    plotOptions[type].dataGrouping,
                    itemOptions.dataGrouping
                );
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart.options.isStock) {
                <span class="hljs-keyword">this</span>.requireSorting = <span class="hljs-literal">true</span>;
            }
            <span class="hljs-keyword">return</span> options;
        });
        wrap(Axis.prototype, <span class="hljs-string">'setScale'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            proceed.call(<span class="hljs-keyword">this</span>);
            each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                series.hasProcessed = <span class="hljs-literal">false</span>;
            });
        });
        Axis.prototype.getGroupPixelWidth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>.series,
                len = series.length,
                i,
                groupPixelWidth = <span class="hljs-number">0</span>,
                doGrouping = <span class="hljs-literal">false</span>,
                dataLength,
                dgOptions;
            i = len;
            <span class="hljs-keyword">while</span> (i--) {
                dgOptions = series[i].options.dataGrouping;
                <span class="hljs-keyword">if</span> (dgOptions) {
                    groupPixelWidth = <span class="hljs-built_in">Math</span>.max(groupPixelWidth, dgOptions.groupPixelWidth);
                }
            }
            i = len;
            <span class="hljs-keyword">while</span> (i--) {
                dgOptions = series[i].options.dataGrouping;
                <span class="hljs-keyword">if</span> (dgOptions &amp;&amp; series[i].hasProcessed) {
                    dataLength = (series[i].processedXData || series[i].data).length;
                    <span class="hljs-keyword">if</span> (series[i].groupPixelWidth || dataLength &gt; (<span class="hljs-keyword">this</span>.chart.plotSizeX / groupPixelWidth) || (dataLength &amp;&amp; dgOptions.forced)) {
                        doGrouping = <span class="hljs-literal">true</span>;
                    }
                }
            }
            <span class="hljs-keyword">return</span> doGrouping ? groupPixelWidth : <span class="hljs-number">0</span>;
        };
        Axis.prototype.setDataGrouping = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dataGrouping, redraw</span>) </span>{
            <span class="hljs-keyword">var</span> i;
            redraw = pick(redraw, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">if</span> (!dataGrouping) {
                dataGrouping = {
                    <span class="hljs-attr">forced</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">units</span>: <span class="hljs-literal">null</span>
                };
            }
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Axis) {
                i = <span class="hljs-keyword">this</span>.series.length;
                <span class="hljs-keyword">while</span> (i--) {
                    <span class="hljs-keyword">this</span>.series[i].update({
                        <span class="hljs-attr">dataGrouping</span>: dataGrouping
                    }, <span class="hljs-literal">false</span>);
                }
            } <span class="hljs-keyword">else</span> {
                each(<span class="hljs-keyword">this</span>.chart.options.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">seriesOptions</span>) </span>{
                    seriesOptions.dataGrouping = dataGrouping;
                }, <span class="hljs-literal">false</span>);
            }
            <span class="hljs-keyword">if</span> (redraw) {
                <span class="hljs-keyword">this</span>.chart.redraw();
            }
        };
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> each = H.each,
            Point = H.Point,
            seriesType = H.seriesType,
            seriesTypes = H.seriesTypes;
        seriesType(<span class="hljs-string">'ohlc'</span>, <span class="hljs-string">'column'</span>, {
            <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">pointFormat</span>: <span class="hljs-string">'&lt;span style="color:{point.color}"&gt;\u25CF&lt;/span&gt; &lt;b&gt; {series.name}&lt;/b&gt;&lt;br/&gt;'</span> +
                    <span class="hljs-string">'Open: {point.open}&lt;br/&gt;'</span> +
                    <span class="hljs-string">'High: {point.high}&lt;br/&gt;'</span> +
                    <span class="hljs-string">'Low: {point.low}&lt;br/&gt;'</span> +
                    <span class="hljs-string">'Close: {point.close}&lt;br/&gt;'</span>
            },
            <span class="hljs-attr">threshold</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">3</span>
                }
            }
        }, {
            <span class="hljs-attr">pointArrayMap</span>: [<span class="hljs-string">'open'</span>, <span class="hljs-string">'high'</span>, <span class="hljs-string">'low'</span>, <span class="hljs-string">'close'</span>],
            <span class="hljs-attr">toYData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                <span class="hljs-keyword">return</span> [point.open, point.high, point.low, point.close];
            },
            <span class="hljs-attr">pointValKey</span>: <span class="hljs-string">'high'</span>,
            <span class="hljs-attr">pointAttrToOptions</span>: {
                <span class="hljs-string">'stroke'</span>: <span class="hljs-string">'color'</span>,
                <span class="hljs-string">'stroke-width'</span>: <span class="hljs-string">'lineWidth'</span>
            },
            <span class="hljs-attr">pointAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> attribs = seriesTypes.column.prototype.pointAttribs.call(
                        <span class="hljs-keyword">this</span>,
                        point,
                        state
                    ),
                    options = <span class="hljs-keyword">this</span>.options;
                <span class="hljs-keyword">delete</span> attribs.fill;
                <span class="hljs-keyword">if</span> (!point.options.color &amp;&amp;
                    options.upColor &amp;&amp;
                    point.open &lt; point.close
                ) {
                    attribs.stroke = options.upColor;
                }
                <span class="hljs-keyword">return</span> attribs;
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    yAxis = series.yAxis,
                    hasModifyValue = !!series.modifyValue,
                    translatedOLC = [<span class="hljs-string">'plotOpen'</span>, <span class="hljs-string">'yBottom'</span>, <span class="hljs-string">'plotClose'</span>];
                seriesTypes.column.prototype.translate.apply(series);
                each(series.points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    each([point.open, point.low, point.close], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, i</span>) </span>{
                        <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span>) {
                            <span class="hljs-keyword">if</span> (hasModifyValue) {
                                value = series.modifyValue(value);
                            }
                            point[translatedOLC[i]] = yAxis.toPixels(value, <span class="hljs-literal">true</span>);
                        }
                    });
                });
            },
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points,
                    chart = series.chart;
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> plotOpen,
                        plotClose,
                        crispCorr,
                        halfWidth,
                        path,
                        graphic = point.graphic,
                        crispX,
                        isNew = !graphic;
                    <span class="hljs-keyword">if</span> (point.plotY !== <span class="hljs-literal">undefined</span>) {
                        <span class="hljs-keyword">if</span> (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }
                        graphic.attr(series.pointAttribs(point, point.selected &amp;&amp; <span class="hljs-string">'select'</span>));
                        crispCorr = (graphic.strokeWidth() % <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;
                        crispX = <span class="hljs-built_in">Math</span>.round(point.plotX) - crispCorr;
                        halfWidth = <span class="hljs-built_in">Math</span>.round(point.shapeArgs.width / <span class="hljs-number">2</span>);
                        path = [
                            <span class="hljs-string">'M'</span>,
                            crispX, <span class="hljs-built_in">Math</span>.round(point.yBottom),
                            <span class="hljs-string">'L'</span>,
                            crispX, <span class="hljs-built_in">Math</span>.round(point.plotY)
                        ];
                        <span class="hljs-keyword">if</span> (point.open !== <span class="hljs-literal">null</span>) {
                            plotOpen = <span class="hljs-built_in">Math</span>.round(point.plotOpen) + crispCorr;
                            path.push(
                                <span class="hljs-string">'M'</span>,
                                crispX,
                                plotOpen,
                                <span class="hljs-string">'L'</span>,
                                crispX - halfWidth,
                                plotOpen
                            );
                        }
                        <span class="hljs-keyword">if</span> (point.close !== <span class="hljs-literal">null</span>) {
                            plotClose = <span class="hljs-built_in">Math</span>.round(point.plotClose) + crispCorr;
                            path.push(
                                <span class="hljs-string">'M'</span>,
                                crispX,
                                plotClose,
                                <span class="hljs-string">'L'</span>,
                                crispX + halfWidth,
                                plotClose
                            );
                        }
                        graphic[isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>]({
                                <span class="hljs-attr">d</span>: path
                            })
                            .addClass(point.getClassName(), <span class="hljs-literal">true</span>);
                    }
                });
            },
            <span class="hljs-attr">animate</span>: <span class="hljs-literal">null</span>
        }, {
            <span class="hljs-attr">getClassName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> Point.prototype.getClassName.call(<span class="hljs-keyword">this</span>) +
                    (<span class="hljs-keyword">this</span>.open &lt; <span class="hljs-keyword">this</span>.close ? <span class="hljs-string">' highcharts-point-up'</span> : <span class="hljs-string">' highcharts-point-down'</span>);
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> defaultPlotOptions = H.defaultPlotOptions,
            each = H.each,
            merge = H.merge,
            seriesType = H.seriesType,
            seriesTypes = H.seriesTypes;
        seriesType(<span class="hljs-string">'candlestick'</span>, <span class="hljs-string">'ohlc'</span>, merge(defaultPlotOptions.column, {
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">2</span>
                }
            },
            <span class="hljs-attr">tooltip</span>: defaultPlotOptions.ohlc.tooltip,
            <span class="hljs-attr">threshold</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">lineColor</span>: <span class="hljs-string">'#000000'</span>,
            <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">upColor</span>: <span class="hljs-string">'#ffffff'</span>
        }), {
            <span class="hljs-attr">pointAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> attribs = seriesTypes.column.prototype.pointAttribs.call(<span class="hljs-keyword">this</span>, point, state),
                    options = <span class="hljs-keyword">this</span>.options,
                    isUp = point.open &lt; point.close,
                    stroke = options.lineColor || <span class="hljs-keyword">this</span>.color,
                    stateOptions;
                attribs[<span class="hljs-string">'stroke-width'</span>] = options.lineWidth;
                attribs.fill = point.options.color || (isUp ? (options.upColor || <span class="hljs-keyword">this</span>.color) : <span class="hljs-keyword">this</span>.color);
                attribs.stroke = point.lineColor || (isUp ? (options.upLineColor || stroke) : stroke);
                <span class="hljs-keyword">if</span> (state) {
                    stateOptions = options.states[state];
                    attribs.fill = stateOptions.color || attribs.fill;
                    attribs.stroke = stateOptions.lineColor || attribs.stroke;
                    attribs[<span class="hljs-string">'stroke-width'</span>] =
                        stateOptions.lineWidth || attribs[<span class="hljs-string">'stroke-width'</span>];
                }
                <span class="hljs-keyword">return</span> attribs;
            },
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points,
                    chart = series.chart;
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> graphic = point.graphic,
                        plotOpen,
                        plotClose,
                        topBox,
                        bottomBox,
                        hasTopWhisker,
                        hasBottomWhisker,
                        crispCorr,
                        crispX,
                        path,
                        halfWidth,
                        isNew = !graphic;
                    <span class="hljs-keyword">if</span> (point.plotY !== <span class="hljs-literal">undefined</span>) {
                        <span class="hljs-keyword">if</span> (!graphic) {
                            point.graphic = graphic = chart.renderer.path()
                                .add(series.group);
                        }
                        graphic
                            .attr(series.pointAttribs(point, point.selected &amp;&amp; <span class="hljs-string">'select'</span>))
                            .shadow(series.options.shadow);
                        crispCorr = (graphic.strokeWidth() % <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>;
                        crispX = <span class="hljs-built_in">Math</span>.round(point.plotX) - crispCorr;
                        plotOpen = point.plotOpen;
                        plotClose = point.plotClose;
                        topBox = <span class="hljs-built_in">Math</span>.min(plotOpen, plotClose);
                        bottomBox = <span class="hljs-built_in">Math</span>.max(plotOpen, plotClose);
                        halfWidth = <span class="hljs-built_in">Math</span>.round(point.shapeArgs.width / <span class="hljs-number">2</span>);
                        hasTopWhisker = <span class="hljs-built_in">Math</span>.round(topBox) !== <span class="hljs-built_in">Math</span>.round(point.plotY);
                        hasBottomWhisker = bottomBox !== point.yBottom;
                        topBox = <span class="hljs-built_in">Math</span>.round(topBox) + crispCorr;
                        bottomBox = <span class="hljs-built_in">Math</span>.round(bottomBox) + crispCorr;
                        path = [];
                        path.push(
                            <span class="hljs-string">'M'</span>,
                            crispX - halfWidth, bottomBox,
                            <span class="hljs-string">'L'</span>,
                            crispX - halfWidth, topBox,
                            <span class="hljs-string">'L'</span>,
                            crispX + halfWidth, topBox,
                            <span class="hljs-string">'L'</span>,
                            crispX + halfWidth, bottomBox,
                            <span class="hljs-string">'Z'</span>,
                            <span class="hljs-string">'M'</span>,
                            crispX, topBox,
                            <span class="hljs-string">'L'</span>,
                            crispX, hasTopWhisker ? <span class="hljs-built_in">Math</span>.round(point.plotY) : topBox,
                            <span class="hljs-string">'M'</span>,
                            crispX, bottomBox,
                            <span class="hljs-string">'L'</span>,
                            crispX, hasBottomWhisker ? <span class="hljs-built_in">Math</span>.round(point.yBottom) : bottomBox
                        );
                        graphic[isNew ? <span class="hljs-string">'attr'</span> : <span class="hljs-string">'animate'</span>]({
                                <span class="hljs-attr">d</span>: path
                            })
                            .addClass(point.getClassName(), <span class="hljs-literal">true</span>);
                    }
                });
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            each = H.each,
            merge = H.merge,
            noop = H.noop,
            Renderer = H.Renderer,
            Series = H.Series,
            seriesType = H.seriesType,
            seriesTypes = H.seriesTypes,
            SVGRenderer = H.SVGRenderer,
            TrackerMixin = H.TrackerMixin,
            VMLRenderer = H.VMLRenderer,
            symbols = SVGRenderer.prototype.symbols;
        seriesType(<span class="hljs-string">'flags'</span>, <span class="hljs-string">'column'</span>, {
            <span class="hljs-attr">pointRange</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">shape</span>: <span class="hljs-string">'flag'</span>,
            <span class="hljs-attr">stackDistance</span>: <span class="hljs-number">12</span>,
            <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>,
            <span class="hljs-attr">tooltip</span>: {
                <span class="hljs-attr">pointFormat</span>: <span class="hljs-string">'{point.text}&lt;br/&gt;'</span>
            },
            <span class="hljs-attr">threshold</span>: <span class="hljs-literal">null</span>,
            <span class="hljs-attr">y</span>: <span class="hljs-number">-30</span>,
            <span class="hljs-attr">fillColor</span>: <span class="hljs-string">'#ffffff'</span>,
            <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">states</span>: {
                <span class="hljs-attr">hover</span>: {
                    <span class="hljs-attr">lineColor</span>: <span class="hljs-string">'#000000'</span>,
                    <span class="hljs-attr">fillColor</span>: <span class="hljs-string">'#ccd6eb'</span>
                }
            },
            <span class="hljs-attr">style</span>: {
                <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'11px'</span>,
                <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'bold'</span>
            }
        }, {
            <span class="hljs-attr">sorted</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">noSharedTooltip</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">allowDG</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">takeOrdinalPosition</span>: <span class="hljs-literal">false</span>,
            <span class="hljs-attr">trackerGroups</span>: [<span class="hljs-string">'markerGroup'</span>],
            <span class="hljs-attr">forceCrop</span>: <span class="hljs-literal">true</span>,
            <span class="hljs-attr">init</span>: Series.prototype.init,
            <span class="hljs-attr">pointAttribs</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, state</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options,
                    color = (point &amp;&amp; point.color) || <span class="hljs-keyword">this</span>.color,
                    lineColor = options.lineColor,
                    lineWidth = (point &amp;&amp; point.lineWidth),
                    fill = (point &amp;&amp; point.fillColor) || options.fillColor;
                <span class="hljs-keyword">if</span> (state) {
                    fill = options.states[state].fillColor;
                    lineColor = options.states[state].lineColor;
                    lineWidth = options.states[state].lineWidth;
                }
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-string">'fill'</span>: fill || color,
                    <span class="hljs-string">'stroke'</span>: lineColor || color,
                    <span class="hljs-string">'stroke-width'</span>: lineWidth || options.lineWidth || <span class="hljs-number">0</span>
                };
            },
            <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                seriesTypes.column.prototype.translate.apply(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    options = series.options,
                    chart = series.chart,
                    points = series.points,
                    cursor = points.length - <span class="hljs-number">1</span>,
                    point,
                    lastPoint,
                    optionsOnSeries = options.onSeries,
                    onSeries = optionsOnSeries &amp;&amp; chart.get(optionsOnSeries),
                    onKey = options.onKey || <span class="hljs-string">'y'</span>,
                    step = onSeries &amp;&amp; onSeries.options.step,
                    onData = onSeries &amp;&amp; onSeries.points,
                    i = onData &amp;&amp; onData.length,
                    xAxis = series.xAxis,
                    xAxisExt = xAxis.getExtremes(),
                    xOffset = <span class="hljs-number">0</span>,
                    leftPoint,
                    lastX,
                    rightPoint,
                    currentDataGrouping;
                <span class="hljs-keyword">if</span> (onSeries &amp;&amp; onSeries.visible &amp;&amp; i) {
                    xOffset = (onSeries.pointXOffset || <span class="hljs-number">0</span>) + (onSeries.barW || <span class="hljs-number">0</span>) / <span class="hljs-number">2</span>;
                    currentDataGrouping = onSeries.currentDataGrouping;
                    lastX = onData[i - <span class="hljs-number">1</span>].x + (currentDataGrouping ? currentDataGrouping.totalRange : <span class="hljs-number">0</span>);
                    points.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
                        <span class="hljs-keyword">return</span> (a.x - b.x);
                    });
                    onKey = <span class="hljs-string">'plot'</span> + onKey[<span class="hljs-number">0</span>].toUpperCase() + onKey.substr(<span class="hljs-number">1</span>);
                    <span class="hljs-keyword">while</span> (i-- &amp;&amp; points[cursor]) {
                        point = points[cursor];
                        leftPoint = onData[i];
                        <span class="hljs-keyword">if</span> (leftPoint.x &lt;= point.x &amp;&amp; leftPoint[onKey] !== <span class="hljs-literal">undefined</span>) {
                            <span class="hljs-keyword">if</span> (point.x &lt;= lastX) {
                                point.plotY = leftPoint[onKey];
                                <span class="hljs-keyword">if</span> (leftPoint.x &lt; point.x &amp;&amp; !step) {
                                    rightPoint = onData[i + <span class="hljs-number">1</span>];
                                    <span class="hljs-keyword">if</span> (rightPoint &amp;&amp; rightPoint[onKey] !== <span class="hljs-literal">undefined</span>) {
                                        point.plotY +=
                                            ((point.x - leftPoint.x) / (rightPoint.x - leftPoint.x)) *
                                            (rightPoint[onKey] - leftPoint[onKey]);
                                    }
                                }
                            }
                            cursor--;
                            i++;
                            <span class="hljs-keyword">if</span> (cursor &lt; <span class="hljs-number">0</span>) {
                                <span class="hljs-keyword">break</span>;
                            }
                        }
                    }
                }
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point, i</span>) </span>{
                    <span class="hljs-keyword">var</span> stackIndex;
                    <span class="hljs-keyword">if</span> (point.plotY === <span class="hljs-literal">undefined</span>) {
                        <span class="hljs-keyword">if</span> (point.x &gt;= xAxisExt.min &amp;&amp; point.x &lt;= xAxisExt.max) {
                            point.plotY = chart.chartHeight - xAxis.bottom - (xAxis.opposite ? xAxis.height : <span class="hljs-number">0</span>) + xAxis.offset - chart.plotTop;
                        } <span class="hljs-keyword">else</span> {
                            point.shapeArgs = {};
                        }
                    }
                    point.plotX += xOffset;
                    lastPoint = points[i - <span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span> (lastPoint &amp;&amp; lastPoint.plotX === point.plotX) {
                        <span class="hljs-keyword">if</span> (lastPoint.stackIndex === <span class="hljs-literal">undefined</span>) {
                            lastPoint.stackIndex = <span class="hljs-number">0</span>;
                        }
                        stackIndex = lastPoint.stackIndex + <span class="hljs-number">1</span>;
                    }
                    point.stackIndex = stackIndex;
                });
            },
            <span class="hljs-attr">drawPoints</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points,
                    chart = series.chart,
                    renderer = chart.renderer,
                    plotX,
                    plotY,
                    options = series.options,
                    optionsY = options.y,
                    shape,
                    i,
                    point,
                    graphic,
                    stackIndex,
                    anchorX,
                    anchorY,
                    outsideRight,
                    yAxis = series.yAxis;
                i = points.length;
                <span class="hljs-keyword">while</span> (i--) {
                    point = points[i];
                    outsideRight = point.plotX &gt; series.xAxis.len;
                    plotX = point.plotX;
                    stackIndex = point.stackIndex;
                    shape = point.options.shape || options.shape;
                    plotY = point.plotY;
                    <span class="hljs-keyword">if</span> (plotY !== <span class="hljs-literal">undefined</span>) {
                        plotY = point.plotY + optionsY - (stackIndex !== <span class="hljs-literal">undefined</span> &amp;&amp; stackIndex * options.stackDistance);
                    }
                    anchorX = stackIndex ? <span class="hljs-literal">undefined</span> : point.plotX;
                    anchorY = stackIndex ? <span class="hljs-literal">undefined</span> : point.plotY;
                    graphic = point.graphic;
                    <span class="hljs-keyword">if</span> (plotY !== <span class="hljs-literal">undefined</span> &amp;&amp; plotX &gt;= <span class="hljs-number">0</span> &amp;&amp; !outsideRight) {
                        <span class="hljs-keyword">if</span> (!graphic) {
                            graphic = point.graphic = renderer.label(
                                    <span class="hljs-string">''</span>,
                                    <span class="hljs-literal">null</span>,
                                    <span class="hljs-literal">null</span>,
                                    shape,
                                    <span class="hljs-literal">null</span>,
                                    <span class="hljs-literal">null</span>,
                                    options.useHTML
                                )
                                .attr(series.pointAttribs(point))
                                .css(merge(options.style, point.style))
                                .attr({
                                    <span class="hljs-attr">align</span>: shape === <span class="hljs-string">'flag'</span> ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'center'</span>,
                                    <span class="hljs-attr">width</span>: options.width,
                                    <span class="hljs-attr">height</span>: options.height,
                                    <span class="hljs-string">'text-align'</span>: options.textAlign
                                })
                                .addClass(<span class="hljs-string">'highcharts-point'</span>)
                                .add(series.markerGroup);
                            graphic.shadow(options.shadow);
                        }
                        <span class="hljs-keyword">if</span> (plotX &gt; <span class="hljs-number">0</span>) {
                            plotX -= graphic.strokeWidth() % <span class="hljs-number">2</span>;
                        }
                        graphic.attr({
                            <span class="hljs-attr">text</span>: point.options.title || options.title || <span class="hljs-string">'A'</span>,
                            <span class="hljs-attr">x</span>: plotX,
                            <span class="hljs-attr">y</span>: plotY,
                            <span class="hljs-attr">anchorX</span>: anchorX,
                            <span class="hljs-attr">anchorY</span>: anchorY
                        });
                        point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - plotX] : [plotX, plotY];
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (graphic) {
                        point.graphic = graphic.destroy();
                    }
                }
            },
            <span class="hljs-attr">drawTracker</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                    points = series.points;
                TrackerMixin.drawTrackerPoint.apply(<span class="hljs-keyword">this</span>);
                each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">point</span>) </span>{
                    <span class="hljs-keyword">var</span> graphic = point.graphic;
                    <span class="hljs-keyword">if</span> (graphic) {
                        addEvent(graphic.element, <span class="hljs-string">'mouseover'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (point.stackIndex &gt; <span class="hljs-number">0</span> &amp;&amp; !point.raised) {
                                point._y = graphic.y;
                                graphic.attr({
                                    <span class="hljs-attr">y</span>: point._y - <span class="hljs-number">8</span>
                                });
                                point.raised = <span class="hljs-literal">true</span>;
                            }
                            each(points, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherPoint</span>) </span>{
                                <span class="hljs-keyword">if</span> (otherPoint !== point &amp;&amp; otherPoint.raised &amp;&amp; otherPoint.graphic) {
                                    otherPoint.graphic.attr({
                                        <span class="hljs-attr">y</span>: otherPoint._y
                                    });
                                    otherPoint.raised = <span class="hljs-literal">false</span>;
                                }
                            });
                        });
                    }
                });
            },
            <span class="hljs-attr">animate</span>: noop,
            <span class="hljs-attr">buildKDTree</span>: noop,
            <span class="hljs-attr">setClip</span>: noop
        });
        symbols.flag = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
            <span class="hljs-keyword">var</span> anchorX = (options &amp;&amp; options.anchorX) || x,
                anchorY = (options &amp;&amp; options.anchorY) || y;
            <span class="hljs-keyword">return</span> [
                <span class="hljs-string">'M'</span>, anchorX, anchorY,
                <span class="hljs-string">'L'</span>, x, y + h,
                x, y,
                x + w, y,
                x + w, y + h,
                x, y + h,
                <span class="hljs-string">'Z'</span>
            ];
        };
        each([<span class="hljs-string">'circle'</span>, <span class="hljs-string">'square'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shape</span>) </span>{
            symbols[shape + <span class="hljs-string">'pin'</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, w, h, options</span>) </span>{
                <span class="hljs-keyword">var</span> anchorX = options &amp;&amp; options.anchorX,
                    anchorY = options &amp;&amp; options.anchorY,
                    path,
                    labelTopOrBottomY;
                <span class="hljs-keyword">if</span> (shape === <span class="hljs-string">'circle'</span> &amp;&amp; h &gt; w) {
                    x -= <span class="hljs-built_in">Math</span>.round((h - w) / <span class="hljs-number">2</span>);
                    w = h;
                }
                path = symbols[shape](x, y, w, h);
                <span class="hljs-keyword">if</span> (anchorX &amp;&amp; anchorY) {
                    labelTopOrBottomY = (y &gt; anchorY) ? y : y + h;
                    path.push(<span class="hljs-string">'M'</span>, anchorX, labelTopOrBottomY, <span class="hljs-string">'L'</span>, anchorX, anchorY);
                }
                <span class="hljs-keyword">return</span> path;
            };
        });
        <span class="hljs-keyword">if</span> (Renderer === VMLRenderer) {
            each([<span class="hljs-string">'flag'</span>, <span class="hljs-string">'circlepin'</span>, <span class="hljs-string">'squarepin'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shape</span>) </span>{
                VMLRenderer.prototype.symbols[shape] = symbols[shape];
            });
        }
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            Axis = H.Axis,
            correctFloat = H.correctFloat,
            defaultOptions = H.defaultOptions,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            doc = H.doc,
            each = H.each,
            fireEvent = H.fireEvent,
            hasTouch = H.hasTouch,
            isTouchDevice = H.isTouchDevice,
            merge = H.merge,
            pick = H.pick,
            removeEvent = H.removeEvent,
            svg = H.svg,
            wrap = H.wrap,
            swapXY;
        <span class="hljs-keyword">var</span> defaultScrollbarOptions = {
            <span class="hljs-attr">height</span>: isTouchDevice ? <span class="hljs-number">20</span> : <span class="hljs-number">14</span>,
            <span class="hljs-attr">barBorderRadius</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">buttonBorderRadius</span>: <span class="hljs-number">0</span>,
            <span class="hljs-attr">liveRedraw</span>: svg &amp;&amp; !isTouchDevice,
            <span class="hljs-attr">margin</span>: <span class="hljs-number">10</span>,
            <span class="hljs-attr">minWidth</span>: <span class="hljs-number">6</span>,
            <span class="hljs-attr">step</span>: <span class="hljs-number">0.2</span>,
            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">3</span>,
            <span class="hljs-attr">barBackgroundColor</span>: <span class="hljs-string">'#cccccc'</span>,
            <span class="hljs-attr">barBorderWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">barBorderColor</span>: <span class="hljs-string">'#cccccc'</span>,
            <span class="hljs-attr">buttonArrowColor</span>: <span class="hljs-string">'#333333'</span>,
            <span class="hljs-attr">buttonBackgroundColor</span>: <span class="hljs-string">'#e6e6e6'</span>,
            <span class="hljs-attr">buttonBorderColor</span>: <span class="hljs-string">'#cccccc'</span>,
            <span class="hljs-attr">buttonBorderWidth</span>: <span class="hljs-number">1</span>,
            <span class="hljs-attr">rifleColor</span>: <span class="hljs-string">'#333333'</span>,
            <span class="hljs-attr">trackBackgroundColor</span>: <span class="hljs-string">'#f2f2f2'</span>,
            <span class="hljs-attr">trackBorderColor</span>: <span class="hljs-string">'#f2f2f2'</span>,
            <span class="hljs-attr">trackBorderWidth</span>: <span class="hljs-number">1</span>
        };
        defaultOptions.scrollbar = merge(<span class="hljs-literal">true</span>, defaultScrollbarOptions, defaultOptions.scrollbar);
        H.swapXY = swapXY = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">path, vertical</span>) </span>{
            <span class="hljs-keyword">var</span> i,
                len = path.length,
                temp;
            <span class="hljs-keyword">if</span> (vertical) {
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">3</span>) {
                    temp = path[i + <span class="hljs-number">1</span>];
                    path[i + <span class="hljs-number">1</span>] = path[i + <span class="hljs-number">2</span>];
                    path[i + <span class="hljs-number">2</span>] = temp;
                }
            }
            <span class="hljs-keyword">return</span> path;
        };

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Scrollbar</span>(<span class="hljs-params">renderer, options, chart</span>) </span>{
            <span class="hljs-keyword">this</span>.init(renderer, options, chart);
        }
        Scrollbar.prototype = {
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">renderer, options, chart</span>) </span>{
                <span class="hljs-keyword">this</span>.scrollbarButtons = [];
                <span class="hljs-keyword">this</span>.renderer = renderer;
                <span class="hljs-keyword">this</span>.userOptions = options;
                <span class="hljs-keyword">this</span>.options = merge(defaultScrollbarOptions, options);
                <span class="hljs-keyword">this</span>.chart = chart;
                <span class="hljs-keyword">this</span>.size = pick(<span class="hljs-keyword">this</span>.options.size, <span class="hljs-keyword">this</span>.options.height);
                <span class="hljs-keyword">if</span> (options.enabled) {
                    <span class="hljs-keyword">this</span>.render();
                    <span class="hljs-keyword">this</span>.initEvents();
                    <span class="hljs-keyword">this</span>.addEvents();
                }
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>,
                    renderer = scroller.renderer,
                    options = scroller.options,
                    size = scroller.size,
                    group;
                scroller.group = group = renderer.g(<span class="hljs-string">'scrollbar'</span>).attr({
                    <span class="hljs-attr">zIndex</span>: options.zIndex,
                    <span class="hljs-attr">translateY</span>: <span class="hljs-number">-99999</span>
                }).add();
                scroller.track = renderer.rect()
                    .addClass(<span class="hljs-string">'highcharts-scrollbar-track'</span>)
                    .attr({
                        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">r</span>: options.trackBorderRadius || <span class="hljs-number">0</span>,
                        <span class="hljs-attr">height</span>: size,
                        <span class="hljs-attr">width</span>: size
                    }).add(group);
                scroller.track.attr({
                    <span class="hljs-attr">fill</span>: options.trackBackgroundColor,
                    <span class="hljs-attr">stroke</span>: options.trackBorderColor,
                    <span class="hljs-string">'stroke-width'</span>: options.trackBorderWidth
                });
                <span class="hljs-keyword">this</span>.trackBorderWidth = scroller.track.strokeWidth();
                scroller.track.attr({
                    <span class="hljs-attr">y</span>: -<span class="hljs-keyword">this</span>.trackBorderWidth % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>
                });
                scroller.scrollbarGroup = renderer.g().add(group);
                scroller.scrollbar = renderer.rect()
                    .addClass(<span class="hljs-string">'highcharts-scrollbar-thumb'</span>)
                    .attr({
                        <span class="hljs-attr">height</span>: size,
                        <span class="hljs-attr">width</span>: size,
                        <span class="hljs-attr">r</span>: options.barBorderRadius || <span class="hljs-number">0</span>
                    }).add(scroller.scrollbarGroup);
                scroller.scrollbarRifles = renderer.path(
                        swapXY([
                            <span class="hljs-string">'M'</span>, <span class="hljs-number">-3</span>, size / <span class="hljs-number">4</span>,
                            <span class="hljs-string">'L'</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">2</span> * size / <span class="hljs-number">3</span>,
                            <span class="hljs-string">'M'</span>,
                            <span class="hljs-number">0</span>, size / <span class="hljs-number">4</span>,
                            <span class="hljs-string">'L'</span>,
                            <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * size / <span class="hljs-number">3</span>,
                            <span class="hljs-string">'M'</span>,
                            <span class="hljs-number">3</span>, size / <span class="hljs-number">4</span>,
                            <span class="hljs-string">'L'</span>,
                            <span class="hljs-number">3</span>, <span class="hljs-number">2</span> * size / <span class="hljs-number">3</span>
                        ], options.vertical))
                    .addClass(<span class="hljs-string">'highcharts-scrollbar-rifles'</span>)
                    .add(scroller.scrollbarGroup);
                scroller.scrollbar.attr({
                    <span class="hljs-attr">fill</span>: options.barBackgroundColor,
                    <span class="hljs-attr">stroke</span>: options.barBorderColor,
                    <span class="hljs-string">'stroke-width'</span>: options.barBorderWidth
                });
                scroller.scrollbarRifles.attr({
                    <span class="hljs-attr">stroke</span>: options.rifleColor,
                    <span class="hljs-string">'stroke-width'</span>: <span class="hljs-number">1</span>
                });
                scroller.scrollbarStrokeWidth = scroller.scrollbar.strokeWidth();
                scroller.scrollbarGroup.translate(-scroller.scrollbarStrokeWidth % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>, -scroller.scrollbarStrokeWidth % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>);
                scroller.drawScrollbarButton(<span class="hljs-number">0</span>);
                scroller.drawScrollbarButton(<span class="hljs-number">1</span>);
            },
            <span class="hljs-attr">position</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, y, width, height</span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>,
                    options = scroller.options,
                    vertical = options.vertical,
                    xOffset = height,
                    yOffset = <span class="hljs-number">0</span>,
                    method = scroller.rendered ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>;
                scroller.x = x;
                scroller.y = y + <span class="hljs-keyword">this</span>.trackBorderWidth;
                scroller.width = width;
                scroller.height = height;
                scroller.xOffset = xOffset;
                scroller.yOffset = yOffset;
                <span class="hljs-keyword">if</span> (vertical) {
                    scroller.width = scroller.yOffset = width = yOffset = scroller.size;
                    scroller.xOffset = xOffset = <span class="hljs-number">0</span>;
                    scroller.barWidth = height - width * <span class="hljs-number">2</span>;
                    scroller.x = x = x + scroller.options.margin;
                } <span class="hljs-keyword">else</span> {
                    scroller.height = scroller.xOffset = height = xOffset = scroller.size;
                    scroller.barWidth = width - height * <span class="hljs-number">2</span>;
                    scroller.y = scroller.y + scroller.options.margin;
                }
                scroller.group[method]({
                    <span class="hljs-attr">translateX</span>: x,
                    <span class="hljs-attr">translateY</span>: scroller.y
                });
                scroller.track[method]({
                    <span class="hljs-attr">width</span>: width,
                    <span class="hljs-attr">height</span>: height
                });
                scroller.scrollbarButtons[<span class="hljs-number">1</span>][method]({
                    <span class="hljs-attr">translateX</span>: vertical ? <span class="hljs-number">0</span> : width - xOffset,
                    <span class="hljs-attr">translateY</span>: vertical ? height - yOffset : <span class="hljs-number">0</span>
                });
            },
            <span class="hljs-attr">drawScrollbarButton</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>,
                    renderer = scroller.renderer,
                    scrollbarButtons = scroller.scrollbarButtons,
                    options = scroller.options,
                    size = scroller.size,
                    group,
                    tempElem;
                group = renderer.g().add(scroller.group);
                scrollbarButtons.push(group);
                tempElem = renderer.rect()
                    .addClass(<span class="hljs-string">'highcharts-scrollbar-button'</span>)
                    .add(group);
                tempElem.attr({
                    <span class="hljs-attr">stroke</span>: options.buttonBorderColor,
                    <span class="hljs-string">'stroke-width'</span>: options.buttonBorderWidth,
                    <span class="hljs-attr">fill</span>: options.buttonBackgroundColor
                });
                tempElem.attr(tempElem.crisp({
                    <span class="hljs-attr">x</span>: <span class="hljs-number">-0.5</span>,
                    <span class="hljs-attr">y</span>: <span class="hljs-number">-0.5</span>,
                    <span class="hljs-attr">width</span>: size + <span class="hljs-number">1</span>,
                    <span class="hljs-attr">height</span>: size + <span class="hljs-number">1</span>,
                    <span class="hljs-attr">r</span>: options.buttonBorderRadius
                }, tempElem.strokeWidth()));
                tempElem = renderer
                    .path(swapXY([
                        <span class="hljs-string">'M'</span>,
                        size / <span class="hljs-number">2</span> + (index ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>),
                        size / <span class="hljs-number">2</span> - <span class="hljs-number">3</span>,
                        <span class="hljs-string">'L'</span>,
                        size / <span class="hljs-number">2</span> + (index ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>),
                        size / <span class="hljs-number">2</span> + <span class="hljs-number">3</span>,
                        <span class="hljs-string">'L'</span>,
                        size / <span class="hljs-number">2</span> + (index ? <span class="hljs-number">2</span> : <span class="hljs-number">-2</span>),
                        size / <span class="hljs-number">2</span>
                    ], options.vertical))
                    .addClass(<span class="hljs-string">'highcharts-scrollbar-arrow'</span>)
                    .add(scrollbarButtons[index]);
                tempElem.attr({
                    <span class="hljs-attr">fill</span>: options.buttonArrowColor
                });
            },
            <span class="hljs-attr">setRange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to</span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>,
                    options = scroller.options,
                    vertical = options.vertical,
                    minWidth = options.minWidth,
                    fullWidth = scroller.barWidth,
                    fromPX,
                    toPX,
                    newPos,
                    newSize,
                    newRiflesPos,
                    method = <span class="hljs-keyword">this</span>.rendered &amp;&amp; !<span class="hljs-keyword">this</span>.hasDragged ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>;
                <span class="hljs-keyword">if</span> (!defined(fullWidth)) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">from</span> = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">from</span>, <span class="hljs-number">0</span>);
                fromPX = fullWidth * <span class="hljs-keyword">from</span>;
                toPX = fullWidth * <span class="hljs-built_in">Math</span>.min(to, <span class="hljs-number">1</span>);
                scroller.calculatedWidth = newSize = correctFloat(toPX - fromPX);
                <span class="hljs-keyword">if</span> (newSize &lt; minWidth) {
                    fromPX = (fullWidth - minWidth + newSize) * <span class="hljs-keyword">from</span>;
                    newSize = minWidth;
                }
                newPos = <span class="hljs-built_in">Math</span>.floor(fromPX + scroller.xOffset + scroller.yOffset);
                newRiflesPos = newSize / <span class="hljs-number">2</span> - <span class="hljs-number">0.5</span>;
                scroller.from = <span class="hljs-keyword">from</span>;
                scroller.to = to;
                <span class="hljs-keyword">if</span> (!vertical) {
                    scroller.scrollbarGroup[method]({
                        <span class="hljs-attr">translateX</span>: newPos
                    });
                    scroller.scrollbar[method]({
                        <span class="hljs-attr">width</span>: newSize
                    });
                    scroller.scrollbarRifles[method]({
                        <span class="hljs-attr">translateX</span>: newRiflesPos
                    });
                    scroller.scrollbarLeft = newPos;
                    scroller.scrollbarTop = <span class="hljs-number">0</span>;
                } <span class="hljs-keyword">else</span> {
                    scroller.scrollbarGroup[method]({
                        <span class="hljs-attr">translateY</span>: newPos
                    });
                    scroller.scrollbar[method]({
                        <span class="hljs-attr">height</span>: newSize
                    });
                    scroller.scrollbarRifles[method]({
                        <span class="hljs-attr">translateY</span>: newRiflesPos
                    });
                    scroller.scrollbarTop = newPos;
                    scroller.scrollbarLeft = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">if</span> (newSize &lt;= <span class="hljs-number">12</span>) {
                    scroller.scrollbarRifles.hide();
                } <span class="hljs-keyword">else</span> {
                    scroller.scrollbarRifles.show(<span class="hljs-literal">true</span>);
                }
                <span class="hljs-keyword">if</span> (options.showFull === <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> &lt;= <span class="hljs-number">0</span> &amp;&amp; to &gt;= <span class="hljs-number">1</span>) {
                        scroller.group.hide();
                    } <span class="hljs-keyword">else</span> {
                        scroller.group.show();
                    }
                }
                scroller.rendered = <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">initEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>;
                scroller.mouseMoveHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> normalizedEvent = scroller.chart.pointer.normalize(e),
                        options = scroller.options,
                        direction = options.vertical ? <span class="hljs-string">'chartY'</span> : <span class="hljs-string">'chartX'</span>,
                        initPositions = scroller.initPositions,
                        scrollPosition,
                        chartPosition,
                        change;
                    <span class="hljs-keyword">if</span> (scroller.grabbedCenter &amp;&amp; (!e.touches || e.touches[<span class="hljs-number">0</span>][direction] !== <span class="hljs-number">0</span>)) {
                        chartPosition = scroller.cursorToScrollbarPosition(normalizedEvent)[direction];
                        scrollPosition = scroller[direction];
                        change = chartPosition - scrollPosition;
                        scroller.hasDragged = <span class="hljs-literal">true</span>;
                        scroller.updatePosition(initPositions[<span class="hljs-number">0</span>] + change, initPositions[<span class="hljs-number">1</span>] + change);
                        <span class="hljs-keyword">if</span> (scroller.hasDragged) {
                            fireEvent(scroller, <span class="hljs-string">'changed'</span>, {
                                <span class="hljs-attr">from</span>: scroller.from,
                                <span class="hljs-attr">to</span>: scroller.to,
                                <span class="hljs-attr">trigger</span>: <span class="hljs-string">'scrollbar'</span>,
                                <span class="hljs-attr">DOMType</span>: e.type,
                                <span class="hljs-attr">DOMEvent</span>: e
                            });
                        }
                    }
                };
                scroller.mouseUpHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">if</span> (scroller.hasDragged) {
                        fireEvent(scroller, <span class="hljs-string">'changed'</span>, {
                            <span class="hljs-attr">from</span>: scroller.from,
                            <span class="hljs-attr">to</span>: scroller.to,
                            <span class="hljs-attr">trigger</span>: <span class="hljs-string">'scrollbar'</span>,
                            <span class="hljs-attr">DOMType</span>: e.type,
                            <span class="hljs-attr">DOMEvent</span>: e
                        });
                    }
                    scroller.grabbedCenter = scroller.hasDragged = scroller.chartX = scroller.chartY = <span class="hljs-literal">null</span>;
                };
                scroller.mouseDownHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> normalizedEvent = scroller.chart.pointer.normalize(e),
                        mousePosition = scroller.cursorToScrollbarPosition(normalizedEvent);
                    scroller.chartX = mousePosition.chartX;
                    scroller.chartY = mousePosition.chartY;
                    scroller.initPositions = [scroller.from, scroller.to];
                    scroller.grabbedCenter = <span class="hljs-literal">true</span>;
                };
                scroller.buttonToMinClick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> range = correctFloat(scroller.to - scroller.from) * scroller.options.step;
                    scroller.updatePosition(correctFloat(scroller.from - range), correctFloat(scroller.to - range));
                    fireEvent(scroller, <span class="hljs-string">'changed'</span>, {
                        <span class="hljs-attr">from</span>: scroller.from,
                        <span class="hljs-attr">to</span>: scroller.to,
                        <span class="hljs-attr">trigger</span>: <span class="hljs-string">'scrollbar'</span>,
                        <span class="hljs-attr">DOMEvent</span>: e
                    });
                };
                scroller.buttonToMaxClick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> range = (scroller.to - scroller.from) * scroller.options.step;
                    scroller.updatePosition(scroller.from + range, scroller.to + range);
                    fireEvent(scroller, <span class="hljs-string">'changed'</span>, {
                        <span class="hljs-attr">from</span>: scroller.from,
                        <span class="hljs-attr">to</span>: scroller.to,
                        <span class="hljs-attr">trigger</span>: <span class="hljs-string">'scrollbar'</span>,
                        <span class="hljs-attr">DOMEvent</span>: e
                    });
                };
                scroller.trackClick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> normalizedEvent = scroller.chart.pointer.normalize(e),
                        range = scroller.to - scroller.from,
                        top = scroller.y + scroller.scrollbarTop,
                        left = scroller.x + scroller.scrollbarLeft;
                    <span class="hljs-keyword">if</span> ((scroller.options.vertical &amp;&amp; normalizedEvent.chartY &gt; top) ||
                        (!scroller.options.vertical &amp;&amp; normalizedEvent.chartX &gt; left)) {
                        scroller.updatePosition(scroller.from + range, scroller.to + range);
                    } <span class="hljs-keyword">else</span> {
                        scroller.updatePosition(scroller.from - range, scroller.to - range);
                    }
                    fireEvent(scroller, <span class="hljs-string">'changed'</span>, {
                        <span class="hljs-attr">from</span>: scroller.from,
                        <span class="hljs-attr">to</span>: scroller.to,
                        <span class="hljs-attr">trigger</span>: <span class="hljs-string">'scrollbar'</span>,
                        <span class="hljs-attr">DOMEvent</span>: e
                    });
                };
            },
            <span class="hljs-attr">cursorToScrollbarPosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">normalizedEvent</span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>,
                    options = scroller.options,
                    minWidthDifference = options.minWidth &gt; scroller.calculatedWidth ? options.minWidth : <span class="hljs-number">0</span>;
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">chartX</span>: (normalizedEvent.chartX - scroller.x - scroller.xOffset) / (scroller.barWidth - minWidthDifference),
                    <span class="hljs-attr">chartY</span>: (normalizedEvent.chartY - scroller.y - scroller.yOffset) / (scroller.barWidth - minWidthDifference)
                };
            },
            <span class="hljs-attr">updatePosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to</span>) </span>{
                <span class="hljs-keyword">if</span> (to &gt; <span class="hljs-number">1</span>) {
                    <span class="hljs-keyword">from</span> = correctFloat(<span class="hljs-number">1</span> - correctFloat(to - <span class="hljs-keyword">from</span>));
                    to = <span class="hljs-number">1</span>;
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> &lt; <span class="hljs-number">0</span>) {
                    to = correctFloat(to - <span class="hljs-keyword">from</span>);
                    <span class="hljs-keyword">from</span> = <span class="hljs-number">0</span>;
                }
                <span class="hljs-keyword">this</span>.from = <span class="hljs-keyword">from</span>;
                <span class="hljs-keyword">this</span>.to = to;
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">this</span>.destroy();
                <span class="hljs-keyword">this</span>.init(<span class="hljs-keyword">this</span>.chart.renderer, merge(<span class="hljs-literal">true</span>, <span class="hljs-keyword">this</span>.options, options), <span class="hljs-keyword">this</span>.chart);
            },
            <span class="hljs-attr">addEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> buttonsOrder = <span class="hljs-keyword">this</span>.options.inverted ? [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] : [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],
                    buttons = <span class="hljs-keyword">this</span>.scrollbarButtons,
                    bar = <span class="hljs-keyword">this</span>.scrollbarGroup.element,
                    track = <span class="hljs-keyword">this</span>.track.element,
                    mouseDownHandler = <span class="hljs-keyword">this</span>.mouseDownHandler,
                    mouseMoveHandler = <span class="hljs-keyword">this</span>.mouseMoveHandler,
                    mouseUpHandler = <span class="hljs-keyword">this</span>.mouseUpHandler,
                    _events;
                _events = [
                    [buttons[buttonsOrder[<span class="hljs-number">0</span>]].element, <span class="hljs-string">'click'</span>, <span class="hljs-keyword">this</span>.buttonToMinClick],
                    [buttons[buttonsOrder[<span class="hljs-number">1</span>]].element, <span class="hljs-string">'click'</span>, <span class="hljs-keyword">this</span>.buttonToMaxClick],
                    [track, <span class="hljs-string">'click'</span>, <span class="hljs-keyword">this</span>.trackClick],
                    [bar, <span class="hljs-string">'mousedown'</span>, mouseDownHandler],
                    [doc, <span class="hljs-string">'mousemove'</span>, mouseMoveHandler],
                    [doc, <span class="hljs-string">'mouseup'</span>, mouseUpHandler]
                ];
                <span class="hljs-keyword">if</span> (hasTouch) {
                    _events.push(
                        [bar, <span class="hljs-string">'touchstart'</span>, mouseDownHandler], [doc, <span class="hljs-string">'touchmove'</span>, mouseMoveHandler], [doc, <span class="hljs-string">'touchend'</span>, mouseUpHandler]
                    );
                }
                each(_events, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
                    addEvent.apply(<span class="hljs-literal">null</span>, args);
                });
                <span class="hljs-keyword">this</span>._events = _events;
            },
            <span class="hljs-attr">removeEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                each(<span class="hljs-keyword">this</span>._events, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">args</span>) </span>{
                    removeEvent.apply(<span class="hljs-literal">null</span>, args);
                });
                <span class="hljs-keyword">this</span>._events = <span class="hljs-literal">undefined</span>;
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> scroller = <span class="hljs-keyword">this</span>.chart.scroller;
                <span class="hljs-keyword">this</span>.removeEvents();
                each([<span class="hljs-string">'track'</span>, <span class="hljs-string">'scrollbarRifles'</span>, <span class="hljs-string">'scrollbar'</span>, <span class="hljs-string">'scrollbarGroup'</span>, <span class="hljs-string">'group'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[prop] &amp;&amp; <span class="hljs-keyword">this</span>[prop].destroy) {
                        <span class="hljs-keyword">this</span>[prop] = <span class="hljs-keyword">this</span>[prop].destroy();
                    }
                }, <span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">if</span> (scroller) {
                    scroller.scrollbar = <span class="hljs-literal">null</span>;
                    destroyObjectProperties(scroller.scrollbarButtons);
                }
            }
        };
        wrap(Axis.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>;
            proceed.apply(axis, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (axis.options.scrollbar &amp;&amp; axis.options.scrollbar.enabled) {
                axis.options.scrollbar.vertical = !axis.horiz;
                axis.options.startOnTick = axis.options.endOnTick = <span class="hljs-literal">false</span>;
                axis.scrollbar = <span class="hljs-keyword">new</span> Scrollbar(axis.chart.renderer, axis.options.scrollbar, axis.chart);
                addEvent(axis.scrollbar, <span class="hljs-string">'changed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    <span class="hljs-keyword">var</span> unitedMin = <span class="hljs-built_in">Math</span>.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),
                        unitedMax = <span class="hljs-built_in">Math</span>.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),
                        range = unitedMax - unitedMin,
                        to,
                        <span class="hljs-keyword">from</span>;
                    <span class="hljs-keyword">if</span> ((axis.horiz &amp;&amp; !axis.reversed) || (!axis.horiz &amp;&amp; axis.reversed)) {
                        to = unitedMin + range * <span class="hljs-keyword">this</span>.to;
                        <span class="hljs-keyword">from</span> = unitedMin + range * <span class="hljs-keyword">this</span>.from;
                    } <span class="hljs-keyword">else</span> {
                        to = unitedMin + range * (<span class="hljs-number">1</span> - <span class="hljs-keyword">this</span>.from);
                        <span class="hljs-keyword">from</span> = unitedMin + range * (<span class="hljs-number">1</span> - <span class="hljs-keyword">this</span>.to);
                    }
                    axis.setExtremes(<span class="hljs-keyword">from</span>, to, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, e);
                });
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'render'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                scrollMin = <span class="hljs-built_in">Math</span>.min(pick(axis.options.min, axis.min), axis.min, axis.dataMin),
                scrollMax = <span class="hljs-built_in">Math</span>.max(pick(axis.options.max, axis.max), axis.max, axis.dataMax),
                scrollbar = axis.scrollbar,
                <span class="hljs-keyword">from</span>,
                to;
            proceed.apply(axis, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (scrollbar) {
                <span class="hljs-keyword">if</span> (axis.horiz) {
                    scrollbar.position(
                        axis.left,
                        axis.top + axis.height + axis.offset + <span class="hljs-number">2</span> + (axis.opposite ? <span class="hljs-number">0</span> : axis.axisTitleMargin),
                        axis.width,
                        axis.height
                    );
                } <span class="hljs-keyword">else</span> {
                    scrollbar.position(
                        axis.left + axis.width + <span class="hljs-number">2</span> + axis.offset + (axis.opposite ? axis.axisTitleMargin : <span class="hljs-number">0</span>),
                        axis.top,
                        axis.width,
                        axis.height
                    );
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(scrollMin) || <span class="hljs-built_in">isNaN</span>(scrollMax) || !defined(axis.min) || !defined(axis.max)) {
                    scrollbar.setRange(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">from</span> = (axis.min - scrollMin) / (scrollMax - scrollMin);
                    to = (axis.max - scrollMin) / (scrollMax - scrollMin);
                    <span class="hljs-keyword">if</span> ((axis.horiz &amp;&amp; !axis.reversed) || (!axis.horiz &amp;&amp; axis.reversed)) {
                        scrollbar.setRange(<span class="hljs-keyword">from</span>, to);
                    } <span class="hljs-keyword">else</span> {
                        scrollbar.setRange(<span class="hljs-number">1</span> - to, <span class="hljs-number">1</span> - <span class="hljs-keyword">from</span>);
                    }
                }
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'getOffset'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                index = axis.horiz ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>,
                scrollbar = axis.scrollbar;
            proceed.apply(axis, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (scrollbar) {
                axis.chart.axisOffset[index] += scrollbar.size + scrollbar.options.margin;
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'destroy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scrollbar) {
                <span class="hljs-keyword">this</span>.scrollbar = <span class="hljs-keyword">this</span>.scrollbar.destroy();
            }
            proceed.apply(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
        });
        H.Scrollbar = Scrollbar;
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            Axis = H.Axis,
            Chart = H.Chart,
            color = H.color,
            defaultDataGroupingUnits = H.defaultDataGroupingUnits,
            defaultOptions = H.defaultOptions,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            doc = H.doc,
            each = H.each,
            erase = H.erase,
            error = H.error,
            extend = H.extend,
            grep = H.grep,
            hasTouch = H.hasTouch,
            isNumber = H.isNumber,
            isObject = H.isObject,
            merge = H.merge,
            pick = H.pick,
            removeEvent = H.removeEvent,
            Scrollbar = H.Scrollbar,
            Series = H.Series,
            seriesTypes = H.seriesTypes,
            wrap = H.wrap,
            swapXY = H.swapXY,
            units = [].concat(defaultDataGroupingUnits),
            defaultSeriesType,
            numExt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">extreme</span>) </span>{
                <span class="hljs-keyword">var</span> numbers = grep(<span class="hljs-built_in">arguments</span>, isNumber);
                <span class="hljs-keyword">if</span> (numbers.length) {
                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>[extreme].apply(<span class="hljs-number">0</span>, numbers);
                }
            };
        units[<span class="hljs-number">4</span>] = [<span class="hljs-string">'day'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];
        units[<span class="hljs-number">5</span>] = [<span class="hljs-string">'week'</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]];
        defaultSeriesType = seriesTypes.areaspline === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">'line'</span> : <span class="hljs-string">'areaspline'</span>;
        extend(defaultOptions, {
            <span class="hljs-attr">navigator</span>: {
                <span class="hljs-attr">height</span>: <span class="hljs-number">40</span>,
                <span class="hljs-attr">margin</span>: <span class="hljs-number">25</span>,
                <span class="hljs-attr">maskInside</span>: <span class="hljs-literal">true</span>,
                <span class="hljs-attr">handles</span>: {
                    <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">'#f2f2f2'</span>,
                    <span class="hljs-attr">borderColor</span>: <span class="hljs-string">'#999999'</span>
                },
                <span class="hljs-attr">maskFill</span>: color(<span class="hljs-string">'#6685c2'</span>).setOpacity(<span class="hljs-number">0.3</span>).get(),
                <span class="hljs-attr">outlineColor</span>: <span class="hljs-string">'#cccccc'</span>,
                <span class="hljs-attr">outlineWidth</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">series</span>: {
                    <span class="hljs-attr">type</span>: defaultSeriesType,
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#335cad'</span>,
                    <span class="hljs-attr">fillOpacity</span>: <span class="hljs-number">0.05</span>,
                    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">compare</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">dataGrouping</span>: {
                        <span class="hljs-attr">approximation</span>: <span class="hljs-string">'average'</span>,
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">groupPixelWidth</span>: <span class="hljs-number">2</span>,
                        <span class="hljs-attr">smoothed</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">units</span>: units
                    },
                    <span class="hljs-attr">dataLabels</span>: {
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>
                    },
                    <span class="hljs-attr">id</span>: <span class="hljs-string">'highcharts-navigator-series'</span>,
                    <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-navigator-series'</span>,
                    <span class="hljs-attr">lineColor</span>: <span class="hljs-literal">null</span>,
                    <span class="hljs-attr">marker</span>: {
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>
                    },
                    <span class="hljs-attr">pointRange</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">threshold</span>: <span class="hljs-literal">null</span>
                },
                <span class="hljs-attr">xAxis</span>: {
                    <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-navigator-xaxis'</span>,
                    <span class="hljs-attr">tickLength</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">lineWidth</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">gridLineColor</span>: <span class="hljs-string">'#e6e6e6'</span>,
                    <span class="hljs-attr">gridLineWidth</span>: <span class="hljs-number">1</span>,
                    <span class="hljs-attr">tickPixelInterval</span>: <span class="hljs-number">200</span>,
                    <span class="hljs-attr">labels</span>: {
                        <span class="hljs-attr">align</span>: <span class="hljs-string">'left'</span>,
                        <span class="hljs-attr">style</span>: {
                            <span class="hljs-attr">color</span>: <span class="hljs-string">'#999999'</span>
                        },
                        <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
                        <span class="hljs-attr">y</span>: <span class="hljs-number">-4</span>
                    },
                    <span class="hljs-attr">crosshair</span>: <span class="hljs-literal">false</span>
                },
                <span class="hljs-attr">yAxis</span>: {
                    <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-navigator-yaxis'</span>,
                    <span class="hljs-attr">gridLineWidth</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">startOnTick</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">endOnTick</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">minPadding</span>: <span class="hljs-number">0.1</span>,
                    <span class="hljs-attr">maxPadding</span>: <span class="hljs-number">0.1</span>,
                    <span class="hljs-attr">labels</span>: {
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>
                    },
                    <span class="hljs-attr">crosshair</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">title</span>: {
                        <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span>
                    },
                    <span class="hljs-attr">tickLength</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">tickWidth</span>: <span class="hljs-number">0</span>
                }
            }
        });

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Navigator</span>(<span class="hljs-params">chart</span>) </span>{
            <span class="hljs-keyword">this</span>.init(chart);
        }
        Navigator.prototype = {
            <span class="hljs-attr">drawHandle</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x, index, inverted, verb</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>;
                navigator.handles[index][verb](inverted ? {
                    <span class="hljs-attr">translateX</span>: <span class="hljs-built_in">Math</span>.round(navigator.left + navigator.height / <span class="hljs-number">2</span> - <span class="hljs-number">8</span>),
                    <span class="hljs-attr">translateY</span>: <span class="hljs-built_in">Math</span>.round(navigator.top + <span class="hljs-built_in">parseInt</span>(x, <span class="hljs-number">10</span>) + <span class="hljs-number">0.5</span>)
                } : {
                    <span class="hljs-attr">translateX</span>: <span class="hljs-built_in">Math</span>.round(navigator.left + <span class="hljs-built_in">parseInt</span>(x, <span class="hljs-number">10</span>)),
                    <span class="hljs-attr">translateY</span>: <span class="hljs-built_in">Math</span>.round(navigator.top + navigator.height / <span class="hljs-number">2</span> - <span class="hljs-number">8</span>)
                });
            },
            <span class="hljs-attr">getHandlePath</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">inverted</span>) </span>{
                <span class="hljs-keyword">return</span> swapXY([
                    <span class="hljs-string">'M'</span>, <span class="hljs-number">-4.5</span>, <span class="hljs-number">0.5</span>,
                    <span class="hljs-string">'L'</span>,
                    <span class="hljs-number">3.5</span>, <span class="hljs-number">0.5</span>,
                    <span class="hljs-string">'L'</span>,
                    <span class="hljs-number">3.5</span>, <span class="hljs-number">15.5</span>,
                    <span class="hljs-string">'L'</span>, <span class="hljs-number">-4.5</span>, <span class="hljs-number">15.5</span>,
                    <span class="hljs-string">'L'</span>, <span class="hljs-number">-4.5</span>, <span class="hljs-number">0.5</span>,
                    <span class="hljs-string">'M'</span>, <span class="hljs-number">-1.5</span>, <span class="hljs-number">4</span>,
                    <span class="hljs-string">'L'</span>, <span class="hljs-number">-1.5</span>, <span class="hljs-number">12</span>,
                    <span class="hljs-string">'M'</span>,
                    <span class="hljs-number">0.5</span>, <span class="hljs-number">4</span>,
                    <span class="hljs-string">'L'</span>,
                    <span class="hljs-number">0.5</span>, <span class="hljs-number">12</span>
                ], inverted);
            },
            <span class="hljs-attr">drawOutline</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">zoomedMin, zoomedMax, inverted, verb</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    maskInside = navigator.navigatorOptions.maskInside,
                    outlineWidth = navigator.outline.strokeWidth(),
                    halfOutline = outlineWidth / <span class="hljs-number">2</span>,
                    outlineHeight = navigator.outlineHeight,
                    scrollbarHeight = navigator.scrollbarHeight,
                    navigatorSize = navigator.size,
                    left = navigator.left - scrollbarHeight,
                    navigatorTop = navigator.top,
                    verticalMin,
                    path;
                <span class="hljs-keyword">if</span> (inverted) {
                    left -= halfOutline;
                    verticalMin = navigatorTop + zoomedMax + halfOutline;
                    zoomedMax = navigatorTop + zoomedMin + halfOutline;
                    path = [
                        <span class="hljs-string">'M'</span>,
                        left + outlineHeight,
                        navigatorTop - scrollbarHeight - halfOutline,
                        <span class="hljs-string">'L'</span>,
                        left + outlineHeight,
                        verticalMin,
                        <span class="hljs-string">'L'</span>,
                        left,
                        verticalMin,
                        <span class="hljs-string">'L'</span>,
                        left,
                        zoomedMax,
                        <span class="hljs-string">'L'</span>,
                        left + outlineHeight,
                        zoomedMax,
                        <span class="hljs-string">'L'</span>,
                        left + outlineHeight,
                        navigatorTop + navigatorSize + scrollbarHeight
                    ].concat(maskInside ? [
                        <span class="hljs-string">'M'</span>,
                        left + outlineHeight,
                        verticalMin - halfOutline,
                        <span class="hljs-string">'L'</span>,
                        left + outlineHeight,
                        zoomedMax + halfOutline
                    ] : []);
                } <span class="hljs-keyword">else</span> {
                    zoomedMin += left + scrollbarHeight - halfOutline;
                    zoomedMax += left + scrollbarHeight - halfOutline;
                    navigatorTop += halfOutline;
                    path = [
                        <span class="hljs-string">'M'</span>,
                        left,
                        navigatorTop,
                        <span class="hljs-string">'L'</span>,
                        zoomedMin,
                        navigatorTop,
                        <span class="hljs-string">'L'</span>,
                        zoomedMin,
                        navigatorTop + outlineHeight,
                        <span class="hljs-string">'L'</span>,
                        zoomedMax,
                        navigatorTop + outlineHeight,
                        <span class="hljs-string">'L'</span>,
                        zoomedMax,
                        navigatorTop,
                        <span class="hljs-string">'L'</span>,
                        left + navigatorSize + scrollbarHeight * <span class="hljs-number">2</span>,
                        navigatorTop
                    ].concat(maskInside ? [
                        <span class="hljs-string">'M'</span>,
                        zoomedMin - halfOutline,
                        navigatorTop,
                        <span class="hljs-string">'L'</span>,
                        zoomedMax + halfOutline,
                        navigatorTop
                    ] : []);
                }
                navigator.outline[verb]({
                    <span class="hljs-attr">d</span>: path
                });
            },
            <span class="hljs-attr">drawMasks</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">zoomedMin, zoomedMax, inverted, verb</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    left = navigator.left,
                    top = navigator.top,
                    navigatorHeight = navigator.height,
                    height,
                    width,
                    x,
                    y;
                <span class="hljs-keyword">if</span> (inverted) {
                    x = [left, left, left];
                    y = [top, top + zoomedMin, top + zoomedMax];
                    width = [navigatorHeight, navigatorHeight, navigatorHeight];
                    height = [
                        zoomedMin,
                        zoomedMax - zoomedMin,
                        navigator.size - zoomedMax
                    ];
                } <span class="hljs-keyword">else</span> {
                    x = [left, left + zoomedMin, left + zoomedMax];
                    y = [top, top, top];
                    width = [
                        zoomedMin,
                        zoomedMax - zoomedMin,
                        navigator.size - zoomedMax
                    ];
                    height = [navigatorHeight, navigatorHeight, navigatorHeight];
                }
                each(navigator.shades, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">shade, i</span>) </span>{
                    shade[verb]({
                        <span class="hljs-attr">x</span>: x[i],
                        <span class="hljs-attr">y</span>: y[i],
                        <span class="hljs-attr">width</span>: width[i],
                        <span class="hljs-attr">height</span>: height[i]
                    });
                });
            },
            <span class="hljs-attr">renderElements</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    navigatorOptions = navigator.navigatorOptions,
                    maskInside = navigatorOptions.maskInside,
                    chart = navigator.chart,
                    inverted = chart.inverted,
                    renderer = chart.renderer,
                    navigatorGroup;
                navigator.navigatorGroup = navigatorGroup = renderer.g(<span class="hljs-string">'navigator'</span>)
                    .attr({
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">8</span>,
                        <span class="hljs-attr">visibility</span>: <span class="hljs-string">'hidden'</span>
                    })
                    .add();
                <span class="hljs-keyword">var</span> mouseCursor = {
                    <span class="hljs-attr">cursor</span>: inverted ? <span class="hljs-string">'ns-resize'</span> : <span class="hljs-string">'ew-resize'</span>
                };
                each([!maskInside, maskInside, !maskInside], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">hasMask, index</span>) </span>{
                    navigator.shades[index] = renderer.rect()
                        .addClass(<span class="hljs-string">'highcharts-navigator-mask'</span> +
                            (index === <span class="hljs-number">1</span> ? <span class="hljs-string">'-inside'</span> : <span class="hljs-string">'-outside'</span>))
                        .attr({
                            <span class="hljs-attr">fill</span>: hasMask ? navigatorOptions.maskFill : <span class="hljs-string">'transparent'</span>
                        })
                        .css(index === <span class="hljs-number">1</span> &amp;&amp; mouseCursor)
                        .add(navigatorGroup);
                });
                navigator.outline = renderer.path()
                    .addClass(<span class="hljs-string">'highcharts-navigator-outline'</span>)
                    .attr({
                        <span class="hljs-string">'stroke-width'</span>: navigatorOptions.outlineWidth,
                        <span class="hljs-attr">stroke</span>: navigatorOptions.outlineColor
                    })
                    .add(navigatorGroup);
                each([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
                    navigator.handles[index] = renderer
                        .path(navigator.getHandlePath(inverted))
                        .attr({
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">7</span> - index
                        })
                        .addClass(
                            <span class="hljs-string">'highcharts-navigator-handle highcharts-navigator-handle-'</span> + [<span class="hljs-string">'left'</span>, <span class="hljs-string">'right'</span>][index]
                        ).add(navigatorGroup);
                    <span class="hljs-keyword">var</span> handlesOptions = navigatorOptions.handles;
                    navigator.handles[index]
                        .attr({
                            <span class="hljs-attr">fill</span>: handlesOptions.backgroundColor,
                            <span class="hljs-attr">stroke</span>: handlesOptions.borderColor,
                            <span class="hljs-string">'stroke-width'</span>: <span class="hljs-number">1</span>
                        })
                        .css(mouseCursor);
                });
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">this</span>.destroy();
                <span class="hljs-keyword">var</span> chartOptions = <span class="hljs-keyword">this</span>.chart.options;
                merge(<span class="hljs-literal">true</span>, chartOptions.navigator, <span class="hljs-keyword">this</span>.options, options);
                <span class="hljs-keyword">this</span>.init(<span class="hljs-keyword">this</span>.chart);
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">min, max, pxMin, pxMax</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    navigatorWidth,
                    scrollbarLeft,
                    scrollbarTop,
                    scrollbarHeight = navigator.scrollbarHeight,
                    navigatorSize,
                    xAxis = navigator.xAxis,
                    navigatorEnabled = navigator.navigatorEnabled,
                    zoomedMin,
                    zoomedMax,
                    rendered = navigator.rendered,
                    inverted = chart.inverted,
                    verb,
                    newMin,
                    newMax,
                    minRange = chart.xAxis[<span class="hljs-number">0</span>].minRange;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasDragged &amp;&amp; !defined(pxMin)) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (!isNumber(min) || !isNumber(max)) {
                    <span class="hljs-keyword">if</span> (rendered) {
                        pxMin = <span class="hljs-number">0</span>;
                        pxMax = xAxis.width;
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span>;
                    }
                }
                navigator.left = pick(
                    xAxis.left,
                    chart.plotLeft + scrollbarHeight
                );
                <span class="hljs-keyword">if</span> (inverted) {
                    navigator.size = zoomedMax = navigatorSize = pick(
                        xAxis.len,
                        chart.plotHeight - <span class="hljs-number">2</span> * scrollbarHeight
                    );
                    navigatorWidth = scrollbarHeight;
                } <span class="hljs-keyword">else</span> {
                    navigator.size = zoomedMax = navigatorSize = pick(
                        xAxis.len,
                        chart.plotWidth - <span class="hljs-number">2</span> * scrollbarHeight
                    );
                    navigatorWidth = navigatorSize + <span class="hljs-number">2</span> * scrollbarHeight;
                }
                pxMin = pick(pxMin, xAxis.toPixels(min, <span class="hljs-literal">true</span>));
                pxMax = pick(pxMax, xAxis.toPixels(max, <span class="hljs-literal">true</span>));
                <span class="hljs-keyword">if</span> (!isNumber(pxMin) || <span class="hljs-built_in">Math</span>.abs(pxMin) === <span class="hljs-literal">Infinity</span>) {
                    pxMin = <span class="hljs-number">0</span>;
                    pxMax = navigatorWidth;
                }
                newMin = xAxis.toValue(pxMin, <span class="hljs-literal">true</span>);
                newMax = xAxis.toValue(pxMax, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(newMax - newMin) &lt; minRange) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.grabbedLeft) {
                        pxMin = xAxis.toPixels(newMax - minRange, <span class="hljs-literal">true</span>);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.grabbedRight) {
                        pxMax = xAxis.toPixels(newMin + minRange, <span class="hljs-literal">true</span>);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-keyword">return</span>;
                    }
                }
                navigator.zoomedMax = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(pxMin, pxMax, <span class="hljs-number">0</span>), zoomedMax);
                navigator.zoomedMin = <span class="hljs-built_in">Math</span>.min(
                    <span class="hljs-built_in">Math</span>.max(
                        navigator.fixedWidth ?
                        navigator.zoomedMax - navigator.fixedWidth :
                        <span class="hljs-built_in">Math</span>.min(pxMin, pxMax),
                        <span class="hljs-number">0</span>
                    ),
                    zoomedMax
                );
                navigator.range = navigator.zoomedMax - navigator.zoomedMin;
                zoomedMax = <span class="hljs-built_in">Math</span>.round(navigator.zoomedMax);
                zoomedMin = <span class="hljs-built_in">Math</span>.round(navigator.zoomedMin);
                <span class="hljs-keyword">if</span> (navigatorEnabled) {
                    navigator.navigatorGroup.attr({
                        <span class="hljs-attr">visibility</span>: <span class="hljs-string">'visible'</span>
                    });
                    verb = rendered &amp;&amp; !navigator.hasDragged ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>;
                    navigator.drawMasks(zoomedMin, zoomedMax, inverted, verb);
                    navigator.drawOutline(zoomedMin, zoomedMax, inverted, verb);
                    navigator.drawHandle(zoomedMin, <span class="hljs-number">0</span>, inverted, verb);
                    navigator.drawHandle(zoomedMax, <span class="hljs-number">1</span>, inverted, verb);
                }
                <span class="hljs-keyword">if</span> (navigator.scrollbar) {
                    <span class="hljs-keyword">if</span> (inverted) {
                        scrollbarTop = navigator.top - scrollbarHeight;
                        scrollbarLeft = navigator.left - scrollbarHeight +
                            (navigatorEnabled ? <span class="hljs-number">0</span> : navigator.height);
                        scrollbarHeight = navigatorSize + <span class="hljs-number">2</span> * scrollbarHeight;
                    } <span class="hljs-keyword">else</span> {
                        scrollbarTop = navigator.top +
                            (navigatorEnabled ? navigator.height : -scrollbarHeight);
                        scrollbarLeft = navigator.left - scrollbarHeight;
                    }
                    navigator.scrollbar.position(
                        scrollbarLeft,
                        scrollbarTop,
                        navigatorWidth,
                        scrollbarHeight
                    );
                    navigator.scrollbar.setRange(
                        zoomedMin / navigatorSize,
                        zoomedMax / navigatorSize
                    );
                }
                navigator.rendered = <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">addMouseEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    container = chart.container,
                    eventsToUnbind = [],
                    mouseMoveHandler,
                    mouseUpHandler;
                navigator.mouseMoveHandler = mouseMoveHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    navigator.onMouseMove(e);
                };
                navigator.mouseUpHandler = mouseUpHandler = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                    navigator.onMouseUp(e);
                };
                eventsToUnbind = navigator.getPartsEvents(<span class="hljs-string">'mousedown'</span>);
                eventsToUnbind.push(
                    addEvent(container, <span class="hljs-string">'mousemove'</span>, mouseMoveHandler),
                    addEvent(doc, <span class="hljs-string">'mouseup'</span>, mouseUpHandler)
                );
                <span class="hljs-keyword">if</span> (hasTouch) {
                    eventsToUnbind.push(
                        addEvent(container, <span class="hljs-string">'touchmove'</span>, mouseMoveHandler),
                        addEvent(doc, <span class="hljs-string">'touchend'</span>, mouseUpHandler)
                    );
                    eventsToUnbind.concat(navigator.getPartsEvents(<span class="hljs-string">'touchstart'</span>));
                }
                navigator.eventsToUnbind = eventsToUnbind;
                <span class="hljs-keyword">if</span> (navigator.series &amp;&amp; navigator.series[<span class="hljs-number">0</span>]) {
                    eventsToUnbind.push(
                        addEvent(navigator.series[<span class="hljs-number">0</span>].xAxis, <span class="hljs-string">'foundExtremes'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            chart.navigator.modifyNavigatorAxisExtremes();
                        })
                    );
                }
            },
            <span class="hljs-attr">getPartsEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    events = [];
                each([<span class="hljs-string">'shades'</span>, <span class="hljs-string">'handles'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                    each(navigator[name], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">navigatorItem, index</span>) </span>{
                        events.push(
                            addEvent(
                                navigatorItem.element,
                                eventName,
                                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                                    navigator[name + <span class="hljs-string">'Mousedown'</span>](e, index);
                                }
                            )
                        );
                    });
                });
                <span class="hljs-keyword">return</span> events;
            },
            <span class="hljs-attr">shadesMousedown</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, index</span>) </span>{
                e = <span class="hljs-keyword">this</span>.chart.pointer.normalize(e);
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    xAxis = navigator.xAxis,
                    zoomedMin = navigator.zoomedMin,
                    navigatorPosition = navigator.left,
                    navigatorSize = navigator.size,
                    range = navigator.range,
                    chartX = e.chartX,
                    fixedMax,
                    ext,
                    left;
                <span class="hljs-keyword">if</span> (chart.inverted) {
                    chartX = e.chartY;
                    navigatorPosition = navigator.top;
                }
                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">1</span>) {
                    navigator.grabbedCenter = chartX;
                    navigator.fixedWidth = range;
                    navigator.dragOffset = chartX - zoomedMin;
                } <span class="hljs-keyword">else</span> {
                    left = chartX - navigatorPosition - range / <span class="hljs-number">2</span>;
                    <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
                        left = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, left);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (index === <span class="hljs-number">2</span> &amp;&amp; left + range &gt;= navigatorSize) {
                        left = navigatorSize - range;
                        fixedMax = navigator.getUnionExtremes().dataMax;
                    }
                    <span class="hljs-keyword">if</span> (left !== zoomedMin) {
                        navigator.fixedWidth = range;
                        ext = xAxis.toFixedRange(left, left + range, <span class="hljs-literal">null</span>, fixedMax);
                        chart.xAxis[<span class="hljs-number">0</span>].setExtremes(
                            <span class="hljs-built_in">Math</span>.min(ext.min, ext.max),
                            <span class="hljs-built_in">Math</span>.max(ext.min, ext.max),
                            <span class="hljs-literal">true</span>,
                            <span class="hljs-literal">null</span>, {
                                <span class="hljs-attr">trigger</span>: <span class="hljs-string">'navigator'</span>
                            }
                        );
                    }
                }
            },
            <span class="hljs-attr">handlesMousedown</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e, index</span>) </span>{
                e = <span class="hljs-keyword">this</span>.chart.pointer.normalize(e);
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    baseXAxis = chart.xAxis[<span class="hljs-number">0</span>],
                    reverse = (chart.inverted &amp;&amp; !baseXAxis.reversed) ||
                    (!chart.inverted &amp;&amp; baseXAxis.reversed);
                <span class="hljs-keyword">if</span> (index === <span class="hljs-number">0</span>) {
                    navigator.grabbedLeft = <span class="hljs-literal">true</span>;
                    navigator.otherHandlePos = navigator.zoomedMax;
                    navigator.fixedExtreme = reverse ? baseXAxis.min : baseXAxis.max;
                } <span class="hljs-keyword">else</span> {
                    navigator.grabbedRight = <span class="hljs-literal">true</span>;
                    navigator.otherHandlePos = navigator.zoomedMin;
                    navigator.fixedExtreme = reverse ? baseXAxis.max : baseXAxis.min;
                }
                chart.fixedRange = <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">onMouseMove</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    left = navigator.left,
                    navigatorSize = navigator.navigatorSize,
                    range = navigator.range,
                    dragOffset = navigator.dragOffset,
                    inverted = chart.inverted,
                    chartX;
                <span class="hljs-keyword">if</span> (!e.touches || e.touches[<span class="hljs-number">0</span>].pageX !== <span class="hljs-number">0</span>) {
                    e = chart.pointer.normalize(e);
                    chartX = e.chartX;
                    <span class="hljs-keyword">if</span> (inverted) {
                        left = navigator.top;
                        chartX = e.chartY;
                    }
                    <span class="hljs-keyword">if</span> (navigator.grabbedLeft) {
                        navigator.hasDragged = <span class="hljs-literal">true</span>;
                        navigator.render(
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            chartX - left,
                            navigator.otherHandlePos
                        );
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator.grabbedRight) {
                        navigator.hasDragged = <span class="hljs-literal">true</span>;
                        navigator.render(
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            navigator.otherHandlePos,
                            chartX - left
                        );
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator.grabbedCenter) {
                        navigator.hasDragged = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">if</span> (chartX &lt; dragOffset) {
                            chartX = dragOffset;
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chartX &gt; navigatorSize + dragOffset - range) {
                            chartX = navigatorSize + dragOffset - range;
                        }
                        navigator.render(
                            <span class="hljs-number">0</span>,
                            <span class="hljs-number">0</span>,
                            chartX - dragOffset,
                            chartX - dragOffset + range
                        );
                    }
                    <span class="hljs-keyword">if</span> (navigator.hasDragged &amp;&amp; navigator.scrollbar &amp;&amp; navigator.scrollbar.options.liveRedraw) {
                        e.DOMType = e.type;
                        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            navigator.onMouseUp(e);
                        }, <span class="hljs-number">0</span>);
                    }
                }
            },
            <span class="hljs-attr">onMouseUp</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    xAxis = navigator.xAxis,
                    fixedMin,
                    fixedMax,
                    ext,
                    DOMEvent = e.DOMEvent || e;
                <span class="hljs-keyword">if</span> (navigator.hasDragged || e.trigger === <span class="hljs-string">'scrollbar'</span>) {
                    <span class="hljs-keyword">if</span> (navigator.zoomedMin === navigator.otherHandlePos) {
                        fixedMin = navigator.fixedExtreme;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (navigator.zoomedMax === navigator.otherHandlePos) {
                        fixedMax = navigator.fixedExtreme;
                    }
                    <span class="hljs-keyword">if</span> (navigator.zoomedMax === navigator.navigatorSize) {
                        fixedMax = navigator.getUnionExtremes().dataMax;
                    }
                    ext = xAxis.toFixedRange(
                        navigator.zoomedMin,
                        navigator.zoomedMax,
                        fixedMin,
                        fixedMax
                    );
                    <span class="hljs-keyword">if</span> (defined(ext.min)) {
                        chart.xAxis[<span class="hljs-number">0</span>].setExtremes(
                            <span class="hljs-built_in">Math</span>.min(ext.min, ext.max),
                            <span class="hljs-built_in">Math</span>.max(ext.min, ext.max),
                            <span class="hljs-literal">true</span>,
                            navigator.hasDragged ? <span class="hljs-literal">false</span> : <span class="hljs-literal">null</span>, {
                                <span class="hljs-attr">trigger</span>: <span class="hljs-string">'navigator'</span>,
                                <span class="hljs-attr">triggerOp</span>: <span class="hljs-string">'navigator-drag'</span>,
                                <span class="hljs-attr">DOMEvent</span>: DOMEvent
                            }
                        );
                    }
                }
                <span class="hljs-keyword">if</span> (e.DOMType !== <span class="hljs-string">'mousemove'</span>) {
                    navigator.grabbedLeft = navigator.grabbedRight =
                        navigator.grabbedCenter = navigator.fixedWidth =
                        navigator.fixedExtreme = navigator.otherHandlePos =
                        navigator.hasDragged = navigator.dragOffset = <span class="hljs-literal">null</span>;
                }
            },
            <span class="hljs-attr">removeEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventsToUnbind) {
                    each(<span class="hljs-keyword">this</span>.eventsToUnbind, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">unbind</span>) </span>{
                        unbind();
                    });
                    <span class="hljs-keyword">this</span>.eventsToUnbind = <span class="hljs-literal">undefined</span>;
                }
                <span class="hljs-keyword">this</span>.removeBaseSeriesEvents();
            },
            <span class="hljs-attr">removeBaseSeriesEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> baseSeries = <span class="hljs-keyword">this</span>.baseSeries || [];
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.navigatorEnabled &amp;&amp; baseSeries[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">this</span>.navigatorOptions.adaptToUpdatedData !== <span class="hljs-literal">false</span>) {
                    each(baseSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                        removeEvent(series, <span class="hljs-string">'updatedData'</span>, <span class="hljs-keyword">this</span>.updatedDataHandler);
                    }, <span class="hljs-keyword">this</span>);
                    <span class="hljs-keyword">if</span> (baseSeries[<span class="hljs-number">0</span>].xAxis) {
                        removeEvent(baseSeries[<span class="hljs-number">0</span>].xAxis, <span class="hljs-string">'foundExtremes'</span>, <span class="hljs-keyword">this</span>.modifyBaseAxisExtremes);
                    }
                }
            },
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart</span>) </span>{
                <span class="hljs-keyword">var</span> chartOptions = chart.options,
                    navigatorOptions = chartOptions.navigator,
                    navigatorEnabled = navigatorOptions.enabled,
                    scrollbarOptions = chartOptions.scrollbar,
                    scrollbarEnabled = scrollbarOptions.enabled,
                    height = navigatorEnabled ? navigatorOptions.height : <span class="hljs-number">0</span>,
                    scrollbarHeight = scrollbarEnabled ? scrollbarOptions.height : <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>.handles = [];
                <span class="hljs-keyword">this</span>.shades = [];
                <span class="hljs-keyword">this</span>.chart = chart;
                <span class="hljs-keyword">this</span>.setBaseSeries();
                <span class="hljs-keyword">this</span>.height = height;
                <span class="hljs-keyword">this</span>.scrollbarHeight = scrollbarHeight;
                <span class="hljs-keyword">this</span>.scrollbarEnabled = scrollbarEnabled;
                <span class="hljs-keyword">this</span>.navigatorEnabled = navigatorEnabled;
                <span class="hljs-keyword">this</span>.navigatorOptions = navigatorOptions;
                <span class="hljs-keyword">this</span>.scrollbarOptions = scrollbarOptions;
                <span class="hljs-keyword">this</span>.outlineHeight = height + scrollbarHeight;
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    baseSeries = navigator.baseSeries,
                    xAxisIndex = chart.xAxis.length,
                    yAxisIndex = chart.yAxis.length,
                    baseXaxis = baseSeries &amp;&amp; baseSeries[<span class="hljs-number">0</span>] &amp;&amp; baseSeries[<span class="hljs-number">0</span>].xAxis || chart.xAxis[<span class="hljs-number">0</span>];
                chart.extraMargin = {
                    <span class="hljs-attr">type</span>: navigatorOptions.opposite ? <span class="hljs-string">'plotTop'</span> : <span class="hljs-string">'marginBottom'</span>,
                    <span class="hljs-attr">value</span>: navigator.outlineHeight + navigatorOptions.margin
                };
                <span class="hljs-keyword">if</span> (chart.inverted) {
                    chart.extraMargin.type = navigatorOptions.opposite ? <span class="hljs-string">'marginRight'</span> : <span class="hljs-string">'plotLeft'</span>;
                }
                chart.isDirtyBox = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span> (navigator.navigatorEnabled) {
                    navigator.xAxis = <span class="hljs-keyword">new</span> Axis(chart, merge({
                        <span class="hljs-attr">breaks</span>: baseXaxis.options.breaks,
                        <span class="hljs-attr">ordinal</span>: baseXaxis.options.ordinal
                    }, navigatorOptions.xAxis, {
                        <span class="hljs-attr">id</span>: <span class="hljs-string">'navigator-x-axis'</span>,
                        <span class="hljs-attr">yAxis</span>: <span class="hljs-string">'navigator-y-axis'</span>,
                        <span class="hljs-attr">isX</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">type</span>: <span class="hljs-string">'datetime'</span>,
                        <span class="hljs-attr">index</span>: xAxisIndex,
                        <span class="hljs-attr">offset</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">keepOrdinalPadding</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">startOnTick</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">endOnTick</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">minPadding</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">maxPadding</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">zoomEnabled</span>: <span class="hljs-literal">false</span>
                    }, chart.inverted ? {
                        <span class="hljs-attr">offsets</span>: [scrollbarHeight, <span class="hljs-number">0</span>, -scrollbarHeight, <span class="hljs-number">0</span>],
                        <span class="hljs-attr">width</span>: height
                    } : {
                        <span class="hljs-attr">offsets</span>: [<span class="hljs-number">0</span>, -scrollbarHeight, <span class="hljs-number">0</span>, scrollbarHeight],
                        <span class="hljs-attr">height</span>: height
                    }));
                    navigator.yAxis = <span class="hljs-keyword">new</span> Axis(chart, merge(navigatorOptions.yAxis, {
                        <span class="hljs-attr">id</span>: <span class="hljs-string">'navigator-y-axis'</span>,
                        <span class="hljs-attr">alignTicks</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">offset</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">index</span>: yAxisIndex,
                        <span class="hljs-attr">zoomEnabled</span>: <span class="hljs-literal">false</span>
                    }, chart.inverted ? {
                        <span class="hljs-attr">width</span>: height
                    } : {
                        <span class="hljs-attr">height</span>: height
                    }));
                    <span class="hljs-keyword">if</span> (baseSeries || navigatorOptions.series.data) {
                        navigator.addBaseSeries();
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (chart.series.length === <span class="hljs-number">0</span>) {
                        wrap(chart, <span class="hljs-string">'redraw'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, animation</span>) </span>{
                            <span class="hljs-keyword">if</span> (chart.series.length &gt; <span class="hljs-number">0</span> &amp;&amp; !navigator.series) {
                                navigator.setBaseSeries();
                                chart.redraw = proceed;
                            }
                            proceed.call(chart, animation);
                        });
                    }
                    navigator.renderElements();
                    navigator.addMouseEvents();
                } <span class="hljs-keyword">else</span> {
                    navigator.xAxis = {
                        <span class="hljs-attr">translate</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, reverse</span>) </span>{
                            <span class="hljs-keyword">var</span> axis = chart.xAxis[<span class="hljs-number">0</span>],
                                ext = axis.getExtremes(),
                                scrollTrackWidth = chart.plotWidth - <span class="hljs-number">2</span> * scrollbarHeight,
                                min = numExt(<span class="hljs-string">'min'</span>, axis.options.min, ext.dataMin),
                                valueRange = numExt(<span class="hljs-string">'max'</span>, axis.options.max, ext.dataMax) - min;
                            <span class="hljs-keyword">return</span> reverse ?
                                (value * valueRange / scrollTrackWidth) + min :
                                scrollTrackWidth * (value - min) / valueRange;
                        },
                        <span class="hljs-attr">toPixels</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.translate(value);
                        },
                        <span class="hljs-attr">toValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
                            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.translate(value, <span class="hljs-literal">true</span>);
                        },
                        <span class="hljs-attr">toFixedRange</span>: Axis.prototype.toFixedRange,
                        <span class="hljs-attr">fake</span>: <span class="hljs-literal">true</span>
                    };
                }
                <span class="hljs-keyword">if</span> (chart.options.scrollbar.enabled) {
                    chart.scrollbar = navigator.scrollbar = <span class="hljs-keyword">new</span> Scrollbar(
                        chart.renderer,
                        merge(chart.options.scrollbar, {
                            <span class="hljs-attr">margin</span>: navigator.navigatorEnabled ? <span class="hljs-number">0</span> : <span class="hljs-number">10</span>,
                            <span class="hljs-attr">vertical</span>: chart.inverted
                        }),
                        chart
                    );
                    addEvent(navigator.scrollbar, <span class="hljs-string">'changed'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">var</span> range = navigator.size,
                            to = range * <span class="hljs-keyword">this</span>.to,
                            <span class="hljs-keyword">from</span> = range * <span class="hljs-keyword">this</span>.from;
                        navigator.hasDragged = navigator.scrollbar.hasDragged;
                        navigator.render(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">from</span>, to);
                        <span class="hljs-keyword">if</span> (chart.options.scrollbar.liveRedraw || e.DOMType !== <span class="hljs-string">'mousemove'</span>) {
                            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                navigator.onMouseUp(e);
                            });
                        }
                    });
                }
                navigator.addBaseSeriesEvents();
                navigator.addChartEvents();
            },
            <span class="hljs-attr">getUnionExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">returnFalseOnNoBaseSeries</span>) </span>{
                <span class="hljs-keyword">var</span> baseAxis = <span class="hljs-keyword">this</span>.chart.xAxis[<span class="hljs-number">0</span>],
                    navAxis = <span class="hljs-keyword">this</span>.xAxis,
                    navAxisOptions = navAxis.options,
                    baseAxisOptions = baseAxis.options,
                    ret;
                <span class="hljs-keyword">if</span> (!returnFalseOnNoBaseSeries || baseAxis.dataMin !== <span class="hljs-literal">null</span>) {
                    ret = {
                        <span class="hljs-attr">dataMin</span>: pick(
                            navAxisOptions &amp;&amp; navAxisOptions.min,
                            numExt(
                                <span class="hljs-string">'min'</span>,
                                baseAxisOptions.min,
                                baseAxis.dataMin,
                                navAxis.dataMin,
                                navAxis.min
                            )
                        ),
                        <span class="hljs-attr">dataMax</span>: pick(
                            navAxisOptions &amp;&amp; navAxisOptions.max,
                            numExt(
                                <span class="hljs-string">'max'</span>,
                                baseAxisOptions.max,
                                baseAxis.dataMax,
                                navAxis.dataMax,
                                navAxis.max
                            )
                        )
                    };
                }
                <span class="hljs-keyword">return</span> ret;
            },
            <span class="hljs-attr">setBaseSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">baseSeriesOptions</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    baseSeries = <span class="hljs-keyword">this</span>.baseSeries = [];
                baseSeriesOptions = baseSeriesOptions || chart.options &amp;&amp; chart.options.navigator.baseSeries || <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.series) {
                    <span class="hljs-keyword">this</span>.removeBaseSeriesEvents();
                    each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                        s.destroy();
                    });
                }
                each(chart.series || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series, i</span>) </span>{
                    <span class="hljs-keyword">if</span> (series.options.showInNavigator || (i === baseSeriesOptions || series.options.id === baseSeriesOptions) &amp;&amp;
                        series.options.showInNavigator !== <span class="hljs-literal">false</span>) {
                        baseSeries.push(series);
                    }
                });
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.xAxis &amp;&amp; !<span class="hljs-keyword">this</span>.xAxis.fake) {
                    <span class="hljs-keyword">this</span>.addBaseSeries();
                }
            },
            <span class="hljs-attr">addBaseSeries</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    chart = navigator.chart,
                    navigatorSeries = navigator.series = [],
                    baseSeries = navigator.baseSeries,
                    baseOptions,
                    mergedNavSeriesOptions,
                    chartNavigatorOptions = navigator.navigatorOptions.series,
                    baseNavigatorOptions,
                    navSeriesMixin = {
                        <span class="hljs-attr">enableMouseTracking</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">index</span>: <span class="hljs-literal">null</span>,
                        <span class="hljs-attr">group</span>: <span class="hljs-string">'nav'</span>,
                        <span class="hljs-attr">padXAxis</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">xAxis</span>: <span class="hljs-string">'navigator-x-axis'</span>,
                        <span class="hljs-attr">yAxis</span>: <span class="hljs-string">'navigator-y-axis'</span>,
                        <span class="hljs-attr">showInLegend</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">stacking</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">isInternal</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">visible</span>: <span class="hljs-literal">true</span>
                    };
                <span class="hljs-keyword">if</span> (baseSeries) {
                    each(baseSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base, i</span>) </span>{
                        navSeriesMixin.name = <span class="hljs-string">'Navigator '</span> + (i + <span class="hljs-number">1</span>);
                        baseOptions = base.options || {};
                        baseNavigatorOptions = baseOptions.navigatorOptions || {};
                        mergedNavSeriesOptions = merge(baseOptions, navSeriesMixin, chartNavigatorOptions, baseNavigatorOptions);
                        <span class="hljs-keyword">var</span> navigatorSeriesData = baseNavigatorOptions.data || chartNavigatorOptions.data;
                        navigator.hasNavigatorData = navigator.hasNavigatorData || !!navigatorSeriesData;
                        mergedNavSeriesOptions.data = navigatorSeriesData || baseOptions.data &amp;&amp; baseOptions.data.slice(<span class="hljs-number">0</span>);
                        base.navigatorSeries = chart.initSeries(mergedNavSeriesOptions);
                        navigatorSeries.push(base.navigatorSeries);
                    });
                } <span class="hljs-keyword">else</span> {
                    mergedNavSeriesOptions = merge(chartNavigatorOptions, navSeriesMixin);
                    mergedNavSeriesOptions.data = chartNavigatorOptions.data;
                    navigator.hasNavigatorData = !!mergedNavSeriesOptions.data;
                    navigatorSeries.push(chart.initSeries(mergedNavSeriesOptions));
                }
                <span class="hljs-keyword">this</span>.addBaseSeriesEvents();
            },
            <span class="hljs-attr">addBaseSeriesEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>,
                    baseSeries = navigator.baseSeries || [];
                <span class="hljs-keyword">if</span> (baseSeries[<span class="hljs-number">0</span>] &amp;&amp; baseSeries[<span class="hljs-number">0</span>].xAxis) {
                    addEvent(baseSeries[<span class="hljs-number">0</span>].xAxis, <span class="hljs-string">'foundExtremes'</span>, <span class="hljs-keyword">this</span>.modifyBaseAxisExtremes);
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.navigatorOptions.adaptToUpdatedData !== <span class="hljs-literal">false</span>) {
                    each(baseSeries, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base</span>) </span>{
                        <span class="hljs-keyword">if</span> (base.xAxis) {
                            addEvent(base, <span class="hljs-string">'updatedData'</span>, <span class="hljs-keyword">this</span>.updatedDataHandler);
                            base.userOptions.events = extend(base.userOptions.event, {
                                <span class="hljs-attr">updatedData</span>: <span class="hljs-keyword">this</span>.updatedDataHandler
                            });
                        }
                        addEvent(base, <span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.navigatorSeries) {
                                erase(navigator.series, <span class="hljs-keyword">this</span>.navigatorSeries);
                                <span class="hljs-keyword">this</span>.navigatorSeries.remove();
                                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.navigatorSeries;
                            }
                        });
                    }, <span class="hljs-keyword">this</span>);
                }
            },
            <span class="hljs-attr">modifyNavigatorAxisExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> xAxis = <span class="hljs-keyword">this</span>.xAxis,
                    unionExtremes;
                <span class="hljs-keyword">if</span> (xAxis.getExtremes) {
                    unionExtremes = <span class="hljs-keyword">this</span>.getUnionExtremes(<span class="hljs-literal">true</span>);
                    <span class="hljs-keyword">if</span> (unionExtremes &amp;&amp; (unionExtremes.dataMin !== xAxis.min || unionExtremes.dataMax !== xAxis.max)) {
                        xAxis.min = unionExtremes.dataMin;
                        xAxis.max = unionExtremes.dataMax;
                    }
                }
            },
            <span class="hljs-attr">modifyBaseAxisExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> baseXAxis = <span class="hljs-keyword">this</span>,
                    navigator = baseXAxis.chart.navigator,
                    baseExtremes = baseXAxis.getExtremes(),
                    baseMin = baseExtremes.min,
                    baseMax = baseExtremes.max,
                    baseDataMin = baseExtremes.dataMin,
                    baseDataMax = baseExtremes.dataMax,
                    range = baseMax - baseMin,
                    stickToMin = navigator.stickToMin,
                    stickToMax = navigator.stickToMax,
                    newMax,
                    newMin,
                    navigatorSeries = navigator.series &amp;&amp; navigator.series[<span class="hljs-number">0</span>],
                    hasSetExtremes = !!baseXAxis.setExtremes,
                    unmutable = baseXAxis.eventArgs &amp;&amp; baseXAxis.eventArgs.trigger === <span class="hljs-string">'rangeSelectorButton'</span>;
                <span class="hljs-keyword">if</span> (!unmutable) {
                    <span class="hljs-keyword">if</span> (stickToMin) {
                        newMin = baseDataMin;
                        newMax = newMin + range;
                    }
                    <span class="hljs-keyword">if</span> (stickToMax) {
                        newMax = baseDataMax;
                        <span class="hljs-keyword">if</span> (!stickToMin) {
                            newMin = <span class="hljs-built_in">Math</span>.max(
                                newMax - range,
                                navigatorSeries &amp;&amp; navigatorSeries.xData ?
                                navigatorSeries.xData[<span class="hljs-number">0</span>] : -<span class="hljs-built_in">Number</span>.MAX_VALUE
                            );
                        }
                    }
                    <span class="hljs-keyword">if</span> (hasSetExtremes &amp;&amp; (stickToMin || stickToMax)) {
                        <span class="hljs-keyword">if</span> (isNumber(newMin)) {
                            baseXAxis.min = baseXAxis.userMin = newMin;
                            baseXAxis.max = baseXAxis.userMax = newMax;
                        }
                    }
                }
                navigator.stickToMin = navigator.stickToMax = <span class="hljs-literal">null</span>;
            },
            <span class="hljs-attr">updatedDataHandler</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>.chart.navigator,
                    baseSeries = <span class="hljs-keyword">this</span>,
                    navigatorSeries = <span class="hljs-keyword">this</span>.navigatorSeries;
                navigator.stickToMin = isNumber(baseSeries.xAxis.min) &amp;&amp; (baseSeries.xAxis.min &lt;= baseSeries.xData[<span class="hljs-number">0</span>]);
                navigator.stickToMax = <span class="hljs-built_in">Math</span>.round(navigator.zoomedMax) &gt;= <span class="hljs-built_in">Math</span>.round(navigator.size);
                <span class="hljs-keyword">if</span> (navigatorSeries &amp;&amp; !navigator.hasNavigatorData) {
                    navigatorSeries.options.pointStart = baseSeries.xData[<span class="hljs-number">0</span>];
                    navigatorSeries.setData(baseSeries.options.data, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);
                }
            },
            <span class="hljs-attr">addChartEvents</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                addEvent(<span class="hljs-keyword">this</span>.chart, <span class="hljs-string">'redraw'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> navigator = <span class="hljs-keyword">this</span>.navigator,
                        xAxis = navigator &amp;&amp; (
                            navigator.baseSeries &amp;&amp;
                            navigator.baseSeries[<span class="hljs-number">0</span>] &amp;&amp;
                            navigator.baseSeries[<span class="hljs-number">0</span>].xAxis ||
                            navigator.scrollbar &amp;&amp; <span class="hljs-keyword">this</span>.xAxis[<span class="hljs-number">0</span>]
                        );
                    <span class="hljs-keyword">if</span> (xAxis) {
                        navigator.render(xAxis.min, xAxis.max);
                    }
                });
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.removeEvents();
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.xAxis) {
                    erase(<span class="hljs-keyword">this</span>.chart.xAxis, <span class="hljs-keyword">this</span>.xAxis);
                    erase(<span class="hljs-keyword">this</span>.chart.axes, <span class="hljs-keyword">this</span>.xAxis);
                }
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.yAxis) {
                    erase(<span class="hljs-keyword">this</span>.chart.yAxis, <span class="hljs-keyword">this</span>.yAxis);
                    erase(<span class="hljs-keyword">this</span>.chart.axes, <span class="hljs-keyword">this</span>.yAxis);
                }
                each(<span class="hljs-keyword">this</span>.series || [], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                    <span class="hljs-keyword">if</span> (s.destroy) {
                        s.destroy();
                    }
                });
                each([
                    <span class="hljs-string">'series'</span>, <span class="hljs-string">'xAxis'</span>, <span class="hljs-string">'yAxis'</span>, <span class="hljs-string">'shades'</span>, <span class="hljs-string">'outline'</span>, <span class="hljs-string">'scrollbarTrack'</span>,
                    <span class="hljs-string">'scrollbarRifles'</span>, <span class="hljs-string">'scrollbarGroup'</span>, <span class="hljs-string">'scrollbar'</span>, <span class="hljs-string">'navigatorGroup'</span>,
                    <span class="hljs-string">'rendered'</span>
                ], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prop</span>) </span>{
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[prop] &amp;&amp; <span class="hljs-keyword">this</span>[prop].destroy) {
                        <span class="hljs-keyword">this</span>[prop].destroy();
                    }
                    <span class="hljs-keyword">this</span>[prop] = <span class="hljs-literal">null</span>;
                }, <span class="hljs-keyword">this</span>);
                each([<span class="hljs-keyword">this</span>.handles], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">coll</span>) </span>{
                    destroyObjectProperties(coll);
                }, <span class="hljs-keyword">this</span>);
            }
        };
        H.Navigator = Navigator;
        wrap(Axis.prototype, <span class="hljs-string">'zoom'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, newMin, newMax</span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                chartOptions = chart.options,
                zoomType = chartOptions.chart.zoomType,
                previousZoom,
                navigator = chartOptions.navigator,
                rangeSelector = chartOptions.rangeSelector,
                ret;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isXAxis &amp;&amp; ((navigator &amp;&amp; navigator.enabled) ||
                    (rangeSelector &amp;&amp; rangeSelector.enabled))) {
                <span class="hljs-keyword">if</span> (zoomType === <span class="hljs-string">'x'</span>) {
                    chart.resetZoomButton = <span class="hljs-string">'blocked'</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zoomType === <span class="hljs-string">'y'</span>) {
                    ret = <span class="hljs-literal">false</span>;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zoomType === <span class="hljs-string">'xy'</span>) {
                    previousZoom = <span class="hljs-keyword">this</span>.previousZoom;
                    <span class="hljs-keyword">if</span> (defined(newMin)) {
                        <span class="hljs-keyword">this</span>.previousZoom = [<span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.max];
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (previousZoom) {
                        newMin = previousZoom[<span class="hljs-number">0</span>];
                        newMax = previousZoom[<span class="hljs-number">1</span>];
                        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.previousZoom;
                    }
                }
            }
            <span class="hljs-keyword">return</span> ret !== <span class="hljs-literal">undefined</span> ? ret : proceed.call(<span class="hljs-keyword">this</span>, newMin, newMax);
        });
        wrap(Chart.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, options, callback</span>) </span>{
            addEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'beforeRender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.options;
                <span class="hljs-keyword">if</span> (options.navigator.enabled || options.scrollbar.enabled) {
                    <span class="hljs-keyword">this</span>.scroller = <span class="hljs-keyword">this</span>.navigator = <span class="hljs-keyword">new</span> Navigator(<span class="hljs-keyword">this</span>);
                }
            });
            proceed.call(<span class="hljs-keyword">this</span>, options, callback);
        });
        wrap(Chart.prototype, <span class="hljs-string">'setChartSize'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> legend = <span class="hljs-keyword">this</span>.legend,
                navigator = <span class="hljs-keyword">this</span>.navigator,
                scrollbarHeight,
                legendOptions,
                xAxis,
                yAxis;
            proceed.apply(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (navigator) {
                legendOptions = legend &amp;&amp; legend.options;
                xAxis = navigator.xAxis;
                yAxis = navigator.yAxis;
                scrollbarHeight = navigator.scrollbarHeight;
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inverted) {
                    navigator.left = navigator.navigatorOptions.opposite ?
                        <span class="hljs-keyword">this</span>.chartWidth - scrollbarHeight - navigator.height :
                        <span class="hljs-keyword">this</span>.spacing[<span class="hljs-number">3</span>] + scrollbarHeight;
                    navigator.top = <span class="hljs-keyword">this</span>.plotTop + scrollbarHeight;
                } <span class="hljs-keyword">else</span> {
                    navigator.left = <span class="hljs-keyword">this</span>.plotLeft + scrollbarHeight;
                    navigator.top = navigator.navigatorOptions.top ||
                        <span class="hljs-keyword">this</span>.chartHeight - navigator.height - scrollbarHeight - <span class="hljs-keyword">this</span>.spacing[<span class="hljs-number">2</span>] -
                        (legendOptions &amp;&amp; legendOptions.verticalAlign === <span class="hljs-string">'bottom'</span> &amp;&amp; legendOptions.enabled &amp;&amp; !legendOptions.floating ?
                            legend.legendHeight + pick(legendOptions.margin, <span class="hljs-number">10</span>) : <span class="hljs-number">0</span>);
                }
                <span class="hljs-keyword">if</span> (xAxis &amp;&amp; yAxis) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.inverted) {
                        xAxis.options.left = yAxis.options.left = navigator.left;
                    } <span class="hljs-keyword">else</span> {
                        xAxis.options.top = yAxis.options.top = navigator.top;
                    }
                    xAxis.setAxisSize();
                    yAxis.setAxisSize();
                }
            }
        });
        wrap(Series.prototype, <span class="hljs-string">'addPoint'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, options, redraw, shift, animation</span>) </span>{
            <span class="hljs-keyword">var</span> turboThreshold = <span class="hljs-keyword">this</span>.options.turboThreshold;
            <span class="hljs-keyword">if</span> (turboThreshold &amp;&amp; <span class="hljs-keyword">this</span>.xData.length &gt; turboThreshold &amp;&amp; isObject(options, <span class="hljs-literal">true</span>) &amp;&amp; <span class="hljs-keyword">this</span>.chart.navigator) {
                error(<span class="hljs-number">20</span>, <span class="hljs-literal">true</span>);
            }
            proceed.call(<span class="hljs-keyword">this</span>, options, redraw, shift, animation);
        });
        wrap(Chart.prototype, <span class="hljs-string">'addSeries'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, options, redraw, animation</span>) </span>{
            <span class="hljs-keyword">var</span> series = proceed.call(<span class="hljs-keyword">this</span>, options, <span class="hljs-literal">false</span>, animation);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.navigator) {
                <span class="hljs-keyword">this</span>.navigator.setBaseSeries();
            }
            <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">this</span>.redraw();
            }
            <span class="hljs-keyword">return</span> series;
        });
        wrap(Series.prototype, <span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, newOptions, redraw</span>) </span>{
            proceed.call(<span class="hljs-keyword">this</span>, newOptions, <span class="hljs-literal">false</span>);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart.navigator) {
                <span class="hljs-keyword">this</span>.chart.navigator.setBaseSeries();
            }
            <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                <span class="hljs-keyword">this</span>.chart.redraw();
            }
        });
        Chart.prototype.callbacks.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart</span>) </span>{
            <span class="hljs-keyword">var</span> extremes,
                navigator = chart.navigator;
            <span class="hljs-keyword">if</span> (navigator) {
                extremes = chart.xAxis[<span class="hljs-number">0</span>].getExtremes();
                navigator.render(extremes.min, extremes.max);
            }
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> addEvent = H.addEvent,
            Axis = H.Axis,
            Chart = H.Chart,
            css = H.css,
            createElement = H.createElement,
            dateFormat = H.dateFormat,
            defaultOptions = H.defaultOptions,
            useUTC = defaultOptions.global.useUTC,
            defined = H.defined,
            destroyObjectProperties = H.destroyObjectProperties,
            discardElement = H.discardElement,
            each = H.each,
            extend = H.extend,
            fireEvent = H.fireEvent,
            HCDate = H.Date,
            isNumber = H.isNumber,
            merge = H.merge,
            pick = H.pick,
            pInt = H.pInt,
            splat = H.splat,
            wrap = H.wrap;
        extend(defaultOptions, {
            <span class="hljs-attr">rangeSelector</span>: {
                <span class="hljs-attr">buttonTheme</span>: {
                    <span class="hljs-string">'stroke-width'</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">width</span>: <span class="hljs-number">28</span>,
                    <span class="hljs-attr">height</span>: <span class="hljs-number">18</span>,
                    <span class="hljs-attr">padding</span>: <span class="hljs-number">2</span>,
                    <span class="hljs-attr">zIndex</span>: <span class="hljs-number">7</span>
                },
                <span class="hljs-attr">height</span>: <span class="hljs-number">35</span>,
                <span class="hljs-attr">inputPosition</span>: {
                    <span class="hljs-attr">align</span>: <span class="hljs-string">'right'</span>
                },
                <span class="hljs-attr">labelStyle</span>: {
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#666666'</span>
                }
            }
        });
        defaultOptions.lang = merge(defaultOptions.lang, {
            <span class="hljs-attr">rangeSelectorZoom</span>: <span class="hljs-string">'Zoom'</span>,
            <span class="hljs-attr">rangeSelectorFrom</span>: <span class="hljs-string">'From'</span>,
            <span class="hljs-attr">rangeSelectorTo</span>: <span class="hljs-string">'To'</span>
        });

        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RangeSelector</span>(<span class="hljs-params">chart</span>) </span>{
            <span class="hljs-keyword">this</span>.init(chart);
        }
        RangeSelector.prototype = {
            <span class="hljs-attr">clickButton</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i, redraw</span>) </span>{
                <span class="hljs-keyword">var</span> rangeSelector = <span class="hljs-keyword">this</span>,
                    chart = rangeSelector.chart,
                    rangeOptions = rangeSelector.buttonOptions[i],
                    baseAxis = chart.xAxis[<span class="hljs-number">0</span>],
                    unionExtremes = (chart.scroller &amp;&amp; chart.scroller.getUnionExtremes()) || baseAxis || {},
                    dataMin = unionExtremes.dataMin,
                    dataMax = unionExtremes.dataMax,
                    newMin,
                    newMax = baseAxis &amp;&amp; <span class="hljs-built_in">Math</span>.round(<span class="hljs-built_in">Math</span>.min(baseAxis.max, pick(dataMax, baseAxis.max))),
                    type = rangeOptions.type,
                    baseXAxisOptions,
                    range = rangeOptions._range,
                    rangeMin,
                    minSetting,
                    rangeSetting,
                    ctx,
                    ytdExtremes,
                    dataGrouping = rangeOptions.dataGrouping;
                <span class="hljs-keyword">if</span> (dataMin === <span class="hljs-literal">null</span> || dataMax === <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">return</span>;
                }
                chart.fixedRange = range;
                <span class="hljs-keyword">if</span> (dataGrouping) {
                    <span class="hljs-keyword">this</span>.forcedDataGrouping = <span class="hljs-literal">true</span>;
                    Axis.prototype.setDataGrouping.call(baseAxis || {
                        <span class="hljs-attr">chart</span>: <span class="hljs-keyword">this</span>.chart
                    }, dataGrouping, <span class="hljs-literal">false</span>);
                }
                <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'month'</span> || type === <span class="hljs-string">'year'</span>) {
                    <span class="hljs-keyword">if</span> (!baseAxis) {
                        range = rangeOptions;
                    } <span class="hljs-keyword">else</span> {
                        ctx = {
                            <span class="hljs-attr">range</span>: rangeOptions,
                            <span class="hljs-attr">max</span>: newMax,
                            <span class="hljs-attr">dataMin</span>: dataMin,
                            <span class="hljs-attr">dataMax</span>: dataMax
                        };
                        newMin = baseAxis.minFromRange.call(ctx);
                        <span class="hljs-keyword">if</span> (isNumber(ctx.newMax)) {
                            newMax = ctx.newMax;
                        }
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (range) {
                    newMin = <span class="hljs-built_in">Math</span>.max(newMax - range, dataMin);
                    newMax = <span class="hljs-built_in">Math</span>.min(newMin + range, dataMax);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'ytd'</span>) {
                    <span class="hljs-keyword">if</span> (baseAxis) {
                        <span class="hljs-keyword">if</span> (dataMax === <span class="hljs-literal">undefined</span>) {
                            dataMin = <span class="hljs-built_in">Number</span>.MAX_VALUE;
                            dataMax = <span class="hljs-built_in">Number</span>.MIN_VALUE;
                            each(chart.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                                <span class="hljs-keyword">var</span> xData = series.xData;
                                dataMin = <span class="hljs-built_in">Math</span>.min(xData[<span class="hljs-number">0</span>], dataMin);
                                dataMax = <span class="hljs-built_in">Math</span>.max(xData[xData.length - <span class="hljs-number">1</span>], dataMax);
                            });
                            redraw = <span class="hljs-literal">false</span>;
                        }
                        ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, useUTC);
                        newMin = rangeMin = ytdExtremes.min;
                        newMax = ytdExtremes.max;
                    } <span class="hljs-keyword">else</span> {
                        addEvent(chart, <span class="hljs-string">'beforeRender'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                            rangeSelector.clickButton(i);
                        });
                        <span class="hljs-keyword">return</span>;
                    }
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'all'</span> &amp;&amp; baseAxis) {
                    newMin = dataMin;
                    newMax = dataMax;
                }
                rangeSelector.setSelected(i);
                <span class="hljs-keyword">if</span> (!baseAxis) {
                    baseXAxisOptions = splat(chart.options.xAxis)[<span class="hljs-number">0</span>];
                    rangeSetting = baseXAxisOptions.range;
                    baseXAxisOptions.range = range;
                    minSetting = baseXAxisOptions.min;
                    baseXAxisOptions.min = rangeMin;
                    addEvent(chart, <span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetMinAndRange</span>(<span class="hljs-params"></span>) </span>{
                        baseXAxisOptions.range = rangeSetting;
                        baseXAxisOptions.min = minSetting;
                    });
                } <span class="hljs-keyword">else</span> {
                    baseAxis.setExtremes(
                        newMin,
                        newMax,
                        pick(redraw, <span class="hljs-number">1</span>),
                        <span class="hljs-literal">null</span>, {
                            <span class="hljs-attr">trigger</span>: <span class="hljs-string">'rangeSelectorButton'</span>,
                            <span class="hljs-attr">rangeSelectorButton</span>: rangeOptions
                        }
                    );
                }
            },
            <span class="hljs-attr">setSelected</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selected</span>) </span>{
                <span class="hljs-keyword">this</span>.selected = <span class="hljs-keyword">this</span>.options.selected = selected;
            },
            <span class="hljs-attr">defaultButtons</span>: [{
                <span class="hljs-attr">type</span>: <span class="hljs-string">'month'</span>,
                <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'1m'</span>
            }, {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'month'</span>,
                <span class="hljs-attr">count</span>: <span class="hljs-number">3</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'3m'</span>
            }, {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'month'</span>,
                <span class="hljs-attr">count</span>: <span class="hljs-number">6</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'6m'</span>
            }, {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'ytd'</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'YTD'</span>
            }, {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'year'</span>,
                <span class="hljs-attr">count</span>: <span class="hljs-number">1</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'1y'</span>
            }, {
                <span class="hljs-attr">type</span>: <span class="hljs-string">'all'</span>,
                <span class="hljs-attr">text</span>: <span class="hljs-string">'All'</span>
            }],
            <span class="hljs-attr">init</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart</span>) </span>{
                <span class="hljs-keyword">var</span> rangeSelector = <span class="hljs-keyword">this</span>,
                    options = chart.options.rangeSelector,
                    buttonOptions = options.buttons || [].concat(rangeSelector.defaultButtons),
                    selectedOption = options.selected,
                    blurInputs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        <span class="hljs-keyword">var</span> minInput = rangeSelector.minInput,
                            maxInput = rangeSelector.maxInput;
                        <span class="hljs-keyword">if</span> (minInput &amp;&amp; minInput.blur) {
                            fireEvent(minInput, <span class="hljs-string">'blur'</span>);
                        }
                        <span class="hljs-keyword">if</span> (maxInput &amp;&amp; maxInput.blur) {
                            fireEvent(maxInput, <span class="hljs-string">'blur'</span>);
                        }
                    };
                rangeSelector.chart = chart;
                rangeSelector.options = options;
                rangeSelector.buttons = [];
                chart.extraTopMargin = options.height;
                rangeSelector.buttonOptions = buttonOptions;
                <span class="hljs-keyword">this</span>.unMouseDown = addEvent(chart.container, <span class="hljs-string">'mousedown'</span>, blurInputs);
                <span class="hljs-keyword">this</span>.unResize = addEvent(chart, <span class="hljs-string">'resize'</span>, blurInputs);
                each(buttonOptions, rangeSelector.computeButtonRange);
                <span class="hljs-keyword">if</span> (selectedOption !== <span class="hljs-literal">undefined</span> &amp;&amp; buttonOptions[selectedOption]) {
                    <span class="hljs-keyword">this</span>.clickButton(selectedOption, <span class="hljs-literal">false</span>);
                }
                addEvent(chart, <span class="hljs-string">'load'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    addEvent(chart.xAxis[<span class="hljs-number">0</span>], <span class="hljs-string">'setExtremes'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.max - <span class="hljs-keyword">this</span>.min !== chart.fixedRange &amp;&amp; e.trigger !== <span class="hljs-string">'rangeSelectorButton'</span> &amp;&amp;
                            e.trigger !== <span class="hljs-string">'updatedData'</span> &amp;&amp; rangeSelector.forcedDataGrouping) {
                            <span class="hljs-keyword">this</span>.setDataGrouping(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
                        }
                    });
                });
            },
            <span class="hljs-attr">updateButtonStates</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> rangeSelector = <span class="hljs-keyword">this</span>,
                    chart = <span class="hljs-keyword">this</span>.chart,
                    baseAxis = chart.xAxis[<span class="hljs-number">0</span>],
                    actualRange = <span class="hljs-built_in">Math</span>.round(baseAxis.max - baseAxis.min),
                    hasNoData = !baseAxis.hasVisibleSeries,
                    day = <span class="hljs-number">24</span> * <span class="hljs-number">36e5</span>,
                    unionExtremes = (chart.scroller &amp;&amp; chart.scroller.getUnionExtremes()) || baseAxis,
                    dataMin = unionExtremes.dataMin,
                    dataMax = unionExtremes.dataMax,
                    ytdExtremes = rangeSelector.getYTDExtremes(dataMax, dataMin, useUTC),
                    ytdMin = ytdExtremes.min,
                    ytdMax = ytdExtremes.max,
                    selected = rangeSelector.selected,
                    selectedExists = isNumber(selected),
                    allButtonsEnabled = rangeSelector.options.allButtonsEnabled,
                    buttons = rangeSelector.buttons;
                each(rangeSelector.buttonOptions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rangeOptions, i</span>) </span>{
                    <span class="hljs-keyword">var</span> range = rangeOptions._range,
                        type = rangeOptions.type,
                        count = rangeOptions.count || <span class="hljs-number">1</span>,
                        button = buttons[i],
                        state = <span class="hljs-number">0</span>,
                        disable,
                        select,
                        isSelected = i === selected,
                        isTooGreatRange = range &gt; dataMax - dataMin,
                        isTooSmallRange = range &lt; baseAxis.minRange,
                        isYTDButNotSelected = <span class="hljs-literal">false</span>,
                        isAllButAlreadyShowingAll = <span class="hljs-literal">false</span>,
                        isSameRange = range === actualRange;
                    <span class="hljs-keyword">if</span> (
                        (type === <span class="hljs-string">'month'</span> || type === <span class="hljs-string">'year'</span>) &amp;&amp;
                        (actualRange &gt;= {
                            <span class="hljs-attr">month</span>: <span class="hljs-number">28</span>,
                            <span class="hljs-attr">year</span>: <span class="hljs-number">365</span>
                        }[type] * day * count) &amp;&amp;
                        (actualRange &lt;= {
                            <span class="hljs-attr">month</span>: <span class="hljs-number">31</span>,
                            <span class="hljs-attr">year</span>: <span class="hljs-number">366</span>
                        }[type] * day * count)
                    ) {
                        isSameRange = <span class="hljs-literal">true</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'ytd'</span>) {
                        isSameRange = (ytdMax - ytdMin) === actualRange;
                        isYTDButNotSelected = !isSelected;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'all'</span>) {
                        isSameRange = baseAxis.max - baseAxis.min &gt;= dataMax - dataMin;
                        isAllButAlreadyShowingAll = !isSelected &amp;&amp; selectedExists &amp;&amp; isSameRange;
                    }
                    disable = (!allButtonsEnabled &amp;&amp;
                        (
                            isTooGreatRange ||
                            isTooSmallRange ||
                            isAllButAlreadyShowingAll ||
                            hasNoData
                        )
                    );
                    select = (
                        (isSelected &amp;&amp; isSameRange) ||
                        (isSameRange &amp;&amp; !selectedExists &amp;&amp; !isYTDButNotSelected)
                    );
                    <span class="hljs-keyword">if</span> (disable) {
                        state = <span class="hljs-number">3</span>;
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (select) {
                        selectedExists = <span class="hljs-literal">true</span>;
                        state = <span class="hljs-number">2</span>;
                    }
                    <span class="hljs-keyword">if</span> (button.state !== state) {
                        button.setState(state);
                    }
                });
            },
            <span class="hljs-attr">computeButtonRange</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rangeOptions</span>) </span>{
                <span class="hljs-keyword">var</span> type = rangeOptions.type,
                    count = rangeOptions.count || <span class="hljs-number">1</span>,
                    fixedTimes = {
                        <span class="hljs-attr">millisecond</span>: <span class="hljs-number">1</span>,
                        <span class="hljs-attr">second</span>: <span class="hljs-number">1000</span>,
                        <span class="hljs-attr">minute</span>: <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,
                        <span class="hljs-attr">hour</span>: <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>,
                        <span class="hljs-attr">day</span>: <span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>,
                        <span class="hljs-attr">week</span>: <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>
                    };
                <span class="hljs-keyword">if</span> (fixedTimes[type]) {
                    rangeOptions._range = fixedTimes[type] * count;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">'month'</span> || type === <span class="hljs-string">'year'</span>) {
                    rangeOptions._range = {
                        <span class="hljs-attr">month</span>: <span class="hljs-number">30</span>,
                        <span class="hljs-attr">year</span>: <span class="hljs-number">365</span>
                    }[type] * <span class="hljs-number">24</span> * <span class="hljs-number">36e5</span> * count;
                }
            },
            <span class="hljs-attr">setInputValue</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, time</span>) </span>{
                <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.chart.options.rangeSelector,
                    input = <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'Input'</span>];
                <span class="hljs-keyword">if</span> (defined(time)) {
                    input.previousValue = input.HCTime;
                    input.HCTime = time;
                }
                input.value = dateFormat(
                    options.inputEditDateFormat || <span class="hljs-string">'%Y-%m-%d'</span>,
                    input.HCTime
                );
                <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'DateBox'</span>].attr({
                    <span class="hljs-attr">text</span>: dateFormat(options.inputDateFormat || <span class="hljs-string">'%b %e, %Y'</span>, input.HCTime)
                });
            },
            <span class="hljs-attr">showInput</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                <span class="hljs-keyword">var</span> inputGroup = <span class="hljs-keyword">this</span>.inputGroup,
                    dateBox = <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'DateBox'</span>];
                css(<span class="hljs-keyword">this</span>[name + <span class="hljs-string">'Input'</span>], {
                    <span class="hljs-attr">left</span>: (inputGroup.translateX + dateBox.x) + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">top</span>: inputGroup.translateY + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">width</span>: (dateBox.width - <span class="hljs-number">2</span>) + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">height</span>: (dateBox.height - <span class="hljs-number">2</span>) + <span class="hljs-string">'px'</span>,
                    <span class="hljs-attr">border</span>: <span class="hljs-string">'2px solid silver'</span>
                });
            },
            <span class="hljs-attr">hideInput</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                css(<span class="hljs-keyword">this</span>[name + <span class="hljs-string">'Input'</span>], {
                    <span class="hljs-attr">border</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">width</span>: <span class="hljs-string">'1px'</span>,
                    <span class="hljs-attr">height</span>: <span class="hljs-string">'1px'</span>
                });
                <span class="hljs-keyword">this</span>.setInputValue(name);
            },
            <span class="hljs-attr">drawInput</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
                <span class="hljs-keyword">var</span> rangeSelector = <span class="hljs-keyword">this</span>,
                    chart = rangeSelector.chart,
                    chartStyle = chart.renderer.style || {},
                    renderer = chart.renderer,
                    options = chart.options.rangeSelector,
                    lang = defaultOptions.lang,
                    div = rangeSelector.div,
                    isMin = name === <span class="hljs-string">'min'</span>,
                    input,
                    label,
                    dateBox,
                    inputGroup = <span class="hljs-keyword">this</span>.inputGroup;

                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateExtremes</span>(<span class="hljs-params"></span>) </span>{
                    <span class="hljs-keyword">var</span> inputValue = input.value,
                        value = (options.inputDateParser || <span class="hljs-built_in">Date</span>.parse)(inputValue),
                        chartAxis = chart.xAxis[<span class="hljs-number">0</span>],
                        dataAxis = chart.scroller &amp;&amp; chart.scroller.xAxis ? chart.scroller.xAxis : chartAxis,
                        dataMin = dataAxis.dataMin,
                        dataMax = dataAxis.dataMax;
                    <span class="hljs-keyword">if</span> (value !== input.previousValue) {
                        input.previousValue = value;
                        <span class="hljs-keyword">if</span> (!isNumber(value)) {
                            value = inputValue.split(<span class="hljs-string">'-'</span>);
                            value = <span class="hljs-built_in">Date</span>.UTC(pInt(value[<span class="hljs-number">0</span>]), pInt(value[<span class="hljs-number">1</span>]) - <span class="hljs-number">1</span>, pInt(value[<span class="hljs-number">2</span>]));
                        }
                        <span class="hljs-keyword">if</span> (isNumber(value)) {
                            <span class="hljs-keyword">if</span> (!useUTC) {
                                value = value + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTimezoneOffset() * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
                            }
                            <span class="hljs-keyword">if</span> (isMin) {
                                <span class="hljs-keyword">if</span> (value &gt; rangeSelector.maxInput.HCTime) {
                                    value = <span class="hljs-literal">undefined</span>;
                                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; dataMin) {
                                    value = dataMin;
                                }
                            } <span class="hljs-keyword">else</span> {
                                <span class="hljs-keyword">if</span> (value &lt; rangeSelector.minInput.HCTime) {
                                    value = <span class="hljs-literal">undefined</span>;
                                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; dataMax) {
                                    value = dataMax;
                                }
                            }
                            <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span>) {
                                chartAxis.setExtremes(
                                    isMin ? value : chartAxis.min,
                                    isMin ? chartAxis.max : value,
                                    <span class="hljs-literal">undefined</span>,
                                    <span class="hljs-literal">undefined</span>, {
                                        <span class="hljs-attr">trigger</span>: <span class="hljs-string">'rangeSelectorInput'</span>
                                    }
                                );
                            }
                        }
                    }
                }
                <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'Label'</span>] = label = renderer.label(lang[isMin ? <span class="hljs-string">'rangeSelectorFrom'</span> : <span class="hljs-string">'rangeSelectorTo'</span>], <span class="hljs-keyword">this</span>.inputGroup.offset)
                    .addClass(<span class="hljs-string">'highcharts-range-label'</span>)
                    .attr({
                        <span class="hljs-attr">padding</span>: <span class="hljs-number">2</span>
                    })
                    .add(inputGroup);
                inputGroup.offset += label.width + <span class="hljs-number">5</span>;
                <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'DateBox'</span>] = dateBox = renderer.label(<span class="hljs-string">''</span>, inputGroup.offset)
                    .addClass(<span class="hljs-string">'highcharts-range-input'</span>)
                    .attr({
                        <span class="hljs-attr">padding</span>: <span class="hljs-number">2</span>,
                        <span class="hljs-attr">width</span>: options.inputBoxWidth || <span class="hljs-number">90</span>,
                        <span class="hljs-attr">height</span>: options.inputBoxHeight || <span class="hljs-number">17</span>,
                        <span class="hljs-attr">stroke</span>: options.inputBoxBorderColor || <span class="hljs-string">'#cccccc'</span>,
                        <span class="hljs-string">'stroke-width'</span>: <span class="hljs-number">1</span>,
                        <span class="hljs-string">'text-align'</span>: <span class="hljs-string">'center'</span>
                    })
                    .on(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                        rangeSelector.showInput(name);
                        rangeSelector[name + <span class="hljs-string">'Input'</span>].focus();
                    })
                    .add(inputGroup);
                inputGroup.offset += dateBox.width + (isMin ? <span class="hljs-number">10</span> : <span class="hljs-number">0</span>);
                <span class="hljs-keyword">this</span>[name + <span class="hljs-string">'Input'</span>] = input = createElement(<span class="hljs-string">'input'</span>, {
                    <span class="hljs-attr">name</span>: name,
                    <span class="hljs-attr">className</span>: <span class="hljs-string">'highcharts-range-selector'</span>,
                    <span class="hljs-attr">type</span>: <span class="hljs-string">'text'</span>
                }, {
                    <span class="hljs-attr">top</span>: chart.plotTop + <span class="hljs-string">'px'</span>
                }, div);
                label.css(merge(chartStyle, options.labelStyle));
                dateBox.css(merge({
                    <span class="hljs-attr">color</span>: <span class="hljs-string">'#333333'</span>
                }, chartStyle, options.inputStyle));
                css(input, extend({
                    <span class="hljs-attr">position</span>: <span class="hljs-string">'absolute'</span>,
                    <span class="hljs-attr">border</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">width</span>: <span class="hljs-string">'1px'</span>,
                    <span class="hljs-attr">height</span>: <span class="hljs-string">'1px'</span>,
                    <span class="hljs-attr">padding</span>: <span class="hljs-number">0</span>,
                    <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>,
                    <span class="hljs-attr">fontSize</span>: chartStyle.fontSize,
                    <span class="hljs-attr">fontFamily</span>: chartStyle.fontFamily,
                    <span class="hljs-attr">left</span>: <span class="hljs-string">'-9em'</span>
                }, options.inputStyle));
                input.onfocus = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    rangeSelector.showInput(name);
                };
                input.onblur = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                    rangeSelector.hideInput(name);
                };
                input.onchange = updateExtremes;
                input.onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
                    <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">13</span>) {
                        updateExtremes();
                    }
                };
            },
            <span class="hljs-attr">getPosition</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                    options = chart.options.rangeSelector,
                    buttonTop = pick((options.buttonPosition || {}).y, chart.plotTop - chart.axisOffset[<span class="hljs-number">0</span>] - options.height);
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">buttonTop</span>: buttonTop,
                    <span class="hljs-attr">inputTop</span>: buttonTop - <span class="hljs-number">10</span>
                };
            },
            <span class="hljs-attr">getYTDExtremes</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">dataMax, dataMin, useUTC</span>) </span>{
                <span class="hljs-keyword">var</span> min,
                    now = <span class="hljs-keyword">new</span> HCDate(dataMax),
                    year = now[HCDate.hcGetFullYear](),
                    startOfYear = useUTC ? HCDate.UTC(year, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) : +<span class="hljs-keyword">new</span> HCDate(year, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
                min = <span class="hljs-built_in">Math</span>.max(dataMin || <span class="hljs-number">0</span>, startOfYear);
                now = now.getTime();
                <span class="hljs-keyword">return</span> {
                    <span class="hljs-attr">max</span>: <span class="hljs-built_in">Math</span>.min(dataMax || now, now),
                    <span class="hljs-attr">min</span>: min
                };
            },
            <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">min, max</span>) </span>{
                <span class="hljs-keyword">var</span> rangeSelector = <span class="hljs-keyword">this</span>,
                    chart = rangeSelector.chart,
                    renderer = chart.renderer,
                    container = chart.container,
                    chartOptions = chart.options,
                    navButtonOptions = chartOptions.exporting &amp;&amp; chartOptions.exporting.enabled !== <span class="hljs-literal">false</span> &amp;&amp;
                    chartOptions.navigation &amp;&amp; chartOptions.navigation.buttonOptions,
                    options = chartOptions.rangeSelector,
                    buttons = rangeSelector.buttons,
                    lang = defaultOptions.lang,
                    div = rangeSelector.div,
                    inputGroup = rangeSelector.inputGroup,
                    buttonTheme = options.buttonTheme,
                    buttonPosition = options.buttonPosition || {},
                    inputEnabled = options.inputEnabled,
                    states = buttonTheme &amp;&amp; buttonTheme.states,
                    plotLeft = chart.plotLeft,
                    buttonLeft,
                    pos = <span class="hljs-keyword">this</span>.getPosition(),
                    buttonGroup = rangeSelector.group,
                    buttonBBox,
                    rendered = rangeSelector.rendered;
                <span class="hljs-keyword">if</span> (options.enabled === <span class="hljs-literal">false</span>) {
                    <span class="hljs-keyword">return</span>;
                }
                <span class="hljs-keyword">if</span> (!rendered) {
                    rangeSelector.group = buttonGroup = renderer.g(<span class="hljs-string">'range-selector-buttons'</span>).add();
                    rangeSelector.zoomText = renderer.text(lang.rangeSelectorZoom, pick(buttonPosition.x, plotLeft), <span class="hljs-number">15</span>)
                        .css(options.labelStyle)
                        .add(buttonGroup);
                    buttonLeft = pick(buttonPosition.x, plotLeft) + rangeSelector.zoomText.getBBox().width + <span class="hljs-number">5</span>;
                    each(rangeSelector.buttonOptions, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">rangeOptions, i</span>) </span>{
                        buttons[i] = renderer.button(
                                rangeOptions.text,
                                buttonLeft,
                                <span class="hljs-number">0</span>,
                                <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                                    rangeSelector.clickButton(i);
                                    rangeSelector.isActive = <span class="hljs-literal">true</span>;
                                },
                                buttonTheme,
                                states &amp;&amp; states.hover,
                                states &amp;&amp; states.select,
                                states &amp;&amp; states.disabled
                            )
                            .attr({
                                <span class="hljs-string">'text-align'</span>: <span class="hljs-string">'center'</span>
                            })
                            .add(buttonGroup);
                        buttonLeft += buttons[i].width + pick(options.buttonSpacing, <span class="hljs-number">5</span>);
                    });
                    <span class="hljs-keyword">if</span> (inputEnabled !== <span class="hljs-literal">false</span>) {
                        rangeSelector.div = div = createElement(<span class="hljs-string">'div'</span>, <span class="hljs-literal">null</span>, {
                            <span class="hljs-attr">position</span>: <span class="hljs-string">'relative'</span>,
                            <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>,
                            <span class="hljs-attr">zIndex</span>: <span class="hljs-number">1</span>
                        });
                        container.parentNode.insertBefore(div, container);
                        rangeSelector.inputGroup = inputGroup = renderer.g(<span class="hljs-string">'input-group'</span>)
                            .add();
                        inputGroup.offset = <span class="hljs-number">0</span>;
                        rangeSelector.drawInput(<span class="hljs-string">'min'</span>);
                        rangeSelector.drawInput(<span class="hljs-string">'max'</span>);
                    }
                }
                rangeSelector.updateButtonStates();
                buttonGroup[rendered ? <span class="hljs-string">'animate'</span> : <span class="hljs-string">'attr'</span>]({
                    <span class="hljs-attr">translateY</span>: pos.buttonTop
                });
                <span class="hljs-keyword">if</span> (inputEnabled !== <span class="hljs-literal">false</span>) {
                    inputGroup.align(extend({
                        <span class="hljs-attr">y</span>: pos.inputTop,
                        <span class="hljs-attr">width</span>: inputGroup.offset,
                        <span class="hljs-attr">x</span>: navButtonOptions &amp;&amp; (pos.inputTop &lt; (navButtonOptions.y || <span class="hljs-number">0</span>) + navButtonOptions.height - chart.spacing[<span class="hljs-number">0</span>]) ?
                            <span class="hljs-number">-40</span> : <span class="hljs-number">0</span>
                    }, options.inputPosition), <span class="hljs-literal">true</span>, chart.spacingBox);
                    <span class="hljs-keyword">if</span> (!defined(inputEnabled)) {
                        buttonBBox = buttonGroup.getBBox();
                        inputGroup[inputGroup.alignAttr.translateX &lt; buttonBBox.x + buttonBBox.width + <span class="hljs-number">10</span> ? <span class="hljs-string">'hide'</span> : <span class="hljs-string">'show'</span>]();
                    }
                    rangeSelector.setInputValue(<span class="hljs-string">'min'</span>, min);
                    rangeSelector.setInputValue(<span class="hljs-string">'max'</span>, max);
                }
                rangeSelector.rendered = <span class="hljs-literal">true</span>;
            },
            <span class="hljs-attr">update</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
                <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart;
                merge(<span class="hljs-literal">true</span>, chart.options.rangeSelector, options);
                <span class="hljs-keyword">this</span>.destroy();
                <span class="hljs-keyword">this</span>.init(chart);
            },
            <span class="hljs-attr">destroy</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">var</span> minInput = <span class="hljs-keyword">this</span>.minInput,
                    maxInput = <span class="hljs-keyword">this</span>.maxInput,
                    key;
                <span class="hljs-keyword">this</span>.unMouseDown();
                <span class="hljs-keyword">this</span>.unResize();
                destroyObjectProperties(<span class="hljs-keyword">this</span>.buttons);
                <span class="hljs-keyword">if</span> (minInput) {
                    minInput.onfocus = minInput.onblur = minInput.onchange = <span class="hljs-literal">null</span>;
                }
                <span class="hljs-keyword">if</span> (maxInput) {
                    maxInput.onfocus = maxInput.onblur = maxInput.onchange = <span class="hljs-literal">null</span>;
                }
                <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key] &amp;&amp; key !== <span class="hljs-string">'chart'</span>) {
                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key].destroy) {
                            <span class="hljs-keyword">this</span>[key].destroy();
                        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key].nodeType) {
                            discardElement(<span class="hljs-keyword">this</span>[key]);
                        }
                    }
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[key] !== RangeSelector.prototype[key]) {
                        <span class="hljs-keyword">this</span>[key] = <span class="hljs-literal">null</span>;
                    }
                }
            }
        };
        Axis.prototype.toFixedRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pxMin, pxMax, fixedMin, fixedMax</span>) </span>{
            <span class="hljs-keyword">var</span> fixedRange = <span class="hljs-keyword">this</span>.chart &amp;&amp; <span class="hljs-keyword">this</span>.chart.fixedRange,
                newMin = pick(fixedMin, <span class="hljs-keyword">this</span>.translate(pxMin, <span class="hljs-literal">true</span>, !<span class="hljs-keyword">this</span>.horiz)),
                newMax = pick(fixedMax, <span class="hljs-keyword">this</span>.translate(pxMax, <span class="hljs-literal">true</span>, !<span class="hljs-keyword">this</span>.horiz)),
                changeRatio = fixedRange &amp;&amp; (newMax - newMin) / fixedRange;
            <span class="hljs-keyword">if</span> (changeRatio &gt; <span class="hljs-number">0.7</span> &amp;&amp; changeRatio &lt; <span class="hljs-number">1.3</span>) {
                <span class="hljs-keyword">if</span> (fixedMax) {
                    newMin = newMax - fixedRange;
                } <span class="hljs-keyword">else</span> {
                    newMax = newMin + fixedRange;
                }
            }
            <span class="hljs-keyword">if</span> (!isNumber(newMin)) {
                newMin = newMax = <span class="hljs-literal">undefined</span>;
            }
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">min</span>: newMin,
                <span class="hljs-attr">max</span>: newMax
            };
        };
        Axis.prototype.minFromRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> rangeOptions = <span class="hljs-keyword">this</span>.range,
                type = rangeOptions.type,
                timeName = {
                    <span class="hljs-attr">month</span>: <span class="hljs-string">'Month'</span>,
                    <span class="hljs-attr">year</span>: <span class="hljs-string">'FullYear'</span>
                }[type],
                min,
                max = <span class="hljs-keyword">this</span>.max,
                dataMin,
                range,
                getTrueRange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">base, count</span>) </span>{
                    <span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(base);
                    date[<span class="hljs-string">'set'</span> + timeName](date[<span class="hljs-string">'get'</span> + timeName]() + count);
                    <span class="hljs-keyword">return</span> date.getTime() - base;
                };
            <span class="hljs-keyword">if</span> (isNumber(rangeOptions)) {
                min = max - rangeOptions;
                range = rangeOptions;
            } <span class="hljs-keyword">else</span> {
                min = max + getTrueRange(max, -rangeOptions.count);
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart) {
                    <span class="hljs-keyword">this</span>.chart.fixedRange = max - min;
                }
            }
            dataMin = pick(<span class="hljs-keyword">this</span>.dataMin, <span class="hljs-built_in">Number</span>.MIN_VALUE);
            <span class="hljs-keyword">if</span> (!isNumber(min)) {
                min = dataMin;
            }
            <span class="hljs-keyword">if</span> (min &lt;= dataMin) {
                min = dataMin;
                <span class="hljs-keyword">if</span> (range === <span class="hljs-literal">undefined</span>) {
                    range = getTrueRange(min, rangeOptions.count);
                }
                <span class="hljs-keyword">this</span>.newMax = <span class="hljs-built_in">Math</span>.min(min + range, <span class="hljs-keyword">this</span>.dataMax);
            }
            <span class="hljs-keyword">if</span> (!isNumber(max)) {
                min = <span class="hljs-literal">undefined</span>;
            }
            <span class="hljs-keyword">return</span> min;
        };
        wrap(Chart.prototype, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, options, callback</span>) </span>{
            addEvent(<span class="hljs-keyword">this</span>, <span class="hljs-string">'init'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.rangeSelector.enabled) {
                    <span class="hljs-keyword">this</span>.rangeSelector = <span class="hljs-keyword">new</span> RangeSelector(<span class="hljs-keyword">this</span>);
                }
            });
            proceed.call(<span class="hljs-keyword">this</span>, options, callback);
        });
        Chart.prototype.callbacks.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">chart</span>) </span>{
            <span class="hljs-keyword">var</span> extremes,
                rangeSelector = chart.rangeSelector,
                unbindRender,
                unbindSetExtremes;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderRangeSelector</span>(<span class="hljs-params"></span>) </span>{
                extremes = chart.xAxis[<span class="hljs-number">0</span>].getExtremes();
                <span class="hljs-keyword">if</span> (isNumber(extremes.min)) {
                    rangeSelector.render(extremes.min, extremes.max);
                }
            }
            <span class="hljs-keyword">if</span> (rangeSelector) {
                unbindSetExtremes = addEvent(
                    chart.xAxis[<span class="hljs-number">0</span>],
                    <span class="hljs-string">'afterSetExtremes'</span>,
                    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
                        rangeSelector.render(e.min, e.max);
                    }
                );
                unbindRender = addEvent(chart, <span class="hljs-string">'redraw'</span>, renderRangeSelector);
                renderRangeSelector();
            }
            addEvent(chart, <span class="hljs-string">'destroy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroyEvents</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">if</span> (rangeSelector) {
                    unbindRender();
                    unbindSetExtremes();
                }
            });
        });
        H.RangeSelector = RangeSelector;
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">H</span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
        <span class="hljs-keyword">var</span> arrayMax = H.arrayMax,
            arrayMin = H.arrayMin,
            Axis = H.Axis,
            Chart = H.Chart,
            defined = H.defined,
            each = H.each,
            extend = H.extend,
            format = H.format,
            inArray = H.inArray,
            isNumber = H.isNumber,
            isString = H.isString,
            map = H.map,
            merge = H.merge,
            pick = H.pick,
            Point = H.Point,
            Renderer = H.Renderer,
            Series = H.Series,
            splat = H.splat,
            SVGRenderer = H.SVGRenderer,
            VMLRenderer = H.VMLRenderer,
            wrap = H.wrap,
            seriesProto = Series.prototype,
            seriesInit = seriesProto.init,
            seriesProcessData = seriesProto.processData,
            pointTooltipFormatter = Point.prototype.tooltipFormatter;
        H.StockChart = H.stockChart = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c</span>) </span>{
            <span class="hljs-keyword">var</span> hasRenderToArg = isString(a) || a.nodeName,
                options = <span class="hljs-built_in">arguments</span>[hasRenderToArg ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>],
                seriesOptions = options.series,
                defaultOptions = H.getOptions(),
                opposite,
                navigatorEnabled = pick(
                    options.navigator &amp;&amp; options.navigator.enabled,
                    defaultOptions.navigator.enabled,
                    <span class="hljs-literal">true</span>
                ),
                disableStartOnTick = navigatorEnabled ? {
                    <span class="hljs-attr">startOnTick</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">endOnTick</span>: <span class="hljs-literal">false</span>
                } : <span class="hljs-literal">null</span>,
                lineOptions = {
                    <span class="hljs-attr">marker</span>: {
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">radius</span>: <span class="hljs-number">2</span>
                    }
                },
                columnOptions = {
                    <span class="hljs-attr">shadow</span>: <span class="hljs-literal">false</span>,
                    <span class="hljs-attr">borderWidth</span>: <span class="hljs-number">0</span>
                };
            options.xAxis = map(splat(options.xAxis || {}), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xAxisOptions</span>) </span>{
                <span class="hljs-keyword">return</span> merge({
                        <span class="hljs-attr">minPadding</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">maxPadding</span>: <span class="hljs-number">0</span>,
                        <span class="hljs-attr">ordinal</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">title</span>: {
                            <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span>
                        },
                        <span class="hljs-attr">labels</span>: {
                            <span class="hljs-attr">overflow</span>: <span class="hljs-string">'justify'</span>
                        },
                        <span class="hljs-attr">showLastLabel</span>: <span class="hljs-literal">true</span>
                    },
                    defaultOptions.xAxis,
                    xAxisOptions, {
                        <span class="hljs-attr">type</span>: <span class="hljs-string">'datetime'</span>,
                        <span class="hljs-attr">categories</span>: <span class="hljs-literal">null</span>
                    },
                    disableStartOnTick
                );
            });
            options.yAxis = map(splat(options.yAxis || {}), <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">yAxisOptions</span>) </span>{
                opposite = pick(yAxisOptions.opposite, <span class="hljs-literal">true</span>);
                <span class="hljs-keyword">return</span> merge({
                        <span class="hljs-attr">labels</span>: {
                            <span class="hljs-attr">y</span>: <span class="hljs-number">-2</span>
                        },
                        <span class="hljs-attr">opposite</span>: opposite,
                        <span class="hljs-attr">showLastLabel</span>: <span class="hljs-literal">false</span>,
                        <span class="hljs-attr">title</span>: {
                            <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span>
                        }
                    },
                    defaultOptions.yAxis,
                    yAxisOptions
                );
            });
            options.series = <span class="hljs-literal">null</span>;
            options = merge({
                    <span class="hljs-attr">chart</span>: {
                        <span class="hljs-attr">panning</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">pinchType</span>: <span class="hljs-string">'x'</span>
                    },
                    <span class="hljs-attr">navigator</span>: {
                        <span class="hljs-attr">enabled</span>: navigatorEnabled
                    },
                    <span class="hljs-attr">scrollbar</span>: {
                        <span class="hljs-attr">enabled</span>: pick(defaultOptions.scrollbar.enabled, <span class="hljs-literal">true</span>)
                    },
                    <span class="hljs-attr">rangeSelector</span>: {
                        <span class="hljs-attr">enabled</span>: pick(defaultOptions.rangeSelector.enabled, <span class="hljs-literal">true</span>)
                    },
                    <span class="hljs-attr">title</span>: {
                        <span class="hljs-attr">text</span>: <span class="hljs-literal">null</span>
                    },
                    <span class="hljs-attr">tooltip</span>: {
                        <span class="hljs-attr">shared</span>: <span class="hljs-literal">true</span>,
                        <span class="hljs-attr">crosshairs</span>: <span class="hljs-literal">true</span>
                    },
                    <span class="hljs-attr">legend</span>: {
                        <span class="hljs-attr">enabled</span>: <span class="hljs-literal">false</span>
                    },
                    <span class="hljs-attr">plotOptions</span>: {
                        <span class="hljs-attr">line</span>: lineOptions,
                        <span class="hljs-attr">spline</span>: lineOptions,
                        <span class="hljs-attr">area</span>: lineOptions,
                        <span class="hljs-attr">areaspline</span>: lineOptions,
                        <span class="hljs-attr">arearange</span>: lineOptions,
                        <span class="hljs-attr">areasplinerange</span>: lineOptions,
                        <span class="hljs-attr">column</span>: columnOptions,
                        <span class="hljs-attr">columnrange</span>: columnOptions,
                        <span class="hljs-attr">candlestick</span>: columnOptions,
                        <span class="hljs-attr">ohlc</span>: columnOptions
                    }
                },
                options, {
                    <span class="hljs-attr">isStock</span>: <span class="hljs-literal">true</span>
                }
            );
            options.series = seriesOptions;
            <span class="hljs-keyword">return</span> hasRenderToArg ?
                <span class="hljs-keyword">new</span> Chart(a, options, c) :
                <span class="hljs-keyword">new</span> Chart(options, b);
        };
        wrap(Axis.prototype, <span class="hljs-string">'autoLabelAlign'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                options = <span class="hljs-keyword">this</span>.options,
                panes = chart._labelPanes = chart._labelPanes || {},
                key,
                labelOptions = <span class="hljs-keyword">this</span>.options.labels;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart.options.isStock &amp;&amp; <span class="hljs-keyword">this</span>.coll === <span class="hljs-string">'yAxis'</span>) {
                key = options.top + <span class="hljs-string">','</span> + options.height;
                <span class="hljs-keyword">if</span> (!panes[key] &amp;&amp; labelOptions.enabled) {
                    <span class="hljs-keyword">if</span> (labelOptions.x === <span class="hljs-number">15</span>) {
                        labelOptions.x = <span class="hljs-number">0</span>;
                    }
                    <span class="hljs-keyword">if</span> (labelOptions.align === <span class="hljs-literal">undefined</span>) {
                        labelOptions.align = <span class="hljs-string">'right'</span>;
                    }
                    panes[key] = <span class="hljs-number">1</span>;
                    <span class="hljs-keyword">return</span> <span class="hljs-string">'right'</span>;
                }
            }
            <span class="hljs-keyword">return</span> proceed.call(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
        });
        wrap(Axis.prototype, <span class="hljs-string">'getPlotLinePath'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, value, lineWidth, old, force, translatedValue</span>) </span>{
            <span class="hljs-keyword">var</span> axis = <span class="hljs-keyword">this</span>,
                series = (<span class="hljs-keyword">this</span>.isLinked &amp;&amp; !<span class="hljs-keyword">this</span>.series ? <span class="hljs-keyword">this</span>.linkedParent.series : <span class="hljs-keyword">this</span>.series),
                chart = axis.chart,
                renderer = chart.renderer,
                axisLeft = axis.left,
                axisTop = axis.top,
                x1,
                y1,
                x2,
                y2,
                result = [],
                axes = [],
                axes2,
                uniqueAxes,
                transVal;

            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAxis</span>(<span class="hljs-params">coll</span>) </span>{
                <span class="hljs-keyword">var</span> otherColl = coll === <span class="hljs-string">'xAxis'</span> ? <span class="hljs-string">'yAxis'</span> : <span class="hljs-string">'xAxis'</span>,
                    opt = axis.options[otherColl];
                <span class="hljs-keyword">if</span> (isNumber(opt)) {
                    <span class="hljs-keyword">return</span> [chart[otherColl][opt]];
                }
                <span class="hljs-keyword">if</span> (isString(opt)) {
                    <span class="hljs-keyword">return</span> [chart.get(opt)];
                }
                <span class="hljs-keyword">return</span> map(series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>{
                    <span class="hljs-keyword">return</span> s[otherColl];
                });
            }
            <span class="hljs-keyword">if</span> (axis.coll === <span class="hljs-string">'colorAxis'</span>) {
                <span class="hljs-keyword">return</span> proceed.apply(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            }
            axes = getAxis(axis.coll);
            axes2 = (axis.isXAxis ? chart.yAxis : chart.xAxis);
            each(axes2, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">A</span>) </span>{
                <span class="hljs-keyword">if</span> (defined(A.options.id) ? A.options.id.indexOf(<span class="hljs-string">'navigator'</span>) === <span class="hljs-number">-1</span> : <span class="hljs-literal">true</span>) {
                    <span class="hljs-keyword">var</span> a = (A.isXAxis ? <span class="hljs-string">'yAxis'</span> : <span class="hljs-string">'xAxis'</span>),
                        rax = (defined(A.options[a]) ? chart[a][A.options[a]] : chart[a][<span class="hljs-number">0</span>]);
                    <span class="hljs-keyword">if</span> (axis === rax) {
                        axes.push(A);
                    }
                }
            });
            uniqueAxes = axes.length ? [] : [axis.isXAxis ? chart.yAxis[<span class="hljs-number">0</span>] : chart.xAxis[<span class="hljs-number">0</span>]];
            each(axes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis2</span>) </span>{
                <span class="hljs-keyword">if</span> (inArray(axis2, uniqueAxes) === <span class="hljs-number">-1</span>) {
                    uniqueAxes.push(axis2);
                }
            });
            transVal = pick(translatedValue, axis.translate(value, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, old));
            <span class="hljs-keyword">if</span> (isNumber(transVal)) {
                <span class="hljs-keyword">if</span> (axis.horiz) {
                    each(uniqueAxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis2</span>) </span>{
                        <span class="hljs-keyword">var</span> skip;
                        y1 = axis2.pos;
                        y2 = y1 + axis2.len;
                        x1 = x2 = <span class="hljs-built_in">Math</span>.round(transVal + axis.transB);
                        <span class="hljs-keyword">if</span> (x1 &lt; axisLeft || x1 &gt; axisLeft + axis.width) {
                            <span class="hljs-keyword">if</span> (force) {
                                x1 = x2 = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(axisLeft, x1), axisLeft + axis.width);
                            } <span class="hljs-keyword">else</span> {
                                skip = <span class="hljs-literal">true</span>;
                            }
                        }
                        <span class="hljs-keyword">if</span> (!skip) {
                            result.push(<span class="hljs-string">'M'</span>, x1, y1, <span class="hljs-string">'L'</span>, x2, y2);
                        }
                    });
                } <span class="hljs-keyword">else</span> {
                    each(uniqueAxes, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">axis2</span>) </span>{
                        <span class="hljs-keyword">var</span> skip;
                        x1 = axis2.pos;
                        x2 = x1 + axis2.len;
                        y1 = y2 = <span class="hljs-built_in">Math</span>.round(axisTop + axis.height - transVal);
                        <span class="hljs-keyword">if</span> (y1 &lt; axisTop || y1 &gt; axisTop + axis.height) {
                            <span class="hljs-keyword">if</span> (force) {
                                y1 = y2 = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(axisTop, y1), axis.top + axis.height);
                            } <span class="hljs-keyword">else</span> {
                                skip = <span class="hljs-literal">true</span>;
                            }
                        }
                        <span class="hljs-keyword">if</span> (!skip) {
                            result.push(<span class="hljs-string">'M'</span>, x1, y1, <span class="hljs-string">'L'</span>, x2, y2);
                        }
                    });
                }
            }
            <span class="hljs-keyword">return</span> result.length &gt; <span class="hljs-number">0</span> ?
                renderer.crispPolyLine(result, lineWidth || <span class="hljs-number">1</span>) :
                <span class="hljs-literal">null</span>;
        });
        Axis.prototype.getPlotBandPath = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">from, to</span>) </span>{
            <span class="hljs-keyword">var</span> toPath = <span class="hljs-keyword">this</span>.getPlotLinePath(to, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>),
                path = <span class="hljs-keyword">this</span>.getPlotLinePath(<span class="hljs-keyword">from</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>),
                result = [],
                i;
            <span class="hljs-keyword">if</span> (path &amp;&amp; toPath) {
                <span class="hljs-keyword">if</span> (path.toString() === toPath.toString()) {
                    result = path;
                    result.flat = <span class="hljs-literal">true</span>;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; path.length; i += <span class="hljs-number">6</span>) {
                        result.push(
                            <span class="hljs-string">'M'</span>, path[i + <span class="hljs-number">1</span>], path[i + <span class="hljs-number">2</span>],
                            <span class="hljs-string">'L'</span>, path[i + <span class="hljs-number">4</span>], path[i + <span class="hljs-number">5</span>],
                            toPath[i + <span class="hljs-number">4</span>], toPath[i + <span class="hljs-number">5</span>],
                            toPath[i + <span class="hljs-number">1</span>], toPath[i + <span class="hljs-number">2</span>],
                            <span class="hljs-string">'z'</span>
                        );
                    }
                }
            } <span class="hljs-keyword">else</span> {
                result = <span class="hljs-literal">null</span>;
            }
            <span class="hljs-keyword">return</span> result;
        };
        SVGRenderer.prototype.crispPolyLine = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">points, width</span>) </span>{
            <span class="hljs-keyword">var</span> i;
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; points.length; i = i + <span class="hljs-number">6</span>) {
                <span class="hljs-keyword">if</span> (points[i + <span class="hljs-number">1</span>] === points[i + <span class="hljs-number">4</span>]) {
                    points[i + <span class="hljs-number">1</span>] = points[i + <span class="hljs-number">4</span>] = <span class="hljs-built_in">Math</span>.round(points[i + <span class="hljs-number">1</span>]) - (width % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>);
                }
                <span class="hljs-keyword">if</span> (points[i + <span class="hljs-number">2</span>] === points[i + <span class="hljs-number">5</span>]) {
                    points[i + <span class="hljs-number">2</span>] = points[i + <span class="hljs-number">5</span>] = <span class="hljs-built_in">Math</span>.round(points[i + <span class="hljs-number">2</span>]) + (width % <span class="hljs-number">2</span> / <span class="hljs-number">2</span>);
                }
            }
            <span class="hljs-keyword">return</span> points;
        };
        <span class="hljs-keyword">if</span> (Renderer === VMLRenderer) {
            VMLRenderer.prototype.crispPolyLine = SVGRenderer.prototype.crispPolyLine;
        }
        wrap(Axis.prototype, <span class="hljs-string">'hideCrosshair'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, i</span>) </span>{
            proceed.call(<span class="hljs-keyword">this</span>, i);
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.crossLabel) {
                <span class="hljs-keyword">this</span>.crossLabel = <span class="hljs-keyword">this</span>.crossLabel.hide();
            }
        });
        wrap(Axis.prototype, <span class="hljs-string">'drawCrosshair'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed, e, point</span>) </span>{
            proceed.call(<span class="hljs-keyword">this</span>, e, point);
            <span class="hljs-keyword">if</span> (!defined(<span class="hljs-keyword">this</span>.crosshair.label) || !<span class="hljs-keyword">this</span>.crosshair.label.enabled || !<span class="hljs-keyword">this</span>.cross) {
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">var</span> chart = <span class="hljs-keyword">this</span>.chart,
                options = <span class="hljs-keyword">this</span>.options.crosshair.label,
                horiz = <span class="hljs-keyword">this</span>.horiz,
                opposite = <span class="hljs-keyword">this</span>.opposite,
                left = <span class="hljs-keyword">this</span>.left,
                top = <span class="hljs-keyword">this</span>.top,
                crossLabel = <span class="hljs-keyword">this</span>.crossLabel,
                posx,
                posy,
                crossBox,
                formatOption = options.format,
                formatFormat = <span class="hljs-string">''</span>,
                limit,
                align,
                tickInside = <span class="hljs-keyword">this</span>.options.tickPosition === <span class="hljs-string">'inside'</span>,
                snap = <span class="hljs-keyword">this</span>.crosshair.snap !== <span class="hljs-literal">false</span>,
                value,
                offset = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (!e) {
                e = <span class="hljs-keyword">this</span>.cross &amp;&amp; <span class="hljs-keyword">this</span>.cross.e;
            }
            align = (horiz ? <span class="hljs-string">'center'</span> : opposite ?
                (<span class="hljs-keyword">this</span>.labelAlign === <span class="hljs-string">'right'</span> ? <span class="hljs-string">'right'</span> : <span class="hljs-string">'left'</span>) :
                (<span class="hljs-keyword">this</span>.labelAlign === <span class="hljs-string">'left'</span> ? <span class="hljs-string">'left'</span> : <span class="hljs-string">'center'</span>));
            <span class="hljs-keyword">if</span> (!crossLabel) {
                crossLabel = <span class="hljs-keyword">this</span>.crossLabel = chart.renderer.label(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, options.shape || <span class="hljs-string">'callout'</span>)
                    .addClass(<span class="hljs-string">'highcharts-crosshair-label'</span> +
                        (<span class="hljs-keyword">this</span>.series[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-string">' highcharts-color-'</span> + <span class="hljs-keyword">this</span>.series[<span class="hljs-number">0</span>].colorIndex))
                    .attr({
                        <span class="hljs-attr">align</span>: options.align || align,
                        <span class="hljs-attr">padding</span>: pick(options.padding, <span class="hljs-number">8</span>),
                        <span class="hljs-attr">r</span>: pick(options.borderRadius, <span class="hljs-number">3</span>),
                        <span class="hljs-attr">zIndex</span>: <span class="hljs-number">2</span>
                    })
                    .add(<span class="hljs-keyword">this</span>.labelGroup);
                crossLabel
                    .attr({
                        <span class="hljs-attr">fill</span>: options.backgroundColor ||
                            (<span class="hljs-keyword">this</span>.series[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-keyword">this</span>.series[<span class="hljs-number">0</span>].color) || <span class="hljs-string">'#666666'</span>,
                        <span class="hljs-attr">stroke</span>: options.borderColor || <span class="hljs-string">''</span>,
                        <span class="hljs-string">'stroke-width'</span>: options.borderWidth || <span class="hljs-number">0</span>
                    })
                    .css(extend({
                        <span class="hljs-attr">color</span>: <span class="hljs-string">'#ffffff'</span>,
                        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">'normal'</span>,
                        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">'11px'</span>,
                        <span class="hljs-attr">textAlign</span>: <span class="hljs-string">'center'</span>
                    }, options.style));
            }
            <span class="hljs-keyword">if</span> (horiz) {
                posx = snap ? point.plotX + left : e.chartX;
                posy = top + (opposite ? <span class="hljs-number">0</span> : <span class="hljs-keyword">this</span>.height);
            } <span class="hljs-keyword">else</span> {
                posx = opposite ? <span class="hljs-keyword">this</span>.width + left : <span class="hljs-number">0</span>;
                posy = snap ? point.plotY + top : e.chartY;
            }
            <span class="hljs-keyword">if</span> (!formatOption &amp;&amp; !options.formatter) {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDatetimeAxis) {
                    formatFormat = <span class="hljs-string">'%b %d, %Y'</span>;
                }
                formatOption = <span class="hljs-string">'{value'</span> + (formatFormat ? <span class="hljs-string">':'</span> + formatFormat : <span class="hljs-string">''</span>) + <span class="hljs-string">'}'</span>;
            }
            value = snap ? point[<span class="hljs-keyword">this</span>.isXAxis ? <span class="hljs-string">'x'</span> : <span class="hljs-string">'y'</span>] : <span class="hljs-keyword">this</span>.toValue(horiz ? e.chartX : e.chartY);
            crossLabel.attr({
                <span class="hljs-attr">text</span>: formatOption ? format(formatOption, {
                    <span class="hljs-attr">value</span>: value
                }) : options.formatter.call(<span class="hljs-keyword">this</span>, value),
                <span class="hljs-attr">x</span>: posx,
                <span class="hljs-attr">y</span>: posy,
                <span class="hljs-attr">visibility</span>: <span class="hljs-string">'visible'</span>
            });
            crossBox = crossLabel.getBBox();
            <span class="hljs-keyword">if</span> (horiz) {
                <span class="hljs-keyword">if</span> ((tickInside &amp;&amp; !opposite) || (!tickInside &amp;&amp; opposite)) {
                    posy = crossLabel.y - crossBox.height;
                }
            } <span class="hljs-keyword">else</span> {
                posy = crossLabel.y - (crossBox.height / <span class="hljs-number">2</span>);
            }
            <span class="hljs-keyword">if</span> (horiz) {
                limit = {
                    <span class="hljs-attr">left</span>: left - crossBox.x,
                    <span class="hljs-attr">right</span>: left + <span class="hljs-keyword">this</span>.width - crossBox.x
                };
            } <span class="hljs-keyword">else</span> {
                limit = {
                    <span class="hljs-attr">left</span>: <span class="hljs-keyword">this</span>.labelAlign === <span class="hljs-string">'left'</span> ? left : <span class="hljs-number">0</span>,
                    <span class="hljs-attr">right</span>: <span class="hljs-keyword">this</span>.labelAlign === <span class="hljs-string">'right'</span> ? left + <span class="hljs-keyword">this</span>.width : chart.chartWidth
                };
            }
            <span class="hljs-keyword">if</span> (crossLabel.translateX &lt; limit.left) {
                offset = limit.left - crossLabel.translateX;
            }
            <span class="hljs-keyword">if</span> (crossLabel.translateX + crossBox.width &gt;= limit.right) {
                offset = -(crossLabel.translateX + crossBox.width - limit.right);
            }
            crossLabel.attr({
                <span class="hljs-attr">x</span>: posx + offset,
                <span class="hljs-attr">y</span>: posy,
                <span class="hljs-attr">anchorX</span>: horiz ? posx : (<span class="hljs-keyword">this</span>.opposite ? <span class="hljs-number">0</span> : chart.chartWidth),
                <span class="hljs-attr">anchorY</span>: horiz ? (<span class="hljs-keyword">this</span>.opposite ? chart.chartHeight : <span class="hljs-number">0</span>) : posy + crossBox.height / <span class="hljs-number">2</span>
            });
        });
        seriesProto.init = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            seriesInit.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
            <span class="hljs-keyword">this</span>.setCompare(<span class="hljs-keyword">this</span>.options.compare);
        };
        seriesProto.setCompare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">compare</span>) </span>{
            <span class="hljs-keyword">this</span>.modifyValue = (compare === <span class="hljs-string">'value'</span> || compare === <span class="hljs-string">'percent'</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, point</span>) </span>{
                <span class="hljs-keyword">var</span> compareValue = <span class="hljs-keyword">this</span>.compareValue;
                <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">undefined</span> &amp;&amp; compareValue !== <span class="hljs-literal">undefined</span>) {
                    <span class="hljs-keyword">if</span> (compare === <span class="hljs-string">'value'</span>) {
                        value -= compareValue;
                    } <span class="hljs-keyword">else</span> {
                        value = <span class="hljs-number">100</span> * (value / compareValue) -
                            (<span class="hljs-keyword">this</span>.options.compareBase === <span class="hljs-number">100</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">100</span>);
                    }
                    <span class="hljs-keyword">if</span> (point) {
                        point.change = value;
                    }
                    <span class="hljs-keyword">return</span> value;
                }
            } : <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">this</span>.userOptions.compare = compare;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart.hasRendered) {
                <span class="hljs-keyword">this</span>.isDirty = <span class="hljs-literal">true</span>;
            }
        };
        seriesProto.processData = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">var</span> series = <span class="hljs-keyword">this</span>,
                i,
                keyIndex = <span class="hljs-number">-1</span>,
                processedXData,
                processedYData,
                length,
                compareValue;
            seriesProcessData.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
            <span class="hljs-keyword">if</span> (series.xAxis &amp;&amp; series.processedYData) {
                processedXData = series.processedXData;
                processedYData = series.processedYData;
                length = processedYData.length;
                <span class="hljs-keyword">if</span> (series.pointArrayMap) {
                    keyIndex = inArray(<span class="hljs-string">'close'</span>, series.pointArrayMap);
                    <span class="hljs-keyword">if</span> (keyIndex === <span class="hljs-number">-1</span>) {
                        keyIndex = inArray(series.pointValKey || <span class="hljs-string">'y'</span>, series.pointArrayMap);
                    }
                }
                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) {
                    compareValue = keyIndex &gt; <span class="hljs-number">-1</span> ?
                        processedYData[i][keyIndex] :
                        processedYData[i];
                    <span class="hljs-keyword">if</span> (isNumber(compareValue) &amp;&amp; processedXData[i + <span class="hljs-number">1</span>] &gt;= series.xAxis.min &amp;&amp; compareValue !== <span class="hljs-number">0</span>) {
                        series.compareValue = compareValue;
                        <span class="hljs-keyword">break</span>;
                    }
                }
            }
        };
        wrap(seriesProto, <span class="hljs-string">'getExtremes'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">var</span> extremes;
            proceed.apply(<span class="hljs-keyword">this</span>, [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>));
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.modifyValue) {
                extremes = [<span class="hljs-keyword">this</span>.modifyValue(<span class="hljs-keyword">this</span>.dataMin), <span class="hljs-keyword">this</span>.modifyValue(<span class="hljs-keyword">this</span>.dataMax)];
                <span class="hljs-keyword">this</span>.dataMin = arrayMin(extremes);
                <span class="hljs-keyword">this</span>.dataMax = arrayMax(extremes);
            }
        });
        Axis.prototype.setCompare = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">compare, redraw</span>) </span>{
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isXAxis) {
                each(<span class="hljs-keyword">this</span>.series, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">series</span>) </span>{
                    series.setCompare(compare);
                });
                <span class="hljs-keyword">if</span> (pick(redraw, <span class="hljs-literal">true</span>)) {
                    <span class="hljs-keyword">this</span>.chart.redraw();
                }
            }
        };
        Point.prototype.tooltipFormatter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">pointFormat</span>) </span>{
            <span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>;
            pointFormat = pointFormat.replace(
                <span class="hljs-string">'{point.change}'</span>,
                (point.change &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">'+'</span> : <span class="hljs-string">''</span>) +
                H.numberFormat(point.change, pick(point.series.tooltipOptions.changeDecimals, <span class="hljs-number">2</span>))
            );
            <span class="hljs-keyword">return</span> pointTooltipFormatter.apply(<span class="hljs-keyword">this</span>, [pointFormat]);
        };
        wrap(Series.prototype, <span class="hljs-string">'render'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proceed</span>) </span>{
            <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span>.chart.is3d &amp;&amp; <span class="hljs-keyword">this</span>.chart.is3d()) &amp;&amp;
                !<span class="hljs-keyword">this</span>.chart.polar &amp;&amp;
                <span class="hljs-keyword">this</span>.xAxis &amp;&amp;
                !<span class="hljs-keyword">this</span>.xAxis.isRadial
            ) {
                <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.clipBox &amp;&amp; <span class="hljs-keyword">this</span>.animate) {
                    <span class="hljs-keyword">this</span>.clipBox = merge(<span class="hljs-keyword">this</span>.chart.clipBox);
                    <span class="hljs-keyword">this</span>.clipBox.width = <span class="hljs-keyword">this</span>.xAxis.len;
                    <span class="hljs-keyword">this</span>.clipBox.height = <span class="hljs-keyword">this</span>.yAxis.len;
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.chart[<span class="hljs-keyword">this</span>.sharedClipKey]) {
                    <span class="hljs-keyword">this</span>.chart[<span class="hljs-keyword">this</span>.sharedClipKey].attr({
                        <span class="hljs-attr">width</span>: <span class="hljs-keyword">this</span>.xAxis.len,
                        <span class="hljs-attr">height</span>: <span class="hljs-keyword">this</span>.yAxis.len
                    });
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.clipBox) {
                    <span class="hljs-keyword">this</span>.clipBox.width = <span class="hljs-keyword">this</span>.xAxis.len;
                    <span class="hljs-keyword">this</span>.clipBox.height = <span class="hljs-keyword">this</span>.yAxis.len;
                }
            }
            proceed.call(<span class="hljs-keyword">this</span>);
        });
    }(Highcharts));
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-meta">        'use strict'</span>;
    }());
    <span class="hljs-keyword">return</span> Highcharts
}));;</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
